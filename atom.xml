<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuxinhua.com/"/>
  <updated>2021-08-06T11:07:42.481Z</updated>
  <id>https://wuxinhua.com/</id>
  
  <author>
    <name>wuxinhua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>放弃 newsfeed 拥抱 Newsletter</title>
    <link href="https://wuxinhua.com/2021/08/02/Newsletter-List-I-Subscribed/"/>
    <id>https://wuxinhua.com/2021/08/02/Newsletter-List-I-Subscribed/</id>
    <published>2021-08-02T10:32:21.000Z</published>
    <updated>2021-08-06T11:07:42.481Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com/blog/assets/newsletter/newsletter.png" alt></p><h2 id="关于-Newsletter"><a href="#关于-Newsletter" class="headerlink" title="关于 Newsletter"></a>关于 Newsletter</h2><p>2006 年 Facebook 上线了 NewsFeed 功能，不禁感叹，这个依赖用户的社交网络以及算法建立的系统已经存在了超过了尽 10 年。我们每天都接触或被动输入海量的信息，有句话说你吃什么，你就是什么，同理这句话在信息获取上也是类似的，你读什么你就是什么；在国内我们会通过关注微信的公众号来获得每天的新闻动态，在国外也有类似的一个信息聚合产品，不太一样的是它通过邮件来订阅的，接受 Newsletter 的主体大多是读者的个人邮箱，按获取信息的方式可以简单地分为主动型或被动型，可以使用资讯 APP 接受系统推送的信息，也可以选择邮箱在固定时间等待一封带聚合信息的邮件，Newsletter 和 RSS 订阅大概是信息爆炸时代中少有的不受到干扰又能确保获得优质内容源的方式了，下面是我日常收集的一些跟 Newsletter 相关的应用、网站、及我订阅的一些 Newsletter 资源。发现作为一个个体，我每天都会重复以下事情：呼吸空气，消耗粮食，阅读书籍…，我几乎是不断地在“消费”，却很少去做“生产”，去分享或者对知识的扩展、影响做出一些努力，所以最近也在考虑把每周阅读感想收获、浴室迷思、idea等整理沉淀，尝试以 Newsletter 这种方式分享出来，当然还在规划中，期待有一天末尾能加上自己的订阅地址。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="https://substack.com/" target="_blank" rel="noopener">substack.com</a> 一个新兴的 Newsletter 创作平台，19 年获得了 a16z 提供的 1530 万美元投资</li><li><a href="https://hedwig.pub/" target="_blank" rel="noopener">hedwig.pub</a> 即刻的一位工程师开发的 Newsletter 订阅工具</li><li><a href="https://stoopinbox.com/" target="_blank" rel="noopener">stoopinbox.com</a> 是一个 Newsletter 的订阅工具 APP</li><li>方可成老师做了一个 <a href="https://www.notion.so/kfang/Newsletter-68ee46c0a4574f659fb8a873ead438c6" target="_blank" rel="noopener">中文 Newsletter 导航</a>，汇集了比较多的 Newsletter 链接，给他点赞</li><li><a href="https://newslab2020.github.io/Collection/%E5%AA%92%E4%BD%93%E9%A3%9F%E8%B0%B1/%5B%E6%96%B0%E9%97%BB%E5%AE%9E%E9%AA%8C%E5%AE%A4%5D%20-%202017-05-10%20%E6%8A%8A%E4%BD%A0%E7%9A%84%E9%82%AE%E7%AE%B1%E8%B0%83%E6%95%99%E6%88%90%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%B0%E9%97%BB%E9%98%85%E8%AF%BB%E5%99%A8%EF%BD%9C%E5%AA%92%E4%BD%93%E9%A3%9F%E8%B0%B107.html" target="_blank" rel="noopener">把你的邮箱调教成最好的新闻阅读器</a></li><li><a href="https://sspai.com/post/62935" target="_blank" rel="noopener">产品经理应订阅的中文 Newsletter 有哪些？</a> PM 产品相关的 Newsletter</li><li><a href="https://zhuanlan.zhihu.com/p/22463740" target="_blank" rel="noopener">用户体验设计国外「公众号</a></li></ul><h2 id="我的订阅"><a href="#我的订阅" class="headerlink" title="我的订阅"></a>我的订阅</h2><ul><li><p><a href="https://www.getrevue.co/profile/newslab?utm_campaign=%E6%96%B0%E9%97%BB%E5%AE%9E%E9%AA%8C%E5%AE%A4&amp;utm_medium=email&amp;utm_source=Revue%20Newsletter" target="_blank" rel="noopener">新闻实验室</a> 新闻传播学者方可成老师运营的 Newsletter，内容涵盖全球传媒业和数字科技产业最新热点、学术研究成果等。</p></li><li><p><a href="https://xiao.do/?utm_campaign=happy%20letter&amp;utm_medium=email&amp;utm_source=Revue%20Newsletter" target="_blank" rel="noopener">happy letter By Happy xiao</a> 每周提供关于个人效率和思维方式的好点子，帮你成为更好的自己，主要聚焦于效率提升和工具推荐等。</p></li><li><p><a href="https://enzochen.substack.com/about?utm_source=menu-dropdown" target="_blank" rel="noopener">推播助栏</a> 由撰稿人Enzo Chen创办的一份关于中文Podcast的Newsletter，广泛关注中国大陆、台湾和海外的中文Podcast的节目和最新动态，聚焦于 podcast 节目</p></li><li><p><a href="https://steve.hedwig.pub/" target="_blank" rel="noopener">Steve说每周通讯</a> 由每周嘉宾推荐的精选优质内容，目前推荐组成员包括：心理学者读者、社会心理学博士、心理咨询师和心理博主等</p></li><li><p><a href="https://anyway.fm/news/" target="_blank" rel="noopener">Anyway.FM 安泥薇时报</a> Anyway.FM 设计杂谈是一档播客节目，由 UI 设计师 JJ Ying 和 Leon Gao 主播创办，关注的主要内容是 UI/UX 设计相关</p></li><li><p><a href="https://via.hedwig.pub/" target="_blank" rel="noopener">事不过三</a> 阅读相关，推荐一些自己在学或者值得一学的内容</p></li><li><p><a href="https://m.littlefat.cn/" target="_blank" rel="noopener">小胖 LittleFat</a> 日常所想，记录博主日常发现的一些东西，内容比较随意</p></li></ul><p>订阅的 list 会持续更新，更多的资源详见上方提到的 Newsletter 导航；如果你也在创作或使用 Newsletter ，有好的订阅资源推荐，欢迎通过邮箱和我交流联系，以上~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com/blog/assets/newsletter/newsletter.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-Newsletter&quot;&gt;&lt;a href=&quot;#关于-Newsletter&quot; cla
      
    
    </summary>
    
    
      <category term="Newsletter订阅" scheme="https://wuxinhua.com/tags/Newsletter%E8%AE%A2%E9%98%85/"/>
    
  </entry>
  
  <entry>
    <title>混迹于 Clubhouse 两周后的一些想法🤔</title>
    <link href="https://wuxinhua.com/2021/02/18/Discussion-On-The-Popularity-Of-Clubhouse/"/>
    <id>https://wuxinhua.com/2021/02/18/Discussion-On-The-Popularity-Of-Clubhouse/</id>
    <published>2021-02-18T12:04:46.000Z</published>
    <updated>2021-03-09T11:00:18.191Z</updated>
    
    <content type="html"><![CDATA[<p>Clubhouse (后面简称 CH) 无疑是过去一个月互联网圈最热门的在线语音聊天软件，年前硅谷“带货大王” Elon Musk 的一场线上语音<a href="https://www.joinclubhouse.com/event/PQ488GWn" target="_blank" rel="noopener">聊天预告</a>让 CH 相关话题在Twitter上又火了一把。我大约是年底在 Twitter 第一次了解到它, 一个偶然的机会在公司飞书群里拿到了一个邀请名额，前后陆续玩了将近两周的时间，查看了一下我春节假期的屏幕使用时间统计，日均在 8 个小时左右，平均下来每天有1.5小时左右用在了 CH 上，除了邀请好友、follow 一些 KOL 外，日常流窜混迹于各种 room 之间，听各行各业的“大佬”们传授经验、讲故事，总体下来还是有些收获，今天来聊一聊这款产品以及这段时间使用后的一些体验，现在来写这篇产品体验可能有些晚了，CH 在春节前在大陆被墙，国内手机号码已经无法再收到邀请短信，但这款社交软件的确值得研究并且给我的春节增加了很多乐趣。</p><p><img src="https://assets.wuxinhua.com/blog/assets/clubhouse/elon_musk_twitter_clubhouse.png" alt></p><h2 id="关于-Clubhouse-及核心玩法"><a href="#关于-Clubhouse-及核心玩法" class="headerlink" title="关于 Clubhouse 及核心玩法"></a>关于 Clubhouse 及核心玩法</h2><p>CH 是一个实时在线语音群聊产品，与其它语音聊天产品不同的是在 CH 房间里只能以音频形式交流，你可以创建房间组织其他人来讲、听，你也可以进入任何房间听大家在聊什么，在 CH 里你可以直接 follow 任何你感兴趣的用户，另外 CH 的日历系统会标记已经预定内容、时间的 room，你可以根据兴趣来选择是否按时参加。这里简单介绍一下其它的一些玩法：</p><p><img src="https://assets.wuxinhua.com/blog/assets/clubhouse/clubhouse.png" alt></p><ul><li>CH 有两种创建聊天的方式：以 Club 为单位开启一个聊天，这个 Club 可以长期存在，需提交申请，Club 在房间的顶部有个 🏡 标识加以区分，另一种是以 “room” 房间为聊天单元，房间内没有用户后会被回收，每个房间目前最多可容纳 5000 人同时在线，而 Club 目前无限制 </li><li>当前只有 iOS 版应用，而且基于通讯录手机号码邀请制，一般情况下每个用户登录后会有两个邀请码，如果你在 CH 比较活跃，用完邀请名额系统陆续会再额外赠送邀请码（邀请用户时请先在通讯录添加对方号码，这里需要注意的是添加号码区号，踩过坑）</li><li>CH 可以开三种类型的房： 公开、社交、私密，分别代表对所有人公开开放、向我关注的人开放及只对手动拉进来的人开放</li><li>CH 不提倡录音，录音等操作把 room 里的交流数据外泄有可能导致账号被封或撤销，并且 CH 采用连坐制度，如果你被 Ban 的话会有可能导致邀请你的人也被 ban 了</li><li>多 follow 一些用户或 club 能在首页看到更多的 room 以及其他用户日历的房间安排信息</li><li>CH 可以在 schedule “日历” 上设定下一个 room，制定房间的主题及时间，那关注了你的用户就能看到这个 schedule 进行订阅，room 开始前会收到相关通知</li><li><p>在每个交流的房间里，有主持⼈（moderator），讲话人（speaker），听众（listener）三个角色，角色可以互相转换</p><ul><li><p>主持⼈<br>当你创建并开始了一个房间，那么你就是这个房间的 moderator 主持人, 你可以主动邀请下面用户上来讲话，当有人想参与聊天时需要先“举手”，modorator (主持人)同意后把你提升到 Speaker 区即可开麦畅聊，moderator 也拥有添加或移除其它主持人的权利；主持人应该适当地对房间进行管理，例如决定邀请哪些人上来当 “speaker”，当房间冷场或有人讨论时间过长的时候进行适当干预；moderator 拥有的权利：</p><ul><li>指派 moderator</li><li>邀请听众上台成为 speaker</li><li>mute 听者的麦克风</li><li>将 speaker 请回观众席</li><li>将任何人剔出房间</li></ul></li><li><p>演讲者<br>翻译成演讲者可能不是很合适，可以简单地理解成想开麦讲话的人，当你想上来分享你的观点的时候举手示意即可，经主持人同意后可以开麦聊天，当你是一个 speaker 身份的时候记得 mute 你的麦克风，这样不会干扰到正在讲话的人，如果某个 speaker 讲得好，大家通常会通过切换 mute/unmute 按钮闪烁麦克风 icon 来表示鼓掌或赞同</p></li><li>听众<br>作为一个倾听者也是一件很幸福的事</li></ul></li></ul><h2 id="RTC-技术及-Clubhouse-背后的声网"><a href="#RTC-技术及-Clubhouse-背后的声网" class="headerlink" title="RTC 技术及 Clubhouse 背后的声网"></a>RTC 技术及 Clubhouse 背后的声网</h2><h3 id="声网这家公司"><a href="#声网这家公司" class="headerlink" title="声网这家公司"></a>声网这家公司</h3><p> 随着 CH 的爆火，提供底层技术支持的音频服务商声网股价也涨了不少(致富代码$API), 对这家公司稍微有一些了解，但没有用声网的 SDK 开发过东西，记得是在 19 年的声网 SDK 体验征文大赛第一次听到这家公司，当时为这个活动还在掘金开发了一个<a href="https://juejin.cn/e/agora" target="_blank" rel="noopener">专题页</a>，感兴趣的可以去看下开发者用声网 SDK 做的东西和文章分享；声网 2014 年在硅谷成立，其创立最初的定位是一家为 App 开发者提供全球范围实时音视频通信服务的服务商，目前市场上也有其他一些在这个领域发力或已经占据了比较好的市场份额的公司，例如网易云信、融云、twillio、腾讯云等，开源的 WebRTC 技术只是实现音频视频技术栈中的一部分，包括音视频的编解码、网络通讯、发言、禁言这些都基于信令的传播，这里还得保证信令的不丢失和实时到达问题，即时通讯与实时音视频技术协同而且需求会有重合，现在很多 IM 通讯软件会把实时的音视频通讯作为一项基础能力服务，或者整合到一起打包出售服务，上面的几个厂商侧重点也有所不同，例如声网是专注于 Paas 层的实时互动云服务，Twilio 则面向开发者提供封装了基础通信能力的软件工具包，覆盖短信、语音、聊天、邮件、视频等通信能力，涉及领域包括双因素认证、WebRTC、联络中心分析，逐渐向 Saas 领域扩展能力；声网 RTE Pass 产品体系中除了提供视频音频产品外，也提供像实时消息、录制、实时码流加速、质量监控等产品，而核心是 SDK 和底层的 SD-RTC（软件定义实时网）；SD-RTC(software-defined real time network) 是声网研发的软件实时传输网络，专门为实时内容传输设计的网络架构，它使用 UDP 作为底层传输协议，SD-RTN 部署在全球超过 200 个地区和国家，根据用户的分布情况，选择可靠、短延时的路线，另外通过算法优化传输能力，侧重点在于解决延时和卡顿的问题；另一个核心是服务 API化，把实时音频技术做成简单的 API，开发者只需要集成简单的 SDK 就能快速让 APP 实现高清语音视频通话。</p><h3 id="RTC-及-WebRTC"><a href="#RTC-及-WebRTC" class="headerlink" title="RTC 及 WebRTC"></a>RTC 及 WebRTC</h3><blockquote><p>WebRTC is a new front in the long war for an open and unencumbered web.</p><p>—— Brendan Eich, inventor of JavaScript</p></blockquote><p> 这里简要介绍下 WebRTC, 需要注意的是 RTC 和 WebRTC 还是有一些区别，RTC 全称 Real-time Communications，直译或者广义指实时通信，狭义一般称为实时音视频通信，最典型的应用是视频会议的实施音频通话、直播等，而 WebRTC 是 RTC 技术中的一部分，WebRTC — Web browsers with Real-Time Communications 是一个由谷歌主导的通信服务标准，也是开源项目，简单来说就是在浏览器中实现实时的音频视频和数据的通信，目前在主流的浏览器中都已经支持。在 RTC 通信中音频的采集和处理都是比较复杂的过程，比如音频流的编码解码、降噪等，在 webRTC 中这些都是已经由浏览器的底层封装完成，双方只需要安装浏览器即可建立点对点的链接实现音视频的实时通信。WebRTC 架构图如下图:</p><ul><li>最上层提供了供开发人员使用的 API，我们在这些接口上去进行我们的业务层开发</li><li>中间部分 VoiceEngine 、VideoEngine 部分主要是对声音、视频的处理，包括常见的编码、回音消除、噪音降低、图像增强等，Transport 部分负责数据的传输，在传输方式上 WebRTC 采用基于 UDP 的 SRTP 协议</li><li><p>底层是声音、视频的输入获取、网络 IO 等</p><p><img src="https://assets.wuxinhua.com/blog/assets/clubhouse/webrtc.png" alt></p><p>WebRTC 提供一些主要的 API 供应用层使用，这些 API 在<a href="https://w3c.github.io/webrtc-pc/" target="_blank" rel="noopener">规范</a>中有详细定义:</p><ul><li>getUserMedia：获取音频和视频流（MediaStream）</li><li>RTCPeerConnection：点对点通信，WebRTC 使用 RTCPeerConnection 在浏览器间传递数据流，经过几次迭代，RTCPeerConnection 被 Chrome 和 Opera 实现为 webkitRTCPeerConnection，被 FireFox 实现为 mozRTCPeerConnection</li><li>RTCDataChannel：数据通信</li></ul><p>建立一个简单的 WebRTC 应用只需要做以下这几件事：</p><ul><li>获取音频、视频流或其它数据</li><li>获取诸如 IP 地址和端口之类的网络信息，并与其他 WebRTC 客户端交换信息建立联系，甚至有些需要通过 NATs 和防火墙才能连接上</li><li>通过信令通信来反馈错误、启动或关闭会话</li><li>交换有关媒体和客户端功能的信息，例如分辨率和编解码器</li><li>音频、视频或数据流通信</li></ul></li></ul><p> 关于 WebRTC 底层技术可以自行谷歌，一些介绍文章：</p><ul><li><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/webrtc/basics/</a></li><li><p><a href="https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/</a></p><h2 id="为什么能火起来"><a href="#为什么能火起来" class="headerlink" title="为什么能火起来"></a>为什么能火起来</h2></li></ul><p><img src="https://assets.wuxinhua.com/blog/assets/clubhouse/weekly-downloads-clubhouse.png" alt></p><p>CH 这类语音社交产品及背后的技术并不是什么新鲜事物，音频聊天室早在 2011 年就出现了，类似的产品有 YY语音、递爪、荔枝等 APP，但都没有像 CH 这样火起来，并且值得注意的是声网这家公司的创始人Tony Zhao 赵斌原来是 YY 的 CTO，YY 在语言聊天这个领域已经发展很多年了。可以看下 CH 几个关键时间节点：</p><ul><li>2020 年4月公司在硅谷成立，上线 APP 后的5月份拿到了谷歌著名风投 A16Z 的 1200万 美元融资，估值1亿美元，当时还只有 1500 个用户</li><li>洛杉矶时间 1 月 31 日(北京时间 2 月 1 日)，马斯克发 Twitter 表示自己当晚将会在 CH 上进行在线分享，Twitter 上大批网友为了上CH 和马斯克“开房”同聊开始求邀请</li><li>2020 年底迅速在大陆、台湾、日本等地蹿红，并获得新的一轮投资和估值</li></ul><p>CH 的创始人和最初种子用户均来源于硅谷，一开始主要在硅谷 VC 和科技圈传播，随着马斯克的站台导致邀请码一票难求，并且迅速火到国内、日本等地，通过使用和研究分析，我认为 CH 能火起来主要得益于以下几个因素：邀请制、抓住人性的弱点、疫情、产品层的一些创新。</p><h3 id="邀请制"><a href="#邀请制" class="headerlink" title="邀请制"></a>邀请制</h3><p> 由于只有 iOS 平台且用户邀请制，一方面 Twitter 及微博、朋友圈上各种“求邀请码” 对产品的传播起到推动作用，另一方面通过邀请制提高了种子用户门槛，也导致更多的人想加入这个 “圈子”，Clubhouse 的两位创始人 Paul Davison 和 Rohan Seth 曾供职于谷歌等大公司，拥有丰厚的人脉资源，带来的种子用户本身就自带超强吸引力，可以说用户质量从前期抓起，入住一大批硅谷精英，科技圈 KOL、留学生、VC/金融行业高层次的用户、各界精英人群，邀请码的稀缺性为能够进入到圈子里的人创造了“优越感”，某种意义上来说你能用而别人不能用，这成了部分用户朋友圈炫耀的资本，但仅此而已，可参考早期的 Gmail、知乎。</p><h3 id="人性的弱点"><a href="#人性的弱点" class="headerlink" title="人性的弱点"></a>人性的弱点</h3><p> 抓住了人性的弱点，分别是 FOMO（Fear of missing out）和偷窥欲、贪婪，FOMO 也称社群恐慌症，具体表现为因为害怕错失某样东西而陷入持续性的焦虑中，在早期我也会有这种感觉，由于上班、时差等问题，为错过了科技圈、程序员届某某大佬的经验分享感到可惜；另外人人都有好奇心，偷窥欲源自于人类天生的好奇心，CH 就有点像你进入一个酒吧，你可以和熟人朋友一边畅饮一边聊天，你也可以去陌生人的桌子凑热闹，听听他们在聊什么，当这个酒吧突然来了一个或几个明星，甚至你能跟他们聊上几句，你会感觉今晚赚到了。<br> 由于不是从正道渠道获取的知识、我知道但别人不知道也从心理上获得一定程度上的满足，当然这些可能实质上给我的认知、生活工作带来的影响比较有限。免费从来都是最贵的，这也是为什么这款软件让很多人上瘾的原因，在 Netflix 的纪录片《The Social Dilemma》中也描述了这一个现象，科技巨头公司除了要用户数据外，还想方设法让你上瘾，在这个纪录片中，制作方访问了多位曾经就职于科技巨头如 Facebook、Google、Twitter 及 Pinterest 工作的创始人、领导和工程師，讲述社交平台为社会带来的危机，形容這些平台犹如「毒品」；他們提及年轻人对社交网络成瘾，使用者在社交平台的一举一动犹如被监视，这些企业有三个共同目标：1. Engagement（你流连在平台上的时间）2. Growth（带动更多朋友入坑）3. Revenue（如何通过用户数、DAU 吸引更多广告主）。</p><h3 id="从疫情中获益"><a href="#从疫情中获益" class="headerlink" title="从疫情中获益"></a>从疫情中获益</h3><p> 新冠病毒的大范围传播彻底改变了人们的生活工作方式，包括心理层面的影响（这点以后补充），由于疫情的爆发，很多公司已经推行 WFH 的工作方式，疫情也让我们从新思考疫情下的工作生活方式，为控制疫情的实施的社交隔离措施也在催生新的社交、协作应用，前段时间视频协作平台 Zoom 的爆火已经验证了这一点，日常生活未恢复正常之前，这种通过语音聊天结识新朋友的方式无疑还是比较安全的一种方式，在 CH 你可以跟来自世界各地的人交换观点、分享故事，结识到你感兴趣领域的朋友。</p><h2 id="个人使用体验"><a href="#个人使用体验" class="headerlink" title="个人使用体验"></a>个人使用体验</h2><ul><li>CH 产品功能设计确实很简洁；这一点跟早期抖音也很类似,没有太多额外的功能，而且基本都是围绕这个聊天核心功能来做的，这也提醒我在思考设计软件功能时应该尽可能保持简洁，Keep it simple, Keep it stupid; 另一个有意思的地方是 CH 在很多地方使用了 emoji 表情，并且用户的 bio 中也大量使用 emoji，非常简介生动形象，emoji 是一个世界语音，我本身也是一个 emoji 爱好者，CH 算是目前我在使用过程看到最多 emoji 的一个应用。</li><li>语音交流的真实及亲切感；相比于其它社交 App，大多以图文为主要交流方式，顺便搭配其它复杂的功能，在 CH 里无法使用文字交流，只能使用语音这个方式；我在日常使用微信的过程很少使用语音这个功能，但家里的亲戚、长辈不管是单独聊天、还是群聊都是大规模发语音，我这里不是说发语音不好，毕竟存在即合理，发语音是自己方便，对方费劲，发文字反之；在互联网出现前，关于信息媒介我们经历了报纸、广播、电视的转变过程，到了互联网时代，自媒体和短视频都经历了快速发展，唯独音频类播客产品一直不温不火，当然近几年也开始快速发展；通过对比传播信息的三种媒介：图文、语音、视频，会发现语音作为最原始也是最直接的交流方式，成本比较低但效率非常高，并且在虚拟的互联网世界用声音进行社交能给人更真实的感觉，总体来说通过我的观察 CH 上的用户在表达观点的时候都显得比较有包容、有礼貌，当然这个跟目前用户受教育程度、素质文化水平较高有一定关系，另一方面人们在用语音交流时更容易保持克制，像微博信息流底下水军刷屏留言、谩骂的现状不太可能发生。</li><li>我感兴趣的、有意思的 room 数量在下降；通过这些天的体验，总体来说目前推荐的一些 room 确实是我感兴趣的，相比于通过用户浏览习惯养成的推荐算法。 CH 基于兴趣 + 熟人这样的一条线路，也就是说你想要找到更多你感兴趣的 room，你需要去 follow 更多你感兴趣的人或club，但在 2 月 8 日大陆被墙后，包括春节过后大家都开始上班， 可以很明显得感受到 CH 在同事、朋友圈的传播热度在逐渐下降，包括好友上线频率、有意思的房间数量等都有减少的趋势。</li><li>Leave quietly 这个按钮真的很棒，我离开房间招呼都可以不用打；另外发现一个小细节: 在房间里即使你把音量降到最低，仍然能听到声音。</li></ul><h2 id="送两邀请码"><a href="#送两邀请码" class="headerlink" title="送两邀请码"></a>送两邀请码</h2><p>如果你看到这里并且也想体验一下这款“开房”聊天软件，我还有两个邀请名额可以赠送，可直接通过我的邮箱联系索要，在发邮件前请确保你是 iOS 用户并且有收到验证码的非大陆区手机号码，也欢迎 fo 我（Clubhouse ID：wuxinhua）一起交流学习。赠送邀请名额长期有效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Clubhouse (后面简称 CH) 无疑是过去一个月互联网圈最热门的在线语音聊天软件，年前硅谷“带货大王” Elon Musk 的一场线上语音&lt;a href=&quot;https://www.joinclubhouse.com/event/PQ488GWn&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="Clubhouse体验" scheme="https://wuxinhua.com/tags/Clubhouse%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>知识的碎片（2020）</title>
    <link href="https://wuxinhua.com/2020/12/31/The-Daily-Notes-Of-2020/"/>
    <id>https://wuxinhua.com/2020/12/31/The-Daily-Notes-Of-2020/</id>
    <published>2020-12-31T12:14:18.000Z</published>
    <updated>2021-03-09T11:02:04.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-fragment-of-knowledge"><a href="#The-fragment-of-knowledge" class="headerlink" title="# The fragment of knowledge"></a># The fragment of knowledge</h2><blockquote><p>记录日常的问题、新知识、想法 💡，欢迎 comment、补充，奇怪的知识增加了 ¯\_(ツ)_/</p><p>THINK BEFORE YOU WRITE! 不定期更新 ~</p><p>Ps: 今年的读书笔记📒要鸽了，这是我 2020 日常记录的一些知识碎片笔记，字节跳动提倡 “context” 文化，注重信息的输入和流动，鼓励分享、交流，我也参与了比较多公司内部分享活动，收获不少，因为有些属于对内的资料、链接，这里一并剔除了 ~</p></blockquote><h1 id="5-月"><a href="#5-月" class="headerlink" title="# 5 月"></a># 5 月</h1><ul><li><p>05-30</p><ul><li>最近通勤路上迷上了听 🎧* <em>Podcast</em> <em>(播客)</em>，*APP 用的是 iOS 自带 “播客”，最近也在用<a href="https://www.xiaoyuzhoufm.com/" target="_blank" rel="noopener">小宇宙</a>，几个不错的节目：</li><li><a href="https://teahour.fm/" target="_blank" rel="noopener">Teahour</a> 聚焦于程序、创业以及一切 Geek 话题的中文播客</li><li><a href="https://talk.swift.gg/" target="_blank" rel="noopener">ggtalk</a> 程序员的闲聊节目</li><li><a href="https://www.etw.fm/" target="_blank" rel="noopener">声东击西</a> 一群驻美记者主持的播客，徐涛的声音很好听</li><li><a href="https://sv101.fireside.fm/hosts/jane" target="_blank" rel="noopener">硅谷 101</a> 《财经》杂志驻美记者，专注于美国科技公司的深度报道</li><li><a href="https://anyway.fm/" target="_blank" rel="noopener">anyway.fm</a> Anyway.FM 是一档设计杂谈播客节目</li><li><a href="https://storyfm.cn/" target="_blank" rel="noopener">故事 fm</a> 用你的声音，讲述你的故事, 每周一、三、五</li></ul></li><li><p>05-31</p><ul><li><a href="https://sspai.com/post/60523" target="_blank" rel="noopener">macOS 的几个小技巧，比较实用的几个：</a></li><li>command + ` 切换不同窗口</li><li>shift + command + . 切换显示 . 开头的文件</li><li>command + shift + R 打开 AirDrop</li><li>空格键预览所有的 txt pdf jpg png gif psd ai sketch rmvb mkv mov 文件</li></ul></li></ul><h1 id="6-月"><a href="#6-月" class="headerlink" title="# 6 月"></a># 6 月</h1><ul><li>06-01<ul><li><a href="https://www.reddit.com/comments/1853ap" target="_blank" rel="noopener">SpaceX 及“龙”飞船用的啥技术栈</a></li></ul></li></ul><blockquote><p>总结一下：操作系统用的 Linux，火箭和飞船的飞行软件主要编程语言是 C++，前端 Javascript/Knockout/Handlebars/LESS 等</p><p>作为 Elon Musk 的粉丝，很久之前收集了关于他的一些有意思的事情：</p><p>1.Elon Musk 本身就是一个很奇怪的名字，Elon 在希伯来语是橡树的意思(但他不是犹太人)，来自于他的祖父 John Elon Haldman，而她的母亲的名字叫 Maye Musk。</p><p>2.伊隆很小的时候，他的父母曾以为他是个聋子，因为他太专注于一些事情而没有注意到父母正在跟他讲话。</p><p>3.他对太空极其着迷，12 岁的时候，完成了一个软件“Blaster”(太空小游戏)，并且卖了 500 美元。</p><p>4.1995 他考入了斯坦福大学学习物理，但只读了两天就辍学了；而在 Tesla，伊隆象征性地领 1 美元的年薪，这两点跟乔布斯也是极其得相似。</p><p>5.伊隆对人工智能非常担忧，引用他的说法“就像是在召唤恶魔”，但他却成立 OpenAI 和 Neuralink 人工智能和脑机接口公司。</p><p>6.他非常喜欢一部叫《October Shy》的电影，中文名叫《火箭男孩》,在《钢铁侠 2》中他有出境，还在《生活大爆炸》第九季中客串和 Howard 厨房洗盘子互动。</p><p>7.SpaceX 的火箭取名“Falcon(猎鹰)”,一级引擎叫“Merlin(梅林或灰背隼)”，而 Falcon 和 Merlin 均取自于电影《星球大战》。</p><p>8.而“龙飞船”的名字来源于美国民谣组合在 20 世纪 60 年代发行并广为流传的一首歌《Puff.the Magic Dragon》（魔法龙帕夫）。</p><p>9.其实他还有一点点低俗趣味，接任 PayPal 首席执行官之后，想立即将公司的名字由 PayPal 重新改为<a href="http://x.com/" target="_blank" rel="noopener">X.com</a>,遭到公司大多数的人反对，因为这个名字听起来就像个色情网站，下面这件事同样。</p><p>10.特斯拉的 CUV 新车取名 Model Y,之前的 SUV 叫 Model X，轿车 Model S,而 Model 3 原本是想命名为 Model E,但是由于版权问题没有通过（组合起来就是 SEXY）;而之所以取名 Model, 是致敬福特公司第一款汽车 Model T 的问世。</p><p>11.伊隆还有一个管道公司叫 Boring company，通过在大城市之间挖隧道来解决交通拥堵问题，而这个公司当时是当一个玩笑成立的。(Boring 还有挖掘的意思)。</p><p>12.伊隆的第一任妻子作家 Justine Musk,她其实喜欢老男人(准确地来说应该是成熟男人)，她喜欢“骑着摩托车停在女生宿舍楼下，穿着深棕色夹克，站在昏暗的路灯下喊我名字的罗密欧”那样的男人。</p><p>13.你能在《盗梦空间》的二层梦里找到 Elon 的第二任妻子 Talulah Riley, 而在 HBO 美剧《西部世界》第一季的第二集中，她扮演了一个 sexbot(性爱机器人)。</p><p>14.Justine 在收到这本书的时候，估计也想不到伊隆的新女朋友在电影《傲慢与偏见》中饰演了一个配角。</p><p>15.他很喜欢金黄色头发的女人。</p></blockquote><ul><li><p>06-02</p><ul><li><p>Promise.all 和 Promise.allSettled 的区别 <a href="https://blog.jonlu.ca/posts/promises" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>总结一下就是 Promise.allSettled 总是返回 resolve 的结果，无需再用 try catch 捕获错误</p></blockquote></li></ul></li><li><p>2020 年 Node.js 11 岁了，而 JavaScript 来到了它的 25 岁生日 🎉</p><p>  <img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-02.png" alt></p></li><li><p>06-03</p><ul><li><a href="https://www.youtube.com/watch?v=ouIK1S0KdJE&amp;feature=emb_title" target="_blank" rel="noopener">关于 HTTP/2 - Ilya Grigorik</a></li></ul></li><li><p>06-04</p><ul><li><p>面向 Google 编程，Google 搜索的几个小技巧，方便你快速地搜到正确的结果</p><ul><li>site: 指定网站结果内容 <a href="https://www.google.com/search?sxsrf=ALeKk03rBzBYaq_tBdGrcGaMEPDRe0mXDQ:1591318083400&amp;ei=Q5bZXtj7F9u_9QOo_JagDg&amp;q=site:stackoverflow.com+javascript+undefined&amp;oq=site:stackoverflow.com+javascript+undefined&amp;gs_lcp=CgZwc3ktYWIQA1CsLliBTmC9Z2gBcAB4AIABlAGIAZIKkgEDMi45mAEAoAEBqgEHZ3dzLXdpeg&amp;sclient=psy-ab&amp;ved=0ahUKEwiYqdfouenpAhXbX30KHSi-BeQQ4dUDCAw&amp;uact=5" target="_blank" rel="noopener">site:stackoverflow.com javascript undefined</a></li><li>filetype: 结果类型 <a href="https://www.google.com/search?sxsrf=ALeKk01vqNo-5Is1RBJ03O6j1aOK0ugLEQ%3A1591318348553&amp;ei=TJfZXvGjIYX59QPr1rnIAg&amp;q=filetype%3A+bitcoin&amp;oq=filetype%3A+bitcoin&amp;gs_lcp=CgZwc3ktYWIQAzIECCMQJzIGCAAQCBAeMgYIABAIEB5QAFgAYIwyaABwAHgAgAFwiAFwkgEDMC4xmAEAqgEHZ3dzLXdpeg&amp;sclient=psy-ab&amp;ved=0ahUKEwjx-Y7nuunpAhWFfH0KHWtrDikQ4dUDCAw&amp;uact=5" target="_blank" rel="noopener">filetype: bitcoin</a></li><li>- ：移除一些特定结果，例如搜索 JavaScript 会有很多教程相关的结果，可以 <a href="https://www.google.com/search?sxsrf=ALeKk03lOzf1w_ugbuvTVcyeIgoLsgdygQ:1591318800182&amp;ei=EJnZXsPfCtGo9QObtK2QAQ&amp;q=JavaScript+-教程&amp;oq=JavaScript+-教程&amp;gs_lcp=CgZwc3ktYWIQAzoECCMQJzoECAAQQzoFCAAQywFQwyRYpCZg7ydoAHAAeACAAXWIAcMCkgEDMC4zmAEAoAEBoAECqgEHZ3dzLXdpeg&amp;sclient=psy-ab&amp;ved=0ahUKEwjDp7y-vOnpAhVRVH0KHRtaCxIQ4dUDCAw&amp;uact=5" target="_blank" rel="noopener">JavaScript -教程</a></li></ul></li><li><p>一本编辑相关的书<a href="https://book.douban.com/subject/1115748//" target="_blank" rel="noopener">《故事》- 罗伯特麦基</a></p></li></ul></li><li><p>06-06</p><ul><li><a href="https://www.youtube.com/watch?v=UqU19dR0bFE" target="_blank" rel="noopener">THE ART OF BALANCING STONES 我如何能把石头玩得这么 6 </a>这个博主很有意思，北欧版李子柒 ~</li></ul></li><li><p>06-07</p><ul><li><a href="https://tc39er.us/" target="_blank" rel="noopener">TC39 的 Podcast</a></li><li><a href="https://insights.stackoverflow.com/survey/2020" target="_blank" rel="noopener">Stackoverflow.com 2020 开发者问卷调查报告</a>( JS 仍然是最受欢迎的语言，开发者更喜欢的是 TypeScript)</li><li><a href="https://www.die.net/earth/" target="_blank" rel="noopener">World Sunlight Map 地球 🌍 日照地图</a></li><li><a href="https://github.com/electronicarts/CnC_Remastered_Collection" target="_blank" rel="noopener">《红色警戒》源代码开放，玩家可自主创建更广泛的 MOD</a> <a href="https://github.com/electronicarts/CnC_Remastered_Collection" target="_blank" rel="noopener">Github 源码</a></li></ul></li><li><p>06-08</p><ul><li>《Interpretable Machine Learning》@christophM 可解释的机器学习- <a href="https://github.com/MingchaoZhu/InterpretableMLBook" target="_blank" rel="noopener">中文版</a></li></ul></li><li><p>06-09</p><ul><li>这位开发者写了一系列的 <a href="https://draveness.me/whys-the-design/" target="_blank" rel="noopener">为什么这么设计文章</a></li><li><a href="https://www.jikelife.com/#download" target="_blank" rel="noopener">即刻终于回来了</a></li></ul></li><li><p>06-10</p><ul><li>解构赋值取别名</li></ul><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-10.png" alt></p></li><li><p>06-11</p><ul><li><a href="https://segmentfault.com/a/1190000022804749" target="_blank" rel="noopener">VS Code 调试 React</a></li></ul></li><li><p>06-12</p><ul><li><a href="https://twitter.com/IGN/status/1271412264311160835" target="_blank" rel="noopener">#PS5</a> 发布了 PS 和 Xbox 外观设计变化</li></ul><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-12.png" alt></p></li><li><p>06-13</p><ul><li><a href="https://www.androidpolice.com/2020/06/12/google-resumes-its-senseless-attack-on-the-url-bar-hides-full-addresses-on-chrome-canary/" target="_blank" rel="noopener">Chrome85 将隐藏地址栏的 URL</a></li></ul><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-13.png" alt></p><blockquote><p>Github 后续会考虑给 repo 默认分支 master 换个名字 🤔 master =&gt; main 字数直接少了两</p></blockquote></li><li><p>06-14</p><ul><li>JetBrains 的 <a href="https://www.jetbrains.com/zh-cn/lp/mono/" target="_blank" rel="noopener">mono 字体</a> 开源而且免费，真香</li></ul><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-14.png" alt></p></li><li><p>06-15</p><ul><li><p>Linux 可以使用 {} 一次创建多个文件，npm 命令同样适用<br><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-15.png" alt></p></li><li><p><a href="https://sspai.com/post/60979" target="_blank" rel="noopener">如何选个好椅子</a></p></li><li>Vue SSR 相关文章</li><li><a href="https://juejin.im/post/5d1fe6be51882579db031a6d" target="_blank" rel="noopener">从头开始，彻底理解服务端渲染原理(8 千字汇总长文)</a></li></ul></li><li><p>06-17</p><ul><li>投资其实是认知的变现</li></ul></li><li><p>06-19</p><ul><li><a href="https://github.blog/2020-06-18-introducing-github-super-linter-one-linter-to-rule-them-all/" target="_blank" rel="noopener">github-super-linter</a> github super linter</li><li><a href="https://gist.github.com/PurpleBooth/109311bb0361f32d87a2" target="_blank" rel="noopener">README 有意思的 Template 模板</a></li><li><a href="https://dev.to/marcradziwill/why-you-should-try-svelte-54k3" target="_blank" rel="noopener">为什么你应该试试 Svelte</a></li></ul></li><li><p>06-20</p><ul><li><a href="https://github.com/vuejs/vue-cli/issues/1034" target="_blank" rel="noopener">SSR 设置 NODE_ENV = server</a></li></ul></li><li><p>06-22</p><ul><li><a href="https://zhuanlan.zhihu.com/p/149351900" target="_blank" rel="noopener">snowpack 原理</a></li><li><a href="https://www.cnbeta.com/articles/tech/994279.htm" target="_blank" rel="noopener">WWDC20</a></li></ul></li><li><p>06-23</p><ul><li><a href="https://segmentfault.com/q/1010000011752614" target="_blank" rel="noopener">关于图片防盗链</a></li></ul></li><li><p>06-24</p><ul><li><p>css 使用 [] 匹配属性值</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/06-24.png" alt></p></li></ul></li><li><p>06-25</p><ul><li><a href="https://chrome.google.com/webstore/detail/death-clock/nddjbfjdamhcmdcghehomomgppbigjam?hl=en" target="_blank" rel="noopener">Death-clock 死亡倒计时扩展</a></li></ul></li><li><p>06-26</p><ul><li><a href="https://www.zhihu.com/question/23240324/answer/302040490" target="_blank" rel="noopener">如何清理 Macbook 磁盘占用的“其它” 项</a></li></ul></li><li><p>06-27</p><ul><li><a href="https://developer.apple.com/services-account/download?path=/WWDC_2020/macOS_10.16_Developer_Beta_Access_Utility/macOSDeveloperBetaAccessUtility.dmg" target="_blank" rel="noopener">体验一下 Big Sur，profile 安装文件</a></li></ul></li><li><p>06-28</p><ul><li><a href="https://blog.angular.io/version-10-of-angular-now-available-78960babd41?gi=ee245c95442f" target="_blank" rel="noopener">Angular 10 Release</a></li><li><a href="https://github.com/kachkaev/njt" target="_blank" rel="noopener">njt</a> 一個快速跳轉到 package npm 頁面的工具，类似 npm home package</li></ul></li><li><p>06-29</p><ul><li>git diff – ‘:!*package-lock.json’ git diff 命令排除某些文件</li></ul></li><li><p>06-30</p><ul><li><a href="https://sspai.com/post/61183" target="_blank" rel="noopener">2020 苹果年度设计大奖 APP</a></li><li>npm 的几个常用命令<ul><li>npm outdated 检测列出已过时的依赖</li><li>npm list 列出当前安装的依赖</li><li>npm home \<package> 跳转依赖 github 主页</package></li></ul></li></ul></li></ul><h1 id="7-月"><a href="#7-月" class="headerlink" title="# 7 月"></a># 7 月</h1><ul><li><p>07-01</p><ul><li><a href="https://uidesigndaily.com/" target="_blank" rel="noopener">https://uidesigndaily.com/</a> 开源的 UI 设计网站</li><li><p><a href="https://www.npmjs.com/package/ntl" target="_blank" rel="noopener">ntl</a> 省时小工具，列出当前 Package.json 中的 script 命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g ntl</span><br></pre></td></tr></table></figure><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-01.png" alt></p></li></ul></li><li><p>07-02</p><ul><li><a href="https://dev.to/richharris/in-defense-of-the-modern-web-2nia" target="_blank" rel="noopener">https://dev.to/richharris/in-defense-of-the-modern-web-2nia</a></li></ul></li><li><p>07-04</p><ul><li><p>+ 运算符的一些特殊用法，+ 可以取代 JavaScript Number() 的一些用法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">+<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span> <span class="comment">// 1593917791284</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>07-07</p><ul><li><a href="https://carlhendy.com/history-of-search-engines/" target="_blank" rel="noopener">搜索引擎的历史</a></li></ul></li><li><p>07-08</p><ul><li><a href="https://github.com/dt-fe/weekly/blob/v2/157.%20%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%20Object%20%E5%AF%B9%E8%B1%A1%E3%80%8B.md" target="_blank" rel="noopener">精读《如何比较 Object 对象》</a></li></ul></li><li><p>07-09</p><ul><li><a href="https://nuxtjs.org/blog/improve-your-developer-experience-with-nuxt-components" target="_blank" rel="noopener">Improve Your Developer Experience With Nuxt Components</a></li></ul></li><li><p>07-10</p><ul><li><a href="https://hugogiraudel.com/2020/05/18/using-calc-to-figure-out-optimal-line-height/" target="_blank" rel="noopener">使用 calc 计算 line-height</a></li></ul></li><li><p>07-11</p><ul><li><a href="https://siipo.la/blog/is-webp-really-better-than-jpeg" target="_blank" rel="noopener">webp 是否真的比 jpeg 要好</a></li></ul></li><li><p>07-12</p><ul><li><p><a href="https://romefrontend.dev/" target="_blank" rel="noopener">rome</a></p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-12.png" alt></p></li><li><p><a href="https://mp.weixin.qq.com/s/wBHZ3aE8ELLY7QZCr_AhHA" target="_blank" rel="noopener">年轻人在股市放肆的样子，像极了当年被套的老股民</a></p></li></ul></li><li><p>07-13</p><ul><li><a href="https://www.shuzhiduo.com/A/n2d9GOP0JD/" target="_blank" rel="noopener">nginx 日志统计的几个命令</a></li></ul></li><li><p>07-14</p><ul><li><a href="https://node.dev/" target="_blank" rel="noopener">Node.dev</a></li></ul></li><li><p>07-15</p><ul><li><a href="https://dev.to/natterstefan/how-to-add-a-readme-to-your-github-profile-2bo9" target="_blank" rel="noopener">README Github profile</a></li></ul></li><li><p>07-16</p><ul><li><a href="https://codegolf.stackexchange.com/questions/2682/tips-for-golfing-in-javascript" target="_blank" rel="noopener">JS 小技巧</a></li><li><p><a href="https://mp.weixin.qq.com/s/z1ZVYXjNGutoovth5-lL-Q" target="_blank" rel="noopener">iPadOS 鼠标的设计哲学</a></p><blockquote><p>苹果不是什么魔法师，只是在设计时认真的去为用户做考量。愿意在这些别人不在意的细节上投资，一点点积累之后，就有了自己独特的用户体验。用户虽然对每年的创新所带来的小毛病憋着一肚子气，但心底里还是希望有人能付出努力，把这些别人不在意的细节一点点做好，于是尽量宽容，大概就是这种默契吧。</p></blockquote></li><li><p><a href="https://www.linkedin.com/pulse/figmas-story-part-1-my-thiel-fellowship-application-2011-dylan-field/?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=rss" target="_blank" rel="noopener">Figma’的故事 Part - 1</a></p></li></ul></li><li><p>07-17</p><ul><li><p>北向资金</p><blockquote><p>北向资金就是指从香港股市流入大陆股市的资金，也就是所谓的外资，相反南下资金是指内地流入香港股市的资金，也就是所谓的内资。</p><p>“北”指的是沪深两证券交易所，南指的是香港证券交易所，因为 A 股市场有管制，不允许外资直接参与，在 14 年和 16 年分别开通了沪港通和深港通，实现 A 股和港股的资金互流，因为内地在香港的北面，所以形成了北向资金的说法，北向资金也有“聪明的资金”之称，买入和卖出有一定参考价值</p></blockquote></li><li><p>带有歧视性软件术语名单</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-17.png" alt></p></li><li><p>macOS 系统里使用 Ctrl + Command + Space 可以在编辑的位置直接调起 emoji 选项板 👏</p></li></ul></li><li><p>07-18</p><ul><li><p>即刻真的是个神奇的 APP，奇怪的知识又增加了</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-18.png" alt></p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-18-1.png" alt></p></li></ul></li><li><p>07-19</p><ul><li><a href="https://book.douban.com/subject/34997975/" target="_blank" rel="noopener">《文明、现代化、价值投资与中国》- 李录</a></li></ul></li><li><p>07-20</p><ul><li><p><a href="https://mp.weixin.qq.com/s/61dD_RyExzs6EGvQIN_z2Q" target="_blank" rel="noopener">GitHub Archive Program 计划，你的开源代码将入驻北极圈，至少保存 1000 年</a> 个人主页还送了个徽章：</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-20.png" alt></p></li></ul></li><li><p>07-21</p><ul><li><a href="https://school.geekwall.in/p/mYqy1FSw/anonymous-web-scraping-with-node-js-tor-puppeteer-and-cheerio" target="_blank" rel="noopener">使用 tor 进行 Anonymous 爬虫爬取</a></li></ul></li><li><p>07-23</p><blockquote><p>“图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能”</p></blockquote></li><li><p>07-24</p><ul><li><a href="https://github.com/developit/redaxios" target="_blank" rel="noopener">800 bytes redaxios</a></li></ul></li><li><p>07-25</p><ul><li><p>这个工具可以帮你 <a href="https://3d-book-css.netlify.app/" target="_blank" rel="noopener">制作一个 3D 书籍封面</a></p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-25.png" alt></p></li></ul></li><li><p>07-27</p><ul><li><p>关于 <a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">Elasticsearch</a> 的故事</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/07-27.png" alt></p></li></ul></li><li><p>07-28</p><ul><li><a href="https://github.blog/2020-07-28-announcing-the-github-public-roadmap/" target="_blank" rel="noopener">github-public-roadmap</a></li><li><a href="https://dotheopposite.substack.com/" target="_blank" rel="noopener">dotheopposite</a></li></ul></li><li><p>07-31</p><ul><li><p><a href="https://mp.weixin.qq.com/s/Nk5-tx6VWt591AfuoP-Ncg" target="_blank" rel="noopener">Notion 的支撑者</a></p><p><img src="https://assets.wuxinhua.com/blog/assets/notes-2020/640.webp" alt></p><blockquote><p>tools for thought； - Ivan Zhao/赵伊</p><p>我并没有创新什么，我只是在复刻历史</p><p>augment our collective intellect - Doug Engelbart</p><p>amplify imagination - Alan Kay</p><p>expand our thoughts far beyond text on paper - Ted Nelson</p></blockquote></li></ul></li></ul><h1 id="8-月"><a href="#8-月" class="headerlink" title="# 8 月"></a># 8 月</h1><ul><li><p>08-01</p><ul><li><a href="https://liqi.io/community/" target="_blank" rel="noopener">利器</a></li></ul><blockquote><p>来自不同的领域，不同类型的创造者的一些工具和灵感</p></blockquote></li><li><p>08-02</p><ul><li><a href="https://github.com/xufei/blog/issues/53" target="_blank" rel="noopener">对 aPaaS 的产品认知</a></li><li><a href="https://v8.dev/docs/respectful-code" target="_blank" rel="noopener">V8 团队的 Respectful code 替换方案</a></li></ul></li><li><p>08-03</p><ul><li><a href="https://docs.lightstep.com/otel/getting-started-node?utm_campaign=js&amp;utm_source=cooper&amp;utm_medium=Email" target="_blank" rel="noopener">OpenTelemetry</a></li><li><p><a href="https://github.blog/2020-07-27-highlights-from-git-2-28/" target="_blank" rel="noopener">git-2-28</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global init.defaultBranch main // 支持默认分支名自定义 master =&gt; main</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>08-07</p><ul><li><p><a href="https://hackernoon.com/ten-useful-git-log-tricks-7nt3yxy" target="_blank" rel="noopener">Git log 实用参数</a> 比较实用的几个:</p><blockquote><p>git log –oneline 一行展示提交日志<br>git log –author=”M1seRy” 显示某个用户的提交<br>git log –grep=”fix” 查找关键字对应的日志</p></blockquote></li><li><p><a href="https://github.com/luyuhuang/vscode-rss" target="_blank" rel="noopener">Vscode-rss</a></p><blockquote><p>在 vscode 摸鱼刷 rss 订阅</p></blockquote></li></ul></li><li><p>08-08</p><ul><li><a href="https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1" target="_blank" rel="noopener">CJS 和 ESM 的区别</a></li><li><a href="https://github.com/felixrieseberg/macintosh.js" target="_blank" rel="noopener">Mac OS 8：带你体验 20 多年前的 Mac 操作系统</a></li></ul></li><li><p>08-09</p><ul><li><a href="https://fruitionsite.com/" target="_blank" rel="noopener">Notion 搭建博客</a></li></ul></li><li><p>08-18</p><ul><li>MongoDB 已经不再开源 brew 已经无法直接安装 <a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/</a></li></ul></li><li><p>08-19</p><ul><li><a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">puppeteer-recorder</a></li></ul><blockquote><p>开启这个工具后，能记录你在浏览器的操作，并转换成 puppeteer 代码</p></blockquote><ul><li><a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation" target="_blank" rel="noopener">中国程序员容易发音错误的单词</a></li></ul></li><li><p>08-20</p><ul><li><a href="https://futu.im/article/2019-seo/" target="_blank" rel="noopener">富途 - 前端搜索引擎优化</a> 总结一下:</li></ul><ol><li>提供 keyword</li><li>图片 alt</li><li>使用 robots.txt</li><li>URL 使用 noffollow</li><li>提供 sitemap</li><li>Spa 提供服务端渲染</li><li>语义化标签</li></ol><ul><li>没有指标收益的事情是否值得去做？<blockquote><p>不是只有指标收益的事情才值得做，有些场景下收益完全用指标衡量相对教难，比如安全、用户隐私、品牌/口碑等，要依靠人的判断，指标最终还是手段/工具，不是目的。</p></blockquote></li></ul></li><li><p>08-23</p><ul><li><a href="https://mp.weixin.qq.com/s/0MOtQfZLLMkcfJW8bXx8Lw" target="_blank" rel="noopener">我是怎样通过个人项目成长为高级 JavaScript 开发者的</a></li><li><a href="https://mp.weixin.qq.com/s/BnugQ-xYl0QOoFjTO5lbUg" target="_blank" rel="noopener">怕你不行，又怕你太行：小扎收购 Instagram 后的矛盾反复</a></li><li><a href="http://www.woshipm.com/chuangye/658054.html" target="_blank" rel="noopener">PMF (product/market/fit)</a></li></ul></li><li><p>08-26</p><ul><li><a href="https://mp.weixin.qq.com/s/pCVN0WfzQGFY6cry0O8c5Q" target="_blank" rel="noopener">TC39 7 月会议提案进度</a></li><li>“4321” 理财法则<blockquote><p>即资产配置方面: 40% 投资、30% 生活开销、20% 储蓄备用、10% 保险</p></blockquote></li></ul></li><li><p>08-27</p><ul><li><a href="https://36kr.com/p/855793597062016" target="_blank" rel="noopener">最前线 | 字节跳动确认 TikTok CEO 凯文梅耶尔离职，知情人士称其与张一鸣产生分歧</a></li></ul><blockquote><p>中午收到邮件 “巴斯光年” Kevin Mayer 离职了</p></blockquote><ul><li><p>Ubisoft 出周边又翻车，但大家还是买账，论如何反向营销 <a href="https://assets.wuxinhua.com//blog/assets/notes-2020/08-27.png" target="_blank" rel="noopener">#育碧联名杯子# ​​​​</a></p><p><img src="https://assets.wuxinhua.com/blog/assets/notes-2020/08-27-1.png" alt></p></li></ul></li><li><p>08-28</p><ul><li><a href="https://www.yuque.com/barretlee/thinking/unouq3" target="_blank" rel="noopener">给自己找个导师 - Barret 李靖</a></li><li><a href="https://www.yuque.com/barretlee/searching" target="_blank" rel="noopener">发现美好的东西/ 收藏关注 关注者 还没有关注者</a></li><li><a href="https://www.bryanlee.net/blog/why-your-perfect-mentor-is-your-future-self-from-the-multiverse" target="_blank" rel="noopener">为什么你需要找个好 mentor</a></li></ul></li><li><p>一行 CSS 代码实现倒影</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.reflect</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-reflect</span>: below -<span class="number">10px</span> <span class="built_in">linear-gradient</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/08-28.png" alt></p></li><li><p>08-31</p><ul><li><a href="https://icons.getbootstrap.com/" target="_blank" rel="noopener">Bootstrap Icon 1100 个免费图标, SVG 格式</a></li><li><p><a href="https://book.douban.com/subject/1313875/" target="_blank" rel="noopener">《创新者的窘境》</a>里提到：</p><p>一个企业陷入困境主要有两个原因：</p><ul><li><p>外在的生存结构，即“价值网”</p></li><li><p>内在的思维模式，即“组织心智”</p></li></ul></li></ul></li></ul><h1 id="9-月"><a href="#9-月" class="headerlink" title="# 9 月"></a># 9 月</h1><ul><li><p>09-02</p><ul><li><p>英伟达发布 RTX 30 系列显卡</p><blockquote><p>英伟达中国官网公布了 RTX 3090/3080/3070 三款公版显卡的价格。RTX 3070 3899 元起，10 月开售，RTX 3080 5499 元起，9 月 17 日开售，RTX 3090 11999 元起，9 月 24 日起售</p></blockquote></li></ul></li><li><p>09-03</p><ul><li><a href="http://blog.haoji.me/vscode-plugin-hello-world.html" target="_blank" rel="noopener">vscode 插件开发攻略</a></li><li><a href="https://hbr.org/2018/10/the-art-of-the-elevator-pitch" target="_blank" rel="noopener">关于 elevator pitch</a></li><li><a href="https://www.iyiou.com/p/43969.html" target="_blank" rel="noopener">“Context，not Control” 又重新看了一下 CEO 的这个分享</a></li><li><a href="https://twitter.com/shelly9909/status/1301167047498280961" target="_blank" rel="noopener">一分钟体验人生</a></li></ul></li><li><p>09-06</p><ul><li><a href="https://dog.wtf/tech/hexo-dark-mode-note/" target="_blank" rel="noopener">Hexo 博客实现 dark mode</a></li></ul></li><li><p>09-07</p><ul><li><a href="https://m.okjike.com/originalPosts/5f4606ecb2d4e60018337ae4?s=ewoidSI6ICI1YWQ4Yzc1N2Q2NTE2NTAwMTcxMjgxZWQiCn0=" target="_blank" rel="noopener">iOS 有趣的技术小知识</a></li></ul></li><li><p>09-08</p><ul><li><p><a href="https://mp.weixin.qq.com/s/Mes1RqIOdp48CMw4pXTwXw" target="_blank" rel="noopener">外卖骑手，困在系统里</a></p><blockquote><p>表面看是系统、算法的问题，其实还是人的问题</p></blockquote></li><li><p><a href="https://www.zhihu.com/question/420025438/answer/1460788352" target="_blank" rel="noopener">《外卖骑手，困在系统里》一文反映出了外卖行业的什么现象与问题？外卖效率与外卖员人性化待遇应如何平衡？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/vVX__t_LLUQ8Zp2kPOXKpg" target="_blank" rel="noopener">新的跨域策略：COOP、COEP</a></p></li></ul></li><li><p>09-10</p><ul><li>30 种语言的 Hello World</li></ul><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/09-10.png" alt></p></li><li><p>09-13</p><ul><li><p><a href="https://www.youtube.com/watch?v=fwSgoUOxeLQ" target="_blank" rel="noopener">【一席】李治中：癌症的真相</a></p><blockquote><p>关于癌症：1. 预防 &gt; 筛选 &gt; 治疗 2. 30 - 50 是高发期</p></blockquote></li></ul></li><li><p>09-14</p><ul><li>NET::ERR_CERT_AUTHORITY_INVALID 报错</li></ul><blockquote><p>这个报错有可能是协议过期 、协议是自签名、签发机构不是合法导致的</p></blockquote><ul><li><p><a href="https://www.infoq.cn/article/MwqrL2yeD6arBgLrMb3F" target="_blank" rel="noopener">软件工程师除了写代码，还能做什么工作？</a></p></li><li><p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。</p></li></ul></li><li><p>09-15</p><ul><li><a href="https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html" target="_blank" rel="noopener">成为一名高级软件工程师所学到的东西</a></li><li><p>error: cannot lock ref ‘refs/remotes/origin/‘: ‘refs/remotes/origin’ exists</p><blockquote><p>git remote prune origin</p></blockquote></li><li><p><a href="https://mp.weixin.qq.com/s/UUcqZCZjfHMa7fsruCjq_w" target="_blank" rel="noopener">“个人主页”设计相关思考</a></p></li><li><p><a href="https://segmentfault.com/a/1190000024458956" target="_blank" rel="noopener">TS 学习指南</a></p></li><li><p><a href="https://sspai.com/post/62603" target="_blank" rel="noopener">无限桌面 | 用 21 天打造出属于自己的理想桌面</a></p></li></ul></li><li><p>09-16</p><ul><li>Moment.js <a href="https://momentjs.com/docs/#/-project-status/" target="_blank" rel="noopener">宣布停止开发了，进入维护状态</a>，并建议新项目使用其他时间库。</li></ul></li><li><p>09-17</p><ul><li><a href="https://recordit.co/" target="_blank" rel="noopener">GIF 录屏软件</a></li></ul></li><li><p>09-18</p><ul><li><a href="https://github.blog/2020-09-17-github-cli-1-0-is-now-available/" target="_blank" rel="noopener">github-cli 1.0</a></li><li><a href="https://github.com/vue3/vue3-News" target="_blank" rel="noopener">vue3 终于发布了正式版 One Piece</a></li></ul></li><li><p>09-20</p><ul><li><a href="https://t.co/zhkNAKQfqE?amp=1" target="_blank" rel="noopener">收录的一些 iOS 14 widget</a></li></ul></li><li><p>09-23</p><ul><li><a href="https://ant.design/docs/react/replace-moment-cn" target="_blank" rel="noopener">antd 团队给出的 moment.js 替代方案</a></li></ul><blockquote><p>建议使用自定义日期库（day.js、date-fns）替换 Moment 以优化打包大小</p></blockquote></li><li><p>09-25</p><ul><li><a href="https://www.zhihu.com/question/422696068" target="_blank" rel="noopener">关于蚂蚁金服的 5 只战略配售基金</a></li></ul></li><li><p>09-27</p><ul><li><a href="https://mp.weixin.qq.com/s/BeVHkj4rBRvFrtrseFDCvw" target="_blank" rel="noopener">Snowflake 创纪录的 SaaS IPO，你不能错过的万字深度解析</a></li></ul></li><li><p>09-28</p><ul><li><a href="https://juejin.im/post/6876977166051966984" target="_blank" rel="noopener">作为前端，我对业务的一点理解</a>(写得不错，先 M 再看)</li></ul></li></ul><h1 id="10-月"><a href="#10-月" class="headerlink" title="#10 月"></a>#10 月</h1><ul><li><p>10-09</p><ul><li><a href="https://mp.weixin.qq.com/s/pPMdQzq8JvSIaGQ8pzLeGw" target="_blank" rel="noopener">「译」更快的 async 函数和 promises</a></li><li><a href="http://pc.txappnet.com/" target="_blank" rel="noopener">Tuber 浏览器</a> 政府带你翻墙</li></ul></li><li><p>10-13</p><ul><li>人人都要了解的理财知识：基金投资</li><li>大牛市搞钱指北之基金投资攻略：从入门到放弃（月亏百万不是梦）</li><li><a href="https://xueqiu.com/9371934674/160939709" target="_blank" rel="noopener">人人都应该了解的理财知识——基金篇（上）</a></li><li><p><a href="https://xueqiu.com/9371934674/160939748" target="_blank" rel="noopener">人人都应该了解的理财知识——基金篇（下）</a></p><blockquote><p>12-14%年化收益可以跑赢央行印钱速度(通胀)</p><p>有效市场假说(市场不总是有效，也不存在完全有效市场)</p><p>打工的本质：加强自身能力，早日摆脱“时间换薪酬”的模式</p><p>你挣到的每一笔超额收益都源于你对知识的学习</p><p>资产配置多元化是投资的唯一免费午餐</p><p>挑选基金简单的方法：公司规模 &amp; 基金经理 &amp; 长期收益</p></blockquote></li><li><p>这个理财主题的分享干货还是比较多，大家感兴趣也可以上雪球、公众号关注他，ps: 基金有风险，投资需谨慎</p></li></ul></li><li><p>10-14</p><ul><li><a href="https://blog.uptrends.com/web-performance/the-psychology-of-web-performance/" target="_blank" rel="noopener">性能优化心理学</a></li></ul><blockquote><p>性能优化有个 20% 定律，即优化幅度达到 20% 提升时，用户就能够确实感受到页面速度变快了</p></blockquote></li><li><p>10-16</p><ul><li>Google 开发的开源工具图片在线压缩实时预览 <a href="https://squoosh.app/" target="_blank" rel="noopener">https://squoosh.app/</a></li></ul></li><li><p>10-17</p><ul><li><a href="https://zhuanlan.zhihu.com/p/30169829" target="_blank" rel="noopener">深度剖析 Css Baseline</a></li><li><a href="https://mp.weixin.qq.com/s/AjE7uP7ApVPyL_HdQDkk5g" target="_blank" rel="noopener">AIOps 在美团的探索与实践——故障发现篇</a></li></ul></li><li><p>10-19</p><ul><li><a href="https://item.jd.com/1683181.html" target="_blank" rel="noopener">安耳悠耳塞</a></li><li><a href="https://book.douban.com/subject/2972992/" target="_blank" rel="noopener">《时间足够你爱》</a> <a href="https://book.douban.com/author/659025/" target="_blank" rel="noopener">[美] 罗伯特·海因莱因</a></li><li><a href="https://mp.weixin.qq.com/s/b_yzbLeQh57oYjqlIgPiYQ" target="_blank" rel="noopener">硬核！15 张图解 Redis 为什么这么快</a></li><li><a href="https://news.futunn.com/stock/13588112?src=3" target="_blank" rel="noopener">ASML 光刻巨头，世界上最先进的 EUV 光刻机，为什么只有荷兰阿斯麦公司做出来了？</a></li></ul><blockquote><p>摩尔定律的产业规范：集成电路上可容纳的元器件的数量每隔 18 至 24 个月就会增加一倍（相应的芯片制程也会不断缩小）。而每一次制程前进，也会带来一次芯片性能性能的飞跃。</p></blockquote><ul><li><a href="https://www.youtube.com/watch?v=q7T7HnsuZsQ" target="_blank" rel="noopener">David Sandberg 《lights out》</a></li></ul></li><li><p>10-20</p><ul><li><a href="https://mp.weixin.qq.com/s/JLorlCMdqQ8gbOZTO17tYA" target="_blank" rel="noopener">一文看懂 HTTP3</a></li><li><p><a href="https://mp.weixin.qq.com/s/5W7EQoiT9f8MlGUjJTn4_w" target="_blank" rel="noopener">什么是真正的程序员</a></p></li><li><p>机器学习三把斧: 模型 + 策略 + 算法</p><blockquote><p><a href="https://space.bilibili.com/88461692/channel/detail?cid=26587" target="_blank" rel="noopener">B 站学习视频：深度学习 Deep Learning</a></p></blockquote></li></ul></li><li><p>10-21</p><ul><li><a href="https://www.bilibili.com/video/BV1Yz4y1C7ut" target="_blank" rel="noopener">Smartisan OS 7.0 感知光影</a></li></ul></li><li><p>10-22</p><ul><li><a href="https://www.zhihu.com/question/422696068" target="_blank" rel="noopener">关于蚂蚁金服战略配售的 5 只基金</a></li><li><p><a href="https://www.bilibili.com/video/av11019747/" target="_blank" rel="noopener">Netflix 《设计的艺术 纪录片》</a></p><blockquote><p>只看了第一集，插画设计师克里斯托夫·尼曼的疯狂创意图集，将简单的生活日常用冲破脑际的创意和灵感碰撞在一起，确实拍的很赞</p></blockquote></li><li><p>“社会性死亡” ：在除去亲密关系的人类面前，做出了无比尴尬丢脸的行为，只想入土为安，这便是社会性死亡</p><blockquote><p>只要你不尴尬，尴尬的就是别人</p></blockquote></li></ul></li><li><p>10-24</p><ul><li><a href="https://mp.weixin.qq.com/s/yik2tZOKxRGkSANIwqH8uA" target="_blank" rel="noopener">关于程序员的 65 张肖像</a></li><li><p><a href="https://www.zhihu.com/question/427013531/answer/1539808415" target="_blank" rel="noopener">2020 - 1024 = 996 ？黑人问号脸</a></p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/10-24.png" alt></p></li></ul></li><li><p>10-27</p><ul><li><a href="https://www.jianshu.com/p/7008d2a1e320" target="_blank" rel="noopener">Kafka 原理总结</a></li><li><a href="https://salttiger.com/?s=node" target="_blank" rel="noopener">node 编程的书</a></li></ul></li></ul><h1 id="11-月"><a href="#11-月" class="headerlink" title="#11 月"></a>#11 月</h1><ul><li><p>11-01</p><ul><li><p><a href="https://segmentfault.com/a/1190000008537712" target="_blank" rel="noopener">编写 Node.js Rest API 的 10 个最佳实践</a></p></li><li><p>《投资中最重要的事》- 霍华德·马克斯</p></li></ul><blockquote><p>价值投资者的“降龙十八掌”秘籍:简要概括如下：</p><p>1.最重要的不是盲目相信股市总是有效或者总是无效，而是清醒认识股市相当高效而且相当难以击败，只有真正的高手才能长期战胜市场。</p><p>2.最重要的投资决策不是以价格为本，而是以价值为本。</p><p>3.最重要的不是买好的，而是买得好。</p><p>4.最重要的不是波动性风险，而是永久损失的可能性风险。</p><p>5.最重要的巨大风险不在人人恐惧时，而在人人都觉得风险很小时。</p><p>6.最重要的不是追求高风险高收益，而是追求低风险高收益。</p><p>7.最重要的不是趋势，而是周期。</p><p>8.最重要的不是市场心理钟摆的中点，而是终点的反转。</p><p>9.最重要的不是顺势而为，而是逆势而为。</p><p>10.最重要的不是想到逆向投资，而是做到逆向投资。</p><p>11.最重要的不是价格也不是价值，而是相对的性价比，即安全边际。</p><p>12.最重要的不是主动寻找机会，而是耐心等待机会上门。</p><p>13.最重要的不是预测未来，而是认识到未来无法预测但可以先作好准备。</p><p>14.最重要的不是关注未来，而是关注现在。</p><p>15.最重要的是认识到短期业绩靠运气，而长期业绩靠技术。</p><p>16.最重要的不是进攻，而是防守。</p><p>17.最重要的不是追求伟大成功，而是避免重大错误。</p><p>18.最重要的不是牛市跑赢市场，而是熊市跑赢市场。</p></blockquote><ul><li><p><a href="https://www.taoguba.com.cn/blog.action?userID=7148" target="_blank" rel="noopener">茅台 03 的博客</a></p><blockquote><p>冯柳谈投资风格分为三种类型：</p></blockquote><pre><code>1. 是买大家都知道它好的公司2. 二是买别人不知道它好但你知道、或者是别人都知道它好但你知道其实更好的公司3. 三是买大家都不知道它好的公司，你不知道我也不知道</code></pre></li></ul></li><li><p>11-08</p><ul><li>理解产品工具：判断力</li><li>“Do not multiply entities beyond necessity”<blockquote><p>“如无必要，勿增实体”，奥卡姆剃刀原则，简单地来说就是能不做的就不要做</p></blockquote></li></ul></li><li><p>11-09</p><ul><li><a href="https://joebiden.com/joes-vision/" target="_blank" rel="noopener">拜登竞选政治承诺</a> 若拜登当选，新能源相关政策利好特斯拉</li></ul></li><li><p>11-10</p><ul><li><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">Node.js 应用内存泄漏排查</a></li></ul></li><li><p>11-16</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTg2NTU0Ng%3D%3D&amp;mid=2656616259&amp;idx=1&amp;sn=d981ce87c2898bc333e5476310bc060d&amp;chksm=bd5de9e68a2a60f0d48baf17e4aca89ca6cbfbcd78b11dc0289972c679261265b7d23d8b0369&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">为什么阿里巴巴这一次能扛得起 11 亿的流量？没有发生崩溃！</a></li><li><a href="https://www.zhihu.com/special/19557769" target="_blank" rel="noopener">如何成为一名老司机</a></li></ul></li><li><p>11-18</p><ul><li><a href="https://coffee.pmcaff.com/article/epk0Dpg1ky" target="_blank" rel="noopener">王慧文清华产品课</a></li><li><a href="https://blog.poetries.top/node-learning-notes/notes/other/03-Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E9%89%B4%E6%9D%83%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">常见的前后端鉴权方式</a></li></ul></li><li><p>11-20</p><ul><li><a href="https://www.anychart.com/blog/2020/11/06/election-maps-us-vote-live-results/" target="_blank" rel="noopener">美国选举结果可视化</a></li></ul><blockquote><p>fox news 数据可视化做得就很棒啊，赏心悦目</p></blockquote><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/11-20.png" alt></p><ul><li>Elon Musk 谈想看到的简历内容: 你碰到过最难的问题以及是如何解决它的?</li></ul><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/11-20-1.png" alt></p></li><li><p>11-21</p><ul><li><p><a href="https://www.bilibili.com/video/BV1TC4y1Y71N?rt=V%2FymTlOu4ow%2Fy4xxNWPUZ4nLA0vJRxoey7MTTAVviIw%3D" target="_blank" rel="noopener">即刻 APP 重新归来，社交市场上还容得下小而美吗？涉及社区的发展方向：内容还是社交</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E8%82%A1%E6%9C%AC%E5%9B%9E%E5%A0%B1%E7%8E%87" target="_blank" rel="noopener">ROE</a></p></li></ul><blockquote><p>净资产收益率，是企业净利润与净资产的比值，其数值大小代表企业盈利能力的大小，例如作为股东，投入 100 万公司一年能赚回多少钱</p></blockquote><ul><li><p><a href="https://www.zhihu.com/question/22513866" target="_blank" rel="noopener">基石投资者</a></p><ul><li>签订协议，无论 IPO 最后项目定价在什么价位，认购一定数量的股票</li><li>基石投资者有六个月锁定期</li></ul></li><li><p><a href="https://www.huxiu.com/article/389376.html" target="_blank" rel="noopener">被推上神坛的高瓴资本</a></p></li><li><p>最近在看<a href="https://book.douban.com/subject/35188914/" target="_blank" rel="noopener">《价值》- 张磊</a></p><blockquote><p>一些想法：方法和策略能够战胜市场，但对长期主义的信仰能够赢得未来（附议：张磊在他的书中提出了一个颇具政治哲学意味的名词：长期主义，并将它跟高瓴资本牢牢绑定在一起，这被一些人视为挑战巴菲特的价值投资），股市投资的两种逻辑：零和游戏及把篮子做大；零和游戏是博弈论的一个概念，指参与博弈的各方在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”，股市有零和游戏的性质，但也不完全是。</p><p>耶鲁捐赠基金(机构投资)的 4 个显著特点：</p></blockquote><ol><li><p>独立严谨的投资分析框架</p></li><li><p>清晰的资产分类和目标配置体系</p></li><li><p>另类投资(私募股权)</p></li><li><p>投资信仰和极致的受托人精神</p></li></ol><blockquote><p>投资的目标是盈利还是实现某种社会理想，其间的平衡必须把握平衡</p><p>选择创业伙伴的三条标准：人品好、学习能力、能吃苦</p></blockquote></li></ul></li><li><p>11-22</p><ul><li><p>发现了一款很精致的时钟 App - <a href="https://apps.apple.com/cn/app/id1536358464" target="_blank" rel="noopener">谜底时钟</a></p><p>卖家秀：</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/11-22.png" alt></p><p>效果图：</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/11-22-1.png" alt></p><ul><li><p>在表单 DOM 结构外提交当前表单 <a href="https://twitter.com/m1guelpf/status/1330374315058073600" target="_blank" rel="noopener">via</a></p><p>  <img src="https://assets.wuxinhua.com//blog/assets/notes-2020/11-22-2.png" alt></p></li></ul></li></ul></li><li><p>11-25</p><ul><li><a href="https://www.yuque.com/barretlee" target="_blank" rel="noopener">Barret 李靖的语雀</a></li></ul></li></ul><h1 id="12-月"><a href="#12-月" class="headerlink" title="#12 月"></a>#12 月</h1><ul><li><p>12-01</p><ul><li><a href="内部同学做得分享，资料无法对外，后面准备自个码一个">你的第一本基金指南</a></li><li><p><a href="https://www.keychron.com/products/keychron-k3-wireless-mechanical-keyboard" target="_blank" rel="noopener">keychron-k3-wireless-mechanical-keyboard</a> 颜值爆表</p><p><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/12-01.png" alt></p></li></ul></li><li><p>12-02</p><ul><li><a href="https://mp.weixin.qq.com/s/ZunUxI3BraGzaSCZXyhzvg" target="_blank" rel="noopener">复盘马掌门事件</a></li></ul></li><li><p>12-03</p><ul><li><p><a href="http://www.myzaker.com/article/5f976e0a8e9f0965fe5cdc1a" target="_blank" rel="noopener">抖音内幕：时间熔炉的诞生</a></p></li><li><p><a href="https://www.ljsw.io/knowl/article/su.html" target="_blank" rel="noopener">《详谈》贝壳左晖 </a></p></li></ul></li><li><p>12-06</p><ul><li><a href="https://pca.st/qarctkc9" target="_blank" rel="noopener">一人公司 - 021 如何制作播客</a></li><li><a href="https://finance.sina.cn/tech/2020-12-03/detail-iiznezxs5050950.d.html?fromtech=1&amp;from=wap" target="_blank" rel="noopener">微众银行为什么会和“蛋壳们”纠缠在一起？</a></li><li><a href="http://orangebay.org/archives/109280" target="_blank" rel="noopener">Lululemon 为什么叫 Lululemon</a></li></ul><blockquote><p>创始人之前有个滑板品牌 Homeless 被日本人高价买走了，日本人就是要买纯正的美国品牌，因为日语中“L”不发音，所以这次索性直接用三个 L ￣ □ ￣</p></blockquote></li><li><p>12-07</p><ul><li><a href="https://www.bilibili.com/video/BV1jf4y1i7da" target="_blank" rel="noopener">太阳照在我身上暖暖的，但我的心还是冰冰的。</a></li><li><a href="https://www.ithome.com/0/518/436.htm" target="_blank" rel="noopener">Big Sur 替换应用 icon</a></li><li>免费的 <a href="https://macosicons.com/" target="_blank" rel="noopener">MacOS icon </a></li></ul></li><li><p>12-08</p><ul><li><a href="https://space.bilibili.com/486442591/channel/detail?cid=96964" target="_blank" rel="noopener">滑雪老司机 SnowSense 的教学视频</a></li></ul></li><li><p>12-09</p><ul><li><p><a href="https://m.okjike.com/originalPosts/5fd08c13fd7e8400187aa1cf?s=eyJ1IjoiNWFkOGM3NTdkNjUxNjUwMDE3MTI4MWVkIiwiZCI6Mn0%3D&amp;utm_source=wechat_session" target="_blank" rel="noopener">原神群吃瓜 =&gt; 张一鸣：“今天工作是很闲吗！图片均来自即刻”</a></p><p><img src="https://assets.wuxinhua.com/blog/assets/notes-2020/12-09-1.png" alt><br><img src="https://assets.wuxinhua.com/blog/assets/notes-2020/12-09.jpg" alt></p><blockquote><p>这个我感觉有点像<a href="https://ys.mihoyo.com/#/" target="_blank" rel="noopener">《原神》</a> + <a href="https://www.feishu.cn/" target="_blank" rel="noopener">飞书</a>联合搞事情… ps: 原神好不好玩我不清楚，但飞书还是挺好用的，如果你们公司有打算体验或更新协同办公软件的计划，也可以尝试切换到<a href="https://www.feishu.cn/customers" target="_blank" rel="noopener">飞书</a></p></blockquote></li></ul></li><li><p>12-14</p><ul><li><a href="https://posts.careerengine.us/p/5a6b4b6405bf3f73e0b7dfed" target="_blank" rel="noopener">潘乱 2018 年的老文章：即刻反对即刻</a></li></ul></li><li><p>12-16</p><ul><li><p><a href="https://chromeisbad.com/" target="_blank" rel="noopener">Chrome is bad</a></p><blockquote><p>为什么有时你的电脑这么卡，Chrome 在你的电脑上安装了一个叫做 Keystone 的东西，它邪恶地把自己从活动监视器隐藏了，使你的整个电脑变慢，即使 Chrome 不运行。</p></blockquote></li><li><p><a href="https://twitter.com/nishuang/status/1338873793838800900" target="_blank" rel="noopener">Atlantic Road 大西洋公路</a></p></li><li><p><a href="https://lutaonan.com/blog/tesla-model-3-review/" target="_blank" rel="noopener">中国制造 Tesla Model 3 长续航体验</a></p><blockquote><p>最近 Model 3 开了一段路，估计 100 多公里，也是我第一次体验“互联网汽车”，整个过程驾驶体验还是很不错，加速很给力，踩“油”超车、变道底气十足；Tesla 的一些细节也挺有意思，比如：Autopilot 模式可以设置“彩虹 🌈 大道”、记住驾驶人座椅、方向盘、后视镜的设置、利用方向盘玩赛车游戏等。如果是开别人的特斯拉记住上车后新增一个驾驶人再去调方向盘+座椅+后视镜，这样车主下次开的时候不用重新设置。</p></blockquote></li></ul></li><li><p>12-17</p><ul><li><a href="http://weibointl.api.weibo.com/share/188942478.html" target="_blank" rel="noopener">#谷歌年度热搜电影#</a></li><li><a href="https://mp.weixin.qq.com/s/dSHpjXgOO9r1kF226w5mVg" target="_blank" rel="noopener">P 站自我整顿 = =</a></li></ul></li><li><p>12-18</p><ul><li><a href="https://mp.weixin.qq.com/s/SY0glP9k75pQWd1pa675qQ" target="_blank" rel="noopener">美团王慧文退休</a></li><li>关于内卷化 =&gt; <a href="https://www.huxiu.com/article/395800.html" target="_blank" rel="noopener">如何摆脱内卷化？</a></li></ul></li><li><p>12-20</p><ul><li><a href="https://twitter.com/elonmusk/status/1340581313406001153" target="_blank" rel="noopener">elonmusk “示好”bitcoin</a><blockquote><p>这个图已经被玩梗玩坏了 ~<br><img src="https://assets.wuxinhua.com//blog/assets/notes-2020/12-20.png" alt></p></blockquote></li><li><a href="https://home.cern/science/computing/birth-web" target="_blank" rel="noopener">web 的诞生</a></li></ul></li><li><p>12-24</p><ul><li><a href="https://zhuanlan.zhihu.com/p/114089665" target="_blank" rel="noopener">在桌面养只宠物玩</a></li><li><a href="https://bookauthority.org/" target="_blank" rel="noopener">科技大佬们推荐的书单</a></li></ul></li><li><p>12-27</p><ul><li>推荐一家日烧，鳗鱼/和牛烧烤/招牌炸鸡 <a href="http://www.dianping.com/shop/13668932" target="_blank" rel="noopener">虎兵卫</a> 📍 三元桥霄云路</li><li>制作一个 notion 风格的头像 =&gt; <a href="https://www\.openpeeps.com/" target="_blank" rel="noopener">https://www\.openpeeps.com/</a></li><li><a href="https://book.douban.com/subject/2970855/" target="_blank" rel="noopener">麦克米伦谈期权</a></li><li><a href="https://book.douban.com/series/12464?page=1" target="_blank" rel="noopener">华章经典·金融投资</a></li></ul></li><li><p>12-28</p><ul><li><a href="https://happyxiao.com/internet/" target="_blank" rel="noopener">如何使用互联网</a></li><li><a href="https://t.me/durov/142" target="_blank" rel="noopener">Telegram 如何盈利</a></li></ul></li><li><p>12-30</p><ul><li><a href="https://etw.fm/2020-capsule" target="_blank" rel="noopener">时间胶囊，用声音记录 2020 年这一整年</a></li><li><a href="https://www.bbc.co.uk/programmes/p01zxm9b" target="_blank" rel="noopener">BBC The Men Who Made Us Spend</a></li></ul></li><li><p>12-31</p><ul><li>用时间胶囊节目的那句话总结一下 2020： “There are decades where nothing happens; and there are weeks where decades happen” – Vladimir Ilyich Lenin</li></ul></li></ul><p>如果你看到这里，希望以上对你有一些启发或收获 ~ ❤️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;The-fragment-of-knowledge&quot;&gt;&lt;a href=&quot;#The-fragment-of-knowledge&quot; class=&quot;headerlink&quot; title=&quot;# The fragment of knowledge&quot;&gt;&lt;/a&gt;# The fra
      
    
    </summary>
    
    
      <category term="年终总结,知识碎片,笔记,原神,字节跳动,声东击西,Elon Musk,马斯克,凯文梅耶尔,张一鸣,蚂蚁金服,基金,理财,Notion,飞书" scheme="https://wuxinhua.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-%E7%AC%94%E8%AE%B0-%E5%8E%9F%E7%A5%9E-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E5%A3%B0%E4%B8%9C%E5%87%BB%E8%A5%BF-Elon-Musk-%E9%A9%AC%E6%96%AF%E5%85%8B-%E5%87%AF%E6%96%87%E6%A2%85%E8%80%B6%E5%B0%94-%E5%BC%A0%E4%B8%80%E9%B8%A3-%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D-%E5%9F%BA%E9%87%91-%E7%90%86%E8%B4%A2-Notion-%E9%A3%9E%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>初探 Web Components</title>
    <link href="https://wuxinhua.com/2020/08/02/Web-Components/"/>
    <id>https://wuxinhua.com/2020/08/02/Web-Components/</id>
    <published>2020-08-02T08:58:01.000Z</published>
    <updated>2020-12-31T12:01:49.413Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年第一次了解到 <a href="https://www.webcomponents.org/" target="_blank" rel="noopener">Web Components</a> 这个概念，直到最近才开始尝试使用，这篇将简单介绍 Web Components，了解它的标准，解决什么问题以及它的优势，它提供的接口 API、兼容程度、如何使用它写一个简单的组件等。</p><h2 id="什么是-Web-Components"><a href="#什么是-Web-Components" class="headerlink" title="什么是 Web Components"></a>什么是 Web Components</h2><p>随着前端框架的流行，组件化开发已经趋于常态，我们通常会把功能通用的模块抽取然后封装成单个组件，这样使用和维护起来都会变得更加简单。但组件也受限于框架，例如一旦离开框架本身，组件就无法使用了，那有没有跨越框架范围的技术构建通用的组件呢？有的，就是今天要介绍的主角 Web Components。</p><blockquote><p>Web components are a set of web platform APIs that allow you to create new custom, reusable, encapsulated HTML tags to use in web pages and web apps.</p></blockquote><p>Web Components 是一套 Web API，允许你创建能在 Web 页面和应用中使用的自定义、可重用、封装的 HTML 标签。总体上来说 Web Components 是 “通过一种标准化的非侵入的方式封装一个组件”。Web Components 的概念最早由 Alex Russell 在2011年的 Fronteers大会上首次提出，2013年 Google 发布了 <a href="https://www.polymer-project.org/" target="_blank" rel="noopener">Polymer</a> 框架，是基于 <a href="https://www.polymer-project.org/" target="_blank" rel="noopener">Web Components API</a> 的实现，来推动 Web Components 的标准化。 2014 年的时候 Chrome 发布了早期的 v0 级别的组件规范，目前已更新到 v1 版本，被各大浏览器接受并支持。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>标准化  </p><p>  w3c 也不断在为 web 标准规范做努力，其中就包括 Web Components, 这套 API 规范成为标准被绝大多数浏览器支持后，我们就能开发更通用的组件了，不用花时间在框架的选择上，而是更聚焦在组件本身，通过 HTML、CSS、JS 来构建原生组件将会成为未来的前端标准。</p></li><li><p>非侵入式  </p><p>  侵入性是指设计时的组件耦合太强了，引入这个组件导致其它代码或者设计要做相应的更改来适应新组件，而非侵入式的组件没有过多的依赖，方便迁移至其他地方。Web Components 组件能够很好的组织好自身的 HTML 结构、 CSS 样式、JS 代码，而且不会干扰到页面中的其他代码。</p></li><li><p>不依赖第三方库或框架  </p><p>  Web Components 可以在不需要引入第三方的库或者框架的情况下通过浏览器的这套 API 创建可复用的组件，也可以和任意与 HTML 交互的 JavaScript 库和框架搭配使用。</p></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><strong><em>HTML templates</em></strong></li></ul><p>HTML 内的 DOM 模板，在 template 元素内声明，内联样式 style 需要放置在它的内部，模板技术引入了两个重要的元素 template 和 slot ，template 提供模板的功能，slot 则被用来提供一个占位符hao，使 template 更灵活。</p><p>template 标签本质上合 HTML 内置标签是一样的，但在 template 标签被激活前：</p><ul><li>标签不会被渲染，标签的内容也是会被隐藏 ，页面上看不到标签展示效果</li><li>模板里的内容不会有副作用，例如  script 标签里不的脚本不会执行，图片不会加载，<br>视频不会播放</li><li>基本上可以放置于任何节点上，例如 header、body 等；激活一个 template 最简单的方式是对它的内容做个深拷贝，然后再插入节点中，举个 🌰：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Web Components<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span> example - 1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"mytemplate"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comment"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'template'</span>)</span></span><br><span class="line"><span class="undefined">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">document</span>.querySelector(<span class="string">'#mytemplate'</span>);</span><br><span class="line">t.content.querySelector(<span class="string">'img'</span>).src = <span class="string">'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7b5bd4445364f3887f7b708c812ca48~tplv-k3u1fbpfcp-zoom-1.image'</span>;</span><br><span class="line"><span class="keyword">var</span> clone = <span class="built_in">document</span>.importNode(t.content, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(clone);</span><br></pre></td></tr></table></figure><p>用户信息卡片及 Slot 的实例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Web Components<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"profile-tpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"profile-name"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"profile-img"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">            <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="undefined">              display: block;</span></span><br><span class="line"><span class="undefined">              border: 1px solid red;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            img &#123;</span></span><br><span class="line"><span class="undefined">                max-width: 100px;</span></span><br><span class="line"><span class="undefined">                border-radius: 50%;</span></span><br><span class="line"><span class="undefined">                border: 1px solid seagreen;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">         </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">let</span> template =  <span class="built_in">document</span>.querySelector(<span class="string">'#profile-tpl'</span>);</span><br><span class="line">template.content.querySelector(<span class="string">'.profile-img'</span>).src = <span class="string">'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bec4077911a44e789fa163ac05b3a18~tplv-k3u1fbpfcp-zoom-1.image'</span>;</span><br><span class="line">template.content.querySelector(<span class="string">'.profile-name'</span>).textContent = <span class="string">'bytedance'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(template.content);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- slot例子 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"my-tpl"</span>&gt;</span>default text<span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"my-tpl"</span>&gt;</span>Let's have some different text!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><em>Custom Elements</em></strong></p><ul><li>创建自定义 HTML 标签</li><li>创建自定义 class 类</li><li>使用生命周期的 Methods 方法</li></ul></li></ul><p>定义新的元素标签，可以被解析成 HTML。定义时首先需要声明一个类，这个类需要继承 HTMLElement 类，这样能够使用组件的一些生命周期回调函数，这些函数帮助我们增强组件的能力。总结一下要点：</p><ul><li>新的定制类需继承 HTMLElement</li><li>当元素被挂载后会调用 connectedCallback 方法，代码中的this指向定制元素，这样我们可以在这个回调中使用 this.innerHtml 方法设置定制元素里的内容</li><li>定制元素带来的问题是你在里面定义的样式可能会影响到外部的dom元素样式，如何进行隔离内，这是下面要介绍的一个 api  Shaodow DOM 。</li></ul><p>生命周期回调函数：</p><ul><li>connectedCallback 元素被插入DOM 时触发</li><li>disconnectedCallback 元素从DOM 被移除时时触发</li><li>adoptedCallback 被移到新的文档中时触发</li><li>attributeChangedCallback 元素的属性被添加、移除、更新、取代时触发</li></ul><p>执行顺序(这里 attributeChangedCallback 在前面是因为需要调整配置，应该在插入 DOM 之前完成)：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> -&gt; attributeChangedCallback -&gt; connectedCallback</span><br></pre></td></tr></table></figure><p>用自定义标签的方式来实现一个用户卡片(user-card)的例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Web Components<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user-card</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;foo-bar&gt;&lt;/foo-bar&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCard</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'user-card'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'user-card'</span>, UserCard);</span><br></pre></td></tr></table></figure><ul><li><strong><em>Shadow DOM</em></strong></li></ul><p>这里的 Shaodow DOM 不应该跟常用的几个框架中的 Virtual DOM 混淆（Virtual DOM 主要是做性能层的优化），Shadow DOM 让我们能够创建一套完全独立于其它元素的 DOM 树，也叫“影子DOM”,有了它可以保证当前的这个组件是个具备独立功能的组件，与其它DOM元素互不干扰。跟 iframe 相似，是一个独立是沙盒，但它没有自己的 window，有一个轻量级 document，另外 shadowRoot 对象不支持所有的 DOM API ，支持主流的 getElementById、querySelector 和 querySelectorAll 等方法</p><p><img src="https://assets.wuxinhua.com//blog/assets/web-components/shadow-tree.png" alt></p><p><img src="https://assets.wuxinhua.com//blog/assets/web-components/shadow-dom.png" alt></p><p>结构：</p><ul><li>Shadow host： 一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。</li><li>Shadow tree：Shadow DOM 内部的 DOM 树。</li><li>Shadow boundary：Shadow DOM 结束的地方，也是常规 DOM 开始的地方。</li><li>Shadow root: Shadow tree 的根节点。</li></ul><p>Element.attachShadow() 方法会将 shadow DOM 树附加给特定元素，并返回它的 ShadowRoot。该方法只有一个对象类型，一个 Key 值 mode，可以设置为 open 或 closed 来指定该模式的打开和关闭。open 状态表示可以通过 JavaScript 来获取 Shadow DOM，close 状态 shadowRoot 将会返回 null。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shadow = elementRef.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> myShadowDom = myCustomElem.shadowRoot;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'user-card'</span>, UserCard);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">'open'</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'foo-bar'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="keyword">this</span>.shadowRoot.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;p&gt;I'm in the Shadow Root!&lt;/p&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'foo-bar'</span>, FooBar);</span><br></pre></td></tr></table></figure><p>并非所有 HTML 元素都可以开启 Shadow DOM，例如用 img 这样的非容器素作为 Shadow Host 不合理，而且会报错。目前支持的元素： article、 body、h1 ~ h6、header、 p、 aside、 div、aside、nav、span、section、main、footer、blockquote。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'img'</span>).attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);    </span><br><span class="line"><span class="comment">// =&gt; DOMException</span></span><br></pre></td></tr></table></figure><p>另一个标准 HTML Imports (例如使用 &lt;link rel=”import” href=”myfile.html &gt;)，已废弃不再详述。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>2016 年 Safari 开始支持 Custom Elements 和 Shadow Dom，Firefox 则是在 2017 年跟进，目前各 API 兼容性如下：</p><p><img src="https://assets.wuxinhua.com//blog/assets/web-components/web-components-api.png" alt></p><p><img src="https://assets.wuxinhua.com//blog/assets/web-components/custom-elements.png" alt></p><p><img src="https://assets.wuxinhua.com//blog/assets/web-components/html-templates.png" alt></p><p><img src="https://assets.wuxinhua.com//blog/assets/web-components/shadow-dom-can-i-use.png" alt></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>使用 define 定义自定义标签的时候，为了避免与原有标签冲突，不能使用单个单词强制使用短横线连接</li><li>定制元素标签不能是自闭合的，因为 HTML 只允许一部分元素可以自闭合。<user-card></user-card></li><li>自定义标签的样式可以直接在全局定义，也可以把组件的样式应该与代码封装在一起，例如在 template 定义 style</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">user-card</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p>与目前其它框架的比较</p><ul><li>Web Component 是 W3C 专门为组件化创建的标准，API 也是底层浏览器的 api，不存在跨框架无法使用的问题。</li><li>而且从浏览器层面解决了一些作用域的问题，使用 Shadow DOM 封装样式,而且不需要再打包构建能直接跑在浏览器上，也实现了用 JavaScript 来写 JavaScript，用 CSS 来写 CSS ，用 HTML 来写 HTML，React 是用 JS 来写 CSS。</li><li>标准的支持推动进展较慢，2013年提出 v0 版本，2016 年推进到 v1 版本，存在兼容性问题，坑还比较多</li><li>主流三大框架 Vue 、React 、Angular 均支持使用 Web components，目前也有一些库或工具实现讲框架的组件转成通用的 Web components 组件，以及例如 <a href="https://github.com/hybridsjs/hybrids" target="_blank" rel="noopener">hybird</a> 这样的 UI 库能用 functional 方式来编写 Web components 组件</li></ul></li><li><p>组件传值监听和事件绑定：</p><ul><li>如何传值及监听值的变化</li><li>通过 DOM 属性，使用 getAttribute 能拿到组件设置的值，同时利用 setAttribute 也能更新组件的属性值</li><li>同时利用 observedAttributes 及生命周期函数 attributeChangedCallback 完成对属性值的更新</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomComponent</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get observedAttributes() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"attributesName"</span>];</span><br><span class="line">  &#125;  attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">    <span class="comment">// 当属性值变更时做一些操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>事件绑定的方式比较简单，直接在自定义标签内添加事件监听即可，如果需要传递函数和内部触发函数，监听绑定 click 事件传入回调函数，在自定义组件内 dispatchEvent 触发点击事件</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.$btn = <span class="keyword">this</span>._shadowRoot.querySelector(<span class="string">'button'</span>);</span><br><span class="line">    <span class="keyword">this</span>.$btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>._timesClicked = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br><span class="line">    button.textContent = <span class="string">"Click me"</span>;</span><br><span class="line">    button.onclick = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._timesClicked++;</span><br><span class="line">      <span class="keyword">this</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">"clicked"</span>, &#123;</span><br><span class="line">        detail: <span class="keyword">this</span>._timesClicked</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.append(button);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">customElements.define(<span class="string">"click-counter"</span>, ClickCounter);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">document</span>.querySelector(<span class="string">"click-counter"</span>);</span><br><span class="line">counter.addEventListener(<span class="string">"clicked"</span>, (evt) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(evt.detail);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul><li><a href="https://github.com/webcomponents" target="_blank" rel="noopener">https://github.com/webcomponents</a></li><li><a href="https://www.webcomponents.org/" target="_blank" rel="noopener">https://www.webcomponents.org/</a></li><li><a href="https://github.com/dt-fe/weekly/issues/15" target="_blank" rel="noopener">精读《Web Components 的困境》</a></li><li><a href="https://dmitriid.com/blog/2017/03/the-broken-promise-of-web-components/" target="_blank" rel="noopener">https://dmitriid.com/blog/2017/03/the-broken-promise-of-web-components/</a></li><li><a href="https://robdodson.me/regarding-the-broken-promise-of-web-components/" target="_blank" rel="noopener">https://robdodson.me/regarding-the-broken-promise-of-web-components/</a></li><li><a href="https://blog.revillweb.com/open-vs-closed-shadow-dom-9f3d7427d1af" target="_blank" rel="noopener">shadow dom open vs close</a></li><li><a href="https://github.com/xufei/blog/issues/3" target="_blank" rel="noopener">从HTML Components的衰落看Web Components的危机 </a></li><li><a href="https://zh-hans.reactjs.org/docs/web-components.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/web-components.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 年第一次了解到 &lt;a href=&quot;https://www.webcomponents.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web Components&lt;/a&gt; 这个概念，直到最近才开始尝试使用，这篇将简单介绍 Web Comp
      
    
    </summary>
    
    
      <category term="Web Components" scheme="https://wuxinhua.com/tags/Web-Components/"/>
    
  </entry>
  
  <entry>
    <title>TL;DR</title>
    <link href="https://wuxinhua.com/2020/03/11/Too-Long-Dont-Read/"/>
    <id>https://wuxinhua.com/2020/03/11/Too-Long-Dont-Read/</id>
    <published>2020-03-11T02:49:26.000Z</published>
    <updated>2021-01-01T03:39:25.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><p>2020 真的是充满魔幻色彩的一年，对我个人来说也是很艰难的一年。一直以来计划里期待发生的事情没有如愿而至，倒是一些没有计划的事发生了，你有你的计划，但世界总是另有计划。很遗憾没有把家人、感情、生活、工作都照顾好，也没有达到大家对我的期待，有一段时间很绝望…。3 月份的时候没想好怎么来写这一篇日志，博客很久没有继续更新内容，也许有一天我会回来把当时的一些想法补上。</p><p>…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020&quot;&gt;&lt;a href=&quot;#2020&quot; class=&quot;headerlink&quot; title=&quot;2020&quot;&gt;&lt;/a&gt;2020&lt;/h1&gt;&lt;p&gt;2020 真的是充满魔幻色彩的一年，对我个人来说也是很艰难的一年。一直以来计划里期待发生的事情没有如愿而至，倒是一些没有计划
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 命令行之 Crontab</title>
    <link href="https://wuxinhua.com/2020/01/21/Learning-Linux-Series-Command-Line-Crontab/"/>
    <id>https://wuxinhua.com/2020/01/21/Learning-Linux-Series-Command-Line-Crontab/</id>
    <published>2020-01-20T16:00:00.000Z</published>
    <updated>2020-12-31T12:01:49.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇是 Linux 命令行学习、使用笔记中的一篇，主要介绍 Linux 下的任务管理 crontab，包括 cron服务、crontab 相关命令的使用。</p><p>日常接触 crontab 会多一些，通过 crontab 命令，可以让系统固定的间隔时间执行指定的 shell 脚本，在介绍 crontab 的使用前，先介绍一下定时任务 cron，cron(即 crond 守护进程) 是 Linux 系统下一个自动执行指定任务的程序，可以使用 service crond status 或 systemctl status crond 查看该服务状态，也可以使用 service crond start/stop/restart来管理它的状态。crond 服务是跟随系统默认启动的，cron 上跑的大多数是系统的一些计划性任务，例如日志的记录、清理等，而 crontab(cron table) 可以看做是 cron 的管理工具，用于安装、移除、列出 cron 进程任务，它是 Linux 或者类 Unix 系统中最为实用的工具之一。</p><p>在 Linux 的 /etc 目录下你会发现以下的几个文件：</p><ul><li>cron.hourly // 每小时执行</li><li>cron.daily // 每天执行</li><li>cron.weekly // 每周执行</li><li>cron.monthly // 每月执行</li></ul><p>如果把脚本放入对应的文件中，根据文件的名字就知道 cron 会以对应的频率执行里面的脚本，同样的用户也可以通过 crontab 来制定自己的 cron 脚本，用户的脚本文件会以用户名为目录放置在 /var/spool/cron/user_name 目录下。</p><h2 id="crontab-规则"><a href="#crontab-规则" class="headerlink" title="crontab 规则"></a>crontab 规则</h2><p>crontab 最小的时间单位 1分钟，5 个 * 对应的是 分(0-59) 时(0-23) 日(1-31) 月(1-12) 星期(0-7) 的时间设置，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * command</span><br><span class="line">----------------</span><br><span class="line">| | | | |</span><br><span class="line">| | | | ---- 周当中的某天 (0 - 7) (周日为 0 或 7)</span><br><span class="line">| | | ------ 月份 (1 - 12)</span><br><span class="line">| | -------- 一月当中的某天 (1 - 31)</span><br><span class="line">| ---------- 小时 (0 - 23)</span><br><span class="line">------------ 分钟 (0 - 59)</span><br></pre></td></tr></table></figure><blockquote><p>minute   hour   day   month   week   command</p></blockquote><p>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p><ol><li>一个口诀，分时日月星。5个 * 数值的设置 分(0-59) 时(0-23) 日(1-31) 月(1-12) 星(0-7) </li><li>crontab 符号规则：<ul><li><ul><li>每，星号代表所有可能的值，例如 日 字段是星号，表示每日会执行该命令</li></ul></li><li><ul><li>到，理解为一个时间段内都执行，取值整数范围 1-5， 代表 1 2 3 4 5 分钟均会执行一次</li></ul><ul><li>, 用于多个值，指定一个范围，例如 1，10 为第 1 和第 10 分钟</li><li>/ 隔，是一个时间间隔  */10 每10分钟执行一次</li></ul></li></ul></li></ol><h2 id="crontab-命令："><a href="#crontab-命令：" class="headerlink" title="crontab 命令："></a>crontab 命令：</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure><p>列出当前机器下设置的定时任务，加上 -u 列出指定用户的定时任务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ crontab -u root -l</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure><p>按 i 进入编辑状态，制定定时任务</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ crontab -r</span><br></pre></td></tr></table></figure><p>移除某个用户的的 crontab 任务文件，如果不指定某个用户，则默认删除当前用户的 crontab</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ crontab -r -u username</span><br></pre></td></tr></table></figure><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>每分钟执行一次</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  * * * * * bash <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>每小时第3分钟、第15分钟执行一次</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  3,15 * * * * bash <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>每小时执行一次</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  * */1 * * * bash <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>每天的凌晨 3 点运行脚本</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  0 3 * * * bash <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>每天晚上的 21:30 点运行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  30 21 * * * bash <span class="built_in">command</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这篇是 Linux 命令行学习、使用笔记中的一篇，主要介绍 Linux 下的任务管理 crontab，包括 cron服务、crontab 相
      
    
    </summary>
    
    
      <category term="Crontab,定时任务,cron,Linux 命令行" scheme="https://wuxinhua.com/tags/Crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-cron-Linux-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>今年看的书📚(2019)</title>
    <link href="https://wuxinhua.com/2019/12/30/The-Books-I-Read-In-2019/"/>
    <id>https://wuxinhua.com/2019/12/30/The-Books-I-Read-In-2019/</id>
    <published>2019-12-30T11:43:48.000Z</published>
    <updated>2020-12-31T12:01:49.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com/blog/assets/book-list-2019/2019-books.png" alt></p><p>人总是会疲倦，但读书不会让人感到厌倦。跟往年一样，不谈理想，也不贩卖焦虑，总结一下这一年读的一些书，博客今年也没怎么更，还好看书没怎么落下，年初买了一些纸质的书，实体书上下班路上不太方便阅读，基本是阅读电子书，前前后后翻了很多书（至少 50+），看的书也比较杂，这里拿了其中的几本，聊一聊书中感兴趣的内容，读完都有哪些感悟，书单顺序不代表推荐程度，毕竟书没有好坏之分，只有合不合自己的阅读胃口。希望这篇读书总结对同样喜欢阅读的你也有一些收获。</p><h3 id="《Permanent-Record-永恒记录》"><a href="#《Permanent-Record-永恒记录》" class="headerlink" title="《Permanent Record 永恒记录》"></a><a href="https://book.douban.com/subject/34862375/" target="_blank" rel="noopener">《Permanent Record 永恒记录》</a></h3><blockquote><p>I did a dangerous thing for a man in my position, I decided to tell the truth</p></blockquote><p>2013 年，前美国中央情报局 CIA 职员、NSA(国安局) 技术员、也是该书的作者斯诺登在香港向媒体透露了西方政府大规模监控项目的相关机密文件，在国际社会引起了轩然大波，随后遭到美国的通缉，目前他在俄罗斯流亡已超过6年。《永恒记录》可以说是爱德华.斯诺登的自传，分为三部分分别讲述他童年、少年以及成年时期的故事，叙述他从一个爱国青年到骇客特工，再到“泄密者”的人生经历，也算是他自己完整的一份永久记录。</p><p>斯诺登出生于 1983 年，在那一年，美国国防部开始把内部互联计算机系统分成两部分：一个是军用网络（Milnet）另一个是民用网络也就是被我们熟知的互联网（Internet），而真正意义的万维网直到 1989 年才诞生，由英国科学家蒂姆·伯纳斯-李发明。出生于这个时期的斯诺登与互联网、联邦政府结下了不解之缘，他家庭的几个成员供职于政府或军队，与美国政府有紧密的联系，外祖父是海军上将，父亲供职于海岸警卫队，他在很小的年纪从父亲那了解并得到了一台计算机，并且迷上了互联网这个匿名世界。在他成长阶段还经历了抑郁症、父母离异等事件，对他影响最大的应该是 2001年发生的 “911” 事件，在书中他写道 “9 月 12 日是新时代的开始，美国人民团结一致的决心坚定，爱国主义高涨，美国本可以利用这个机会做更多的改变，但美国当时却选择了开战。” 当时的他毫不犹豫地支持了这个决定，这也成了他这一生最后悔的事，随后他决定入伍。</p><p>退伍后的斯诺登先后在国安局、中情局任职，在国安局工作时期，他并非真正意义的政府机构职员，为了削减开支，美国政府会将一些政府系统的服务、情报工程等外包，斯诺登通过承包商成了一名为政府效力的系统管理员，也就是我们称呼的“外包”，但其实给国安局当“外包”也并非是件容易的事，期间他还需经过各种背景调查、审核，甚至包括美国情报机构的调查，他供职的公司不久后被戴尔公司收购了，他顺理成章地成了一名戴尔员工，先后在美国弗吉尼亚中情局、中情局日内瓦工作站、国安局日本横田美军基地太平洋技术中心(PTC)、夏威夷国安局工作。由于身份和职业的特殊性，他有机会接触到一些机密的文件，他利用这个机会开发了一款叫“心跳”的程序，能够检索这些档案数据库，用来收集自己关注的信息，利用这个程序斯诺登逐渐获得的美国监控计划的很多机密文件。</p><p>书中披露的一些内幕：</p><ul><li><p>目前来说，网络基本上属于美国，互联网虽然不是美国人发明，但网络使用方式却由美国主导，正如棒球、篮球一样，拥有极大的主场优势。大多数网络基础建设都由美国掌控，包括电缆、卫星、服务器与基地等，全球超过九成的网络流量依赖的是美国政府与美国企业研发、拥有或控制的技术，而这些企业多数位于美国。</p></li><li><p>国安局的终极目标就是将收集、制造的情报资料永远储存下来，创造出一个完美的记忆库、一份永久的记录档案。</p></li><li><p>除了著名的 PRISM 计划（棱镜计划），其实还有一个 Upstream Collection（上游收集计划）。两者监控信息的方式不太一样，棱镜计划可以定期让微软、雅虎、谷歌、脸书、Paltalk、YouTube、Skype、AOL 及苹果收集目标资料，包括电子邮件、照片、视频聊天、网络浏览记录、搜索引擎搜寻记录，以及存储在云端的数据。上游收集计划更具侵入性，他们打造秘密监听设备，植入全球网络服务供应商的企业设施内部，可以固定从民营的网络基础设施上——例如全球网络流量的转换器与路由器、经由太空卫星和高容量海底光纤电缆，直接抓取资料。总的来说，国安局通过这两个项目来确保全球信息都可受到监视，包括存储的与传输的信息。</p></li><li><p>小布什总统在“9·11”事故后授权国安局对总统进行监控，也就是最具争议的总统监控计划（President’s Surveillance Program，PSP），据说连德国总理默克尔也在美国监控名单里。</p></li><li><p>书中介绍了国安局的 XKeyscore 系统，可以把它理解为一个搜索引擎，你可以在上面搜索任何记录，想象这是另一种谷歌浏览器，它显示的搜索结果不是公共网络的页面，而是搜索目标的私人电子邮件、聊天记录、私人档案等，国安局形容 XKeyscore 是最为全面性的工具，用以搜索使用者在网络上所做的每一件事。</p></li><li><p>还有一个插曲，斯诺登逃亡滞留俄罗斯机场后，还造成了总统专机被迫降检查的事，让俄罗斯当局颜面尽失。2013年 7月1日，玻利维亚总统埃沃·莫拉莱斯（Evo Morales）结束天然气输出国论坛年度大会后，搭乘专机从莫斯科伏努科沃机场离开。由于莫拉莱斯曾对斯诺登的处境公开表达同情，美国怀疑斯诺登藏匿在专机里并飞往南美，于是向意大利、法国、西班牙与葡萄牙施压，不准飞机进入他们国家领空，最终导致专机在奥地利首都维也纳迫降，此专机遭到停飞、搜查，直到确认没有藏匿斯诺登才放行。这件事也令俄罗斯颜面无光，因为他们无法确保来访的国家元首能顺利回家。</p></li></ul><p>总得来说是一本不错的书，中文版关于中国的一些内容有删减，不想错过这部分内容的的可以去看英文原版。泄密这种事是有前车之鉴的，美国大兵拉德利·曼宁和维基解密网站的阿桑奇合作曝光大量阿富汗战争、伊拉克战争的秘密文件，曼宁因泄密被判 35 年监禁（后被赦免减刑至7年），而阿桑奇被通缉后在英国的厄瓜多尔大使馆寻求政治避难，2019 年厄瓜多尔政府取消了对阿桑奇的政治庇护，“借宿”大使馆 7 年后，走出大使馆的他已白发苍苍，英国警方随后逮捕了阿桑奇；斯诺登对于美国政府来说是个“叛徒”，但对于民众来说，他是个英雄，他让这个庞大的全球监听系统曝光于天下，很难想象这需要多大的勇气并且在承受巨大的压力情况下来讲出真相。斯诺登在泄密前曾考虑将资料提供给维基解密网站，但最后还是觉得飞到香港通过媒体公布情况，为什么选择香港？因为香港确实是当时最好的选择：1.经济、交通、媒体发达；2.香港特別行政区属于中国，就这件事大陆基本上不太可能跟美国有合作，既能保护自由和异议分子，又能保证他爆料后不被拘留移交美国。让我感到意外的是既然国安局连其他国家的总统都能监听，为什么没有觉察到系统内部人的“吹哨”呢？还是说整个事件有不为人知的另一面？</p><p>科学技术是一把双刃剑，互联网技术的发展和更新真的是太快了，法律及对用户隐私的保护措施已经跟不上技术的更新。我的感觉是目前只要你接入了互联网，基本已经不存在什么用户隐私受保护了，各种手机软件明目张胆地收集用户信息，记录了你的衣食住行，举一些例子：搜索引擎、浏览器知道你每天的浏览喜好，打车软件记录了你的行踪，甚至家庭住址、工作地，甚至连输入法也有可能上传了你的输入内容进行分析。更可怕的是我们很难想象被盗取的这些个人信息被卖给谁，之后拿这些信息做了什么。关于隐私保护这块，信息加密软件或使用 Tor 网络可能会提供一些帮助，但不可否认的是我们在网络上留下的所有足迹已经变成了别人用以牟利的商品。</p><h2 id="《Nonviolent-Communication-A-Language-of-Life-非暴力沟通》"><a href="#《Nonviolent-Communication-A-Language-of-Life-非暴力沟通》" class="headerlink" title="《Nonviolent Communication A Language of Life 非暴力沟通》"></a><a href="https://book.douban.com/subject/3533221/" target="_blank" rel="noopener">《Nonviolent Communication A Language of Life 非暴力沟通》</a></h2><p>这本书读起来可能会比较枯燥，道理我们都懂，但是还是没办法好好说话。我们每天花费了很多时间在与别人沟通上，很多时候沟通的障碍或误解都是双方信息不对称导致的，这本书应该能帮助改善这一现象。非暴力沟通意味着让爱融入生活，让尊重、理解、欣赏、感激、慈悲和友情来主导生活，而非自私自利、贪婪、憎恨、偏见、怀疑和敌意。简单地来讲就是希望我们能转变谈话和聆听的方式，既需要坦诚、清晰地表达，也需要尊重倾听他人。总结一下非暴力沟通的四个要素：1、观察；2、感受；3、需要；4、请求，观察是指我们在沟通、聆听的时候需要学会观察环境、对方、观察上下文，尽量用观察而不是评价或批判。感受是最直接的，一句夸赞和一句批评给人带来的是两种截然不同的感受，对他人的评价实际上反映了我们的需要和价值观，如果直接说出我们的需求，换来的可能是更积极的回应。在表达观察、感受和需要之后，我们请求他人的帮助。以什么样的方式提出请求容易得到积极回应呢？即清楚地告诉对方需要他们做什么？不希望他们做什么？请求应该清晰、具体的，当对方提出请求时，我们应该给予反馈，如果对方没有反馈，也需要倾听他的感受和需要。非暴力沟通不是去改变别人，而是用于帮助我们在诚实和倾听的基础上与人联系。</p><h3 id="《幕后产品》"><a href="#《幕后产品》" class="headerlink" title="《幕后产品》"></a><a href="https://book.douban.com/subject/33396395/" target="_blank" rel="noopener">《幕后产品》</a></h3><p>网易云音乐想必大家都用过，也是我日常使用频率较高的一款应用，口碑一直都很不错。作者是网易云音乐的负责人王诗沐，即网易云音乐幕后的缔造者，本书讲他作为产品经理的成长之路。在书中他介绍了产品经理成长的三个阶段，第一阶段是修炼产品经理的基本功，能在执行层面做好产品工作，精通基础战术，业务能力、产品基础功应该扎实，例如打磨产品细节、如何对产品方向、功能做决策、锻炼产品思维模式等；第二阶段涉及到产品的定位、架构、顶层设计等；第三阶段也是最难的，上升到商业模式的层面了，像商业思维、洞察、战略设计这些。书中他列出了产品经理四个要诀 - “创业、求知、联想、善断”。对于我这种从事技术开发的人来说还是学到不少东西，能够了解产品经理日常是如何分析用户行为，设计产品结构，再到打磨产品细节等。</p><p>网易云音乐的一些功能在当时来说确认让人耳目一新，比如它的歌单功能，14 年的时候我把经常听的一些英文歌（10首）整理成了一个歌单，并且分享出去，没想到居然上了当天的首页推荐，收到了 2000+ 收藏，收听 10万+，哇，当时觉得挺新颖的，听歌还能这么玩，还有一些小小的成就感。例如后来的私人FM、跑步FM、以及音乐+社交模式（评论 999+，大家快忘了这是一款听歌应用了）、视频、直播、电台等，这款音乐软件已经超越听歌这一单纯功能，开始围绕听歌、音乐、视听内容将产品内容领域扩宽，突破音乐类产品的天花板，开始做强做大。可以说产品经理涉及到的能力确实挺广泛的，美学、心理学、市场营销、行为交互、数据分析等等各方面，最好能再懂点技术，但人的精力总是有限的，能掌握精通其中的某一些已经很不容易了，我认为优秀的产品经理跟普通的产品经理区别在于专业技能，顶尖的产品经理和优秀的产品经理的区别在于思想，就我目前的经历、遇到的一些产品来说，顶尖的产品经理就好像讲鬼故事一般，别人说的时候神乎其神，但现实生活中谁都没见到过。苏杰有一本书叫<a href="https://book.douban.com/subject/4723970/" target="_blank" rel="noopener">《人人都是产品经理》</a>，书名其实挺嘲讽的，也是对这个职业的无奈，因为人人都是产品经理本来就是个伪命题，只是好的产品经理很难碰到。例如有时我就觉得我好像也可以去当产品经理，因为我基本能把握用户的需求，画画原型、写 prd 文档也应该没问题，还有技术背景，跟开发、测试等技术同学沟通起来障碍应该会更小，但如果你要问我对产品未来整体思考、对这个行业的把握、针对产品用户行为探究规划产品路线、甚至制定产品战略、商业嗅觉(如何商业化变现，建立商业模式)、如何开辟一条新的业务？这些我就比较难回答了，目前我所认识的比较很多的产品经理都是停留在第一阶段（这也可能跟我自身所处的环境有关吧）。</p><h3 id="《LE-PIEGE-AMERICAIN-美国陷阱》"><a href="#《LE-PIEGE-AMERICAIN-美国陷阱》" class="headerlink" title="《LE PIÈGE AMÉRICAIN 美国陷阱》"></a><a href="https://book.douban.com/subject/33379779/" target="_blank" rel="noopener">《LE PIÈGE AMÉRICAIN 美国陷阱》</a></h3><blockquote><p>一个人最终什么都能适应，就算是看守所也是一样！</p></blockquote><p>很精彩的一本书，这本书的作者皮耶鲁奇，是世界500强法国巨头集团阿尔斯通的高管，在美国一下飞机就被逮捕扔进了看守所，随后的一系列的事件导致他和公司整个掉入美国设置陷阱里无法脱身，阿尔斯通活生生被收购肢解，整个事件被网友称为法国版华为事件，皮耶鲁奇也是现阶段“法国版本的孟晚舟”。是一本详细揭露美国司法当局与企业联手打击美国企业竞争对手阿尔斯通内幕的书，很精彩地描述针对皮耶鲁奇被关押，阿尔斯通被起诉过程中美国司法部、法国政府、阿尔斯通首席执行官、欧盟交锋博弈的细节。</p><p>2013 年 4 月 14 日，法国阿尔斯通集团锅炉部全球负责人皮耶鲁齐，乘坐的航班降落在美国的肯尼迪国际机场，他没想到机场等候迎接他的是美国联邦调查局的警察，随后被关押在美国，并且被指控在印尼塔拉罕发电站项目中为了拿下项目公司向当地议员行贿，被指控涉嫌违反美国的《反海外腐败法》10 余项罪名，叠加起来预计坐 125 年大牢。很显然美国司法部的最终目标肯定不是针对他个人，而是以小博大，利于这一点打击肢解法国这个巨无霸企业，美国司法部下令逮捕皮耶鲁奇是在向阿尔斯通的其他高管传递信号：如果不跟我们配合，下一个进去的就是你。随后阿尔斯通的首席执行官选择跟美国人合作，跟美国司法部、通用公司合作将公司包括电力在内的四分之三的业务卖给了美国通用公司，阿尔斯通还被罚了 7.72 亿美元，皮耶鲁奇形容这是 21 世纪绝无仅有、丑恶至极的跨国收购案。再来看看法国的阿尔斯通是怎样的一个跨国企业，可以说它曾经是全球交通运输和电力基础设施领域的先驱，业务涉及核能、水电、燃气、锅炉、电气、轨道交通等各领域，是法国本土的高度战略型企业，被誉为法国的“工业明珠”，阿尔斯通有多厉害呢？它曾负责法国境内 58 座核反应堆所有汽轮发电机的制作、维护更新工作，负责法国 75% 的电力生产设备，甚至连戴高乐航母推进汽轮机也是由阿尔斯通提供的…，阿尔斯通在法国的地位类似于美国的通用，德国的西门子公司，通过这次操作，美国人基本上已经控制了法国的所有核电站后续维护工作，这是多么恐怖的一件事。</p><p>了解一下《反海外腐败法》这部法律，书里记录这部法律的前世今生:</p><p>1977年，水门事件东窗事发，直接导致总统尼克松下台。在调查这桩丑闻的时候，美国司法机关揭露出一个暗地贿赂外国公职人员的庞大体系，涉及 400 多家美国公司。为此，美国总统卡特通过立法，禁止美国公司向外国公职人员支付佣金，这就是最初版本的《反海外腐败法》。</p><p>这部法律自生效以来，就受到美国行业巨擘的质疑，而美国政府也明白，并不想真的拿它打压自己国家的的企业，如果能把它用在别的国家的竞争对手上，将会产生巨大的威力。1998年，美国国会修改法律，美国《反海外腐败法》将同样适用于外国公司，比如只要它用美元计价签订合同，或者通过美国的邮件服务器收发邮件，使用美国公司提供的云服务等，美国自诩为“世界警察”，想当然的认为自己有权追诉这些公司。真的是匪夷所思，一部本国颁布的法律竟然也在境外执行，摇身一变成了打压国外竞争对手的利器，十几年来，美国在反腐败法的伪装下，成功地瓦解了欧洲的许多大型跨国公司，特别是法国的跨国公司，至2008年来，被美国罚款超过 1 亿美元的企业达到 26 家，这值得所有中国公司提高警惕，避免阿尔斯通、中兴类似的事情再次发生。</p><h3 id="《OKR工作法：谷歌领英等顶级公司的高效秘籍》"><a href="#《OKR工作法：谷歌领英等顶级公司的高效秘籍》" class="headerlink" title="《OKR工作法：谷歌领英等顶级公司的高效秘籍》"></a><a href="https://book.douban.com/subject/27132072/" target="_blank" rel="noopener">《OKR工作法：谷歌领英等顶级公司的高效秘籍》</a></h3><p>我在之前工作过的公司已经稍微了解了 OKR 这一工具，当时对我来说比较新颖的，也是第一次写 OKR，比较可惜的是写之前并没仔细阅读这本书，导致 OKR 写得不尽人意，看完这本书之后也会向朋友安利尝试去使用 OKR。这本书篇幅比较小，整体来说干货还是比较多，OKR（Objective - Key Results) 是一个目标管理体系，一套严密的思考框架和持续的纪律要求，以目标、结果为导向，O 代表 Objective,是团队或个人的工作目标，KR 指 Key Result, 是可衡量的关键结果。OKR 起源于英特尔公司，后来被谷歌、领英等互联网公司推广使用后，都实现了持续高速的增长，目前国内很多公司已经开始使用 OKR 来管理公司了。</p><p>OKR 带来的一些好处：</p><ul><li>OKR 是公司内是公开透明的，这样做的好处就是每个人知道公司其他人在干什么，沟通起来也会更加顺畅。</li><li>OKR 是在一定周期内为企业和团队设定的战略和目标，因为OKR的实施顺序是从上往下的，使得公司能够绝对聚焦朝一个方向努力，并在这个过程中员工能明确自己的位置，贡献自己力所能及的力量。</li></ul><p>如何来制定 OKR，撰写时的一些坑尽量避开：</p><ul><li>OKR 中 O 必须是明确的，可实现的，最多 5 个 O，每个 O 最多 4 个 KRs，3-5 个目标较合适，过多的目标导致工作精力的分散；</li><li>OKR 的结果必须是可量化的；</li><li>个人 OKR 要与整体相匹配契合；</li><li>OKR 不等同于绩效，如果公司将这两着挂钩，那建议使用 KPI；</li><li>目标设置具备挑战性（谷歌使用0-1.0分制度，0.6-0.7分恰到好处）；</li></ul><h3 id="《硅谷之火》"><a href="#《硅谷之火》" class="headerlink" title="《硅谷之火》"></a><a href="https://book.douban.com/subject/26306584/" target="_blank" rel="noopener">《硅谷之火》</a></h3><blockquote><p>我希望蒸汽动力能够进行各种数学运算 - 查尔斯.巴比杰</p></blockquote><p>记住上面这句话，计算器的诞生就是源于上面这个大胆的设想。这是一本讲计算机诞生历史的书，介绍计算机爱好者以创新精神和坚持不懈的努力，设计研发出计算机的故事。如果你想了解早期的计算机是什么样子？早期的计算机操作系统是如何设计研发的？BASIC 语言的起源，以及苹果、微软、Intel 这些公司是如何建立起来，那么可以把这本书加入到你书单里。这里主要想跟大家聊聊到底谁才是公认的世界上第一台计算机以及仙童公司“八大叛逆”背后的故事。</p><p>说到第一台计算机，我脑海里浮现的第一个名字是 ENIAC（埃尼阿克），它的全程叫“电子数字积分计算机”，ENIAC 是英文 Electronic Numerical Integrator And Computer 首字母的缩写。来看下当时它的一些参数：</p><ul><li>诞生于 1946 年 2 月 14 日（情人节）</li><li>重 28 吨，占地 170 平，内置 18600 个电子管</li><li>并非二进制，而是采用十进制</li><li>国家项目，预算 15 万刀，结果超支 3 倍以上</li><li>目的用来计算炮弹弹道，但当它研制出来的时候，二战已经结束了</li><li>真空管的电耗和自身的损耗都非常严重，据说当时每开一次机，费城西区电灯为之黯然失色，每 15 分钟会坏掉一只电子管。</li></ul><p>让我们把时针再往前拨回到 1833 年，英国的数学家、天文学家、发明家查尔斯.巴比杰提出了一个大胆的设想：让蒸汽动力能够进行各种数学运算。为了让设想变成现实，他开始着手设计使用蒸汽机来辅助数字的运算，而且他的确研制出了一款声称能够自己思考的机器，还给它取名“分析机”，这台机器在进行计算时会发出巨大的响声，数字存储和输入得通过机械齿轮装置发生作用来实现，这是最早计算机的雏形。</p><p>巴比杰在蒸汽时期使用蒸汽装置来设计计算机，到了电器时代，继电器代替了制动车轮和齿轮。19世纪60年底，美国精通布尔代数学的逻辑学家查尔斯·桑德斯·皮尔斯将符号学带进了美国，他发现流经复杂电路的开/关电流与逻辑中的真/假指是完全符合的，利用布尔代数可以模拟电器开关电路，反过来电路也可以来表示逻辑法，这样的话机型齿轮这些可以用模拟电器开关的电路装置代替（这类装置被称为开关元件或继电器），计算机的体积也会大大减少。1930 年本杰明·布拉克发明了第一台电动逻辑计算机，与此同时，国际商业机器公司也就是大家熟知的 IBM 已经开始研制并出售计算设备了，这时的计算器功能比较单一只能进行数学运算，无法进行逻辑运算，本质地说是体积巨大的计算器。在这之后 IBM 开始投入巨资研发新型机电式计算器，并与 1944 研发出 MARKI 型计算器,开发使用的是继电器。</p><p>很快继电器也被更好的选择电子管代替，电子管由爱迪生发明，是一种内胆真空的电子玻璃管，在具备某种条件下，电流才可以通过，所以这个是一个很好的电子开关元件，衣何华州立大学的数学和物理教授约翰.阿塔纳索夫和他的学生科里福德.贝里共同设计出来一款新的计算机 —— Atanasoff–Berry Computer 阿塔纳索夫-贝里计算机￼，简称为 ABC。ABC 最大的特点就是它的开关部件不是继电器，而是转而使用电子元件。这个变化是技术史上的一个重要飞跃，理论层面上来说，相比继电器，电子元件计算机无论是运算速度还是运行的效率都要高出许多。但由于资金的短缺，两人只能在实验室组装了一台比较简单的样机，从结构上来说，与早期的台式计算机非常接近了。</p><p>1943 年费城穆尔工程学院的约翰·莫奇莱和普里斯泊·埃克特曾提出制造 ENIAC 计算机￼的提议，两人在提议之后立刻动手开始建造这一计算机，后来也就有了前面的 ENIAC，也是第一台通用全电子数字计算机。为啥要加个“通用”呢，ENIAC 被制造出来后团队决定去申请美国专利，被认为“世界上第一台电子计算机”，结果阿塔纳索夫那边不干了，因为在在 1941 年的时候，ABC 计算机项目停滞后，阿塔纳索夫把 ABC 的设计思想告诉了约翰·莫克利，莫克利就是 ENIAC 项目后来的负责人之一，于是 ABC 的设计思想就被用到了 ENIAC 的制造当中，阿塔纳索夫起诉ENIAC团队抄袭ABC计算机的设计、专利等，后来经过漫长的官司，1973 年法院宣布撤销了 ENIAC 的专利，判定 ENIAC 的发明只是从ABC那继承了主要设计、构建思想，第一台计算机称号及相关的专利属于 ABC。关于ABC这一部分的历史我是通过网易云音乐FM栋哥的”软件那些事儿” 中解到了更多详细信息，<a href="https://music.163.com/#/program?id=2061233759" target="_blank" rel="noopener">200期：计算机真正的发明人（1）</a> 还介绍了背后的一些故事，感兴趣的也可以去收听一下。</p><p>计算机问世之后，英国的数学家艾伦·图林曾就计算机的运算提出过一种思路：他希望人们通过编码指令与计算机交流，让计算机读懂编码，依照指令执行并完成各项任务。计算机若是能够通过指令描述来完成任务的话，这才是真正意义上的通用计算设备。10年后，另一位数学家约翰·冯纽曼￼将图林的思路变成现实，他把指令变成了计算机编程，从而计算机开始具备了通用设备的性质。</p><p>再来看仙童（Fairchild）的故事和硅谷圈的背叛文化：</p><p>在硅谷，背叛和创新一样多。苹果初创于车库，Facebook源起于校园，但实际上很大一部分的公司的创业者是从成熟企业组织中“叛逃”出来的精英，例如摩尔、诺伊斯等著名的“八叛徒”，在1957年离开半导体公司后创建的仙童公司。</p><p>威廉·肖克利（William Shockley）由于在晶体管的发明而获得了诺贝尔奖，在这之后他于加州Mountain View的一个水果农场创建了肖克里晶体管实验室，试图将硅晶体商业化，他选择这个位置是因为距离他母亲很近，而他的办公室就在距离今天Google所在地不到三英里的地方。在他的公司里聚焦了一个小团队来制作第一代的晶体管，其中大部分都是是从斯坦福或MIT毕业的学生，可以说他是一位很伟大的工程师，但却不是一位称职的老板，不到一年的时间里，这部分员工大多离职或跳槽了。肖克利是个偏执的微观管理者，而且是个种族主义者，非常容易发怒，他后来去捐精，但附加了条件，只允许精子用于通过了门萨测试（一个高智商测试）的女性使用。他对下属也极度怀疑，甚至有一次要求所有员工测谎，肖克利的八名顶尖工程师发现了他们对老板有同样的不满，极难相处，他们联系了另一家名为仙童（Fairchild）的公司，后者愿意帮助他们创建一家新公司。在这八个人告诉肖克利他们要辞职时，他的助理告诉他们，感觉就像是“被好朋友在背后捅了一刀”一样，这些背叛者后来被称为“八叛逆”，而这个过程中取得关键作用的是Arthur Rock，这个人是美国科技投资历史上的传奇人物，仙童、英特尔、苹果等公司的成立都与他有关，感兴趣可以自行了解这位传奇。亚瑟帮这八个人找到了投资，这个人就是Sherman Fairchild，翻译过来就是谢尔曼费尔柴尔德，Fairchild中文名称仙童让人有点摸不着头脑，其实是意译，类似于Microsoft被翻译成微软。Sherman Fairchild 他本身就是个发明家，对技术很感兴趣，最关键的是他还很有钱，为啥？他是IBM最大的个人股东之一，他爸和Tom Watson一起创办了IBM😂。Fairchild和亚瑟、八大叛逆谈过后决定投资150万美元，这就是仙童半导体的由来，后来的故事大家也都知道了，仙童半导体的工程师离职后又去创建新的公司，前后共有一百多家，其中就包括Teledyne和英特尔。</p><p>这种背叛的频繁发生跟硅谷的公司文化和投资传统是有联系的。</p><p>与硅谷的“背叛”相对应的，是硅谷的宽容，加州法律比较倾向于支持跳槽者，不像纽约、新泽西州等地严格的执行同业竞争条款。在硅谷你周五离职了，周一就可以去新的公司上班，甚至都来不及跟朋友分享这一信息，员工辞职或者跳槽之后，可以继续从事原来的工作，甚至与前雇主直接竞争。</p><p>另一方面大公司倾向于对辞职的员工的创业公司进行投资，而不是“赶尽杀绝”。如果通过诉讼，大公司从“叛逃”员工身上获得的受益不会太多，却要陷入旷日持久的法律诉讼程序中；相反通过对“叛逃”员工进行投资，换取优先收购权或者购股权，获得的收益反而更高。</p><h3 id="《启示录：打造用户喜爱的产品》"><a href="#《启示录：打造用户喜爱的产品》" class="headerlink" title="《启示录：打造用户喜爱的产品》"></a><a href="https://book.douban.com/subject/5914587/" target="_blank" rel="noopener">《启示录：打造用户喜爱的产品》</a></h3><p>作者 Marty Cagan 曾担任eBay产品管理及产品设计高级副总裁，负责规划全球电子商务网站的产品和服务，在这本书中详细介绍他参与一些大公司软件和产品开发、管理的经验，很多观点理论性较强，但国内外情况还是有差异，有一些东西看看就好，放在国内并不一定实用。一些摘要：</p><ul><li>探讨如何做好一款成功的产品的三个方向：人员、流程、产品；</li><li>产品应该基于两点：1. 深入理解用户需求 2. 什么样的解决方案在目前阶段是可行；</li><li>很多产品失败的原因是公司对产品经理的职责界定不清楚导致的；</li><li>用户在没有解出到实际产品前，并不知道自己要什么；</li><li>好的产品经理：对产品足够的热情(足够的热爱才会付出努力)、换位思考能力(站在用户的角度去思考产品) 、敏锐的洞察力及解决问题的能力；</li><li>好的产品经理很多时候就藏着公司内部，有可能是公司的分析师、程序员、也可能是产品潜在的用户；</li><li>苹果公司的一些的启示：<ul><li>硬件 =&gt; 软件 =&gt; 用户体验 =&gt; 用户需求/情感需求；</li></ul></li></ul><h3 id="《星际穿越》"><a href="#《星际穿越》" class="headerlink" title="《星际穿越》"></a><a href="https://book.douban.com/subject/26413155/" target="_blank" rel="noopener">《星际穿越》</a></h3><blockquote><p>不要温和地走进那个良夜，老年应当在日暮时燃烧咆哮；怒斥，怒斥光明的消逝。</p></blockquote><p>我是因为电影才找到这本书的，我非常喜欢和享受观看《星际穿越》这部电影，这是一部讲述地球存亡，黑洞、虫洞、星际穿越、高维生命、时间弯曲、时间旅行、亲情的烧脑科幻大片，在我看过的所有科幻片里，它应该是 top3 的位置。这本书的作者是天体物理学巨擘基普·索恩，也是这部好莱坞大片的唯一科学顾问，这本书里蕴藏着电影背后深厚的科学知识，为了让这部电影的科学性更加准备，索恩在拍摄前制定了两个硬性条件：</p><ol><li>影片的情节不能违背已经确认的对宇宙的认知，包括已成定论的物料定律；</li><li>对尚不明确的物料定律和对宇宙的猜想要基于科学；</li></ol><p>为什么黑洞会吞噬一切物质？黑洞是一个光都无法逃逸的牢笼，无法看见黑洞，那么如何在电影里向观众展现黑洞？什么是潮汐力，如何利用引力弹弓来获得逃逸的加速度？为什么虫洞不是一个洞，而是一个球？除了我们日常使用到的x、y、z加上时间这四个维度，是否存在超越四维的第五个维度？枯萎病是否真的会导致地球的灭绝？电影中的“幽灵”引力异常现象是如何产生的？黑洞和虫洞的里面是什么？我们都能在这本书里找到答案。</p><p>关于黑洞：</p><p>1、任何东西都能掉进去，但没有东西能逃出来，包括光子，它们被锁在黑洞视界里；<br>2、黑洞的引力能让时间和空间弯曲；<br>3、很多的黑洞是在恒星死亡时自身坍陷形成的，如果牛顿的引力定律是正确的，坍缩就将持续加速，直到没有任何内部压力的恒星被高速挤压成一个点；<br>4、黑洞的形状、引力强度、轨道的偏转等由三个参数决定：黑洞的质量、角动量、电荷；<br>5、黑洞和虫洞是两码事，虫洞结构也不是一个”洞🕳”，而是一个球体形状；<br>6、旋转黑洞会辐射引力波，也辐射电磁波（光子）、中微子以及可能在自然界存在的所有其他形式的辐射；<br>7、依照广义相对论，球状恒星生成包围自己的黑洞视界后会继续无情地坍缩下去，直到没有体积却有无限大的密度，它在这里产生时空奇点，是时空曲率无限大、时空不再存在的区域；</p><p>建议配合他的另一本书<a href="https://book.douban.com/subject/1120886/" target="_blank" rel="noopener">《黑洞与时间弯曲》</a>一起食用效果更佳。</p><h3 id="《XGoogler-谷歌创业邦：关于梦想、创新、勇气与坚持》"><a href="#《XGoogler-谷歌创业邦：关于梦想、创新、勇气与坚持》" class="headerlink" title="《XGoogler 谷歌创业邦：关于梦想、创新、勇气与坚持》"></a><a href="https://book.douban.com/subject/26683032/" target="_blank" rel="noopener">《XGoogler 谷歌创业邦：关于梦想、创新、勇气与坚持》</a></h3><p>本来想通过这本书了解一些谷歌的东西，但貌似并不是合适的选择。这本书讲的更多的是前谷歌员工现在的创业故事，xGoogler 是一个特别的群体，谷歌的工作经历给予了他们发现、认识和提升自己的平台，离开Google后，他们带着技术及智慧投身到中国的创业浪潮中，例如科技投资领域专家的李开复、宓群，与雷军一同创立小米的林斌，涉及机器视觉、硬件研发的格灵深瞳公司赵勇等等，一群牛逼的人的故事，但感觉没啥深度，整体来说收获较少。已将<a href="https://book.douban.com/subject/4789228/" target="_blank" rel="noopener">《In the Plex：Google如何思考，運作和塑造我們的生活》</a> 加入了 2020 年的书单，进一步了解谷歌这家公司。</p><h3 id="《软技能：代码之外的生存指南》"><a href="#《软技能：代码之外的生存指南》" class="headerlink" title="《软技能：代码之外的生存指南》"></a><a href="https://book.douban.com/subject/26835090/" target="_blank" rel="noopener">《软技能：代码之外的生存指南》</a></h3><blockquote><p>作为一个软件开发人员，你的工作就是与人打交道（其实几乎所有的职业都是这样）</p></blockquote><p>有很多的书教我们新的编程语言，指导程序员如何才能写出更好的代码，我们每天花很多时间对产品进行优化迭代，对代码性能不断调优，但却很少去花时间去改进、优化自己本身，如何成为一个更优秀的个体，我们说的“优秀的软件开发人员”并不只是由于他精通编码之道，这本书侧重点放在整个“人”上，那到底什么是“程序员必备的软技能”？作者从职业生涯、个人营销、健康、自学、理财等方面来阐述，在这本书里能找到一些比较好的建议。</p><p>作为一名开发人员，我们值得去思考的一些点。例如：</p><ul><li>思考一下每天在做的事情？是否给你带来了收获，这是否脱离了你最开始设定的目标？ </li><li>对软件开发人员的印象就是写代码，但在软件开发领域，不仅仅是会写代码这么简单。我们除了跟机器打交道外，更多的是跟人相处，代码应该是写给人看的，顺带能在机器上运行。你是否经常在会上争吵，日常能很好地跟同事沟通、协作吗？你是否会换位思考问题？</li><li>基本上有人的地方就会有斗争，大多数机构、公司会存在办公室政治，作为程序员的我们应该保持警惕，但至少应该知道会发生什么事，尽管不能完全避开，但可以去了解哪些人需要避开，哪种人不要有交集。</li><li>关于创业问题，有没有去研究过一些创业公司，这些公司是如何发展起来的，这些公司创立时是一个创始人还是多个创始人？</li><li>如何选择自己的职业，选择去大公司还是中型企业还是小型创业公司？三者各有利弊，如何来权衡？</li><li>如何支配你的薪水，资产与负债，如何建立长远理财思维? 例如可以获得股息的股票或基金是资产，超过一栋你的实际需求的房子就是一笔很大的负债，开始学会理财和投资。文中作者也给出了自己对资产和负债的定义：<ul><li>资产：实用价值高于维护成本的东西</li><li>负债：成本高于带来价值的东西</li></ul></li><li>如何成为一名健康的软件工程师，制定跑步、健康饮食计划等，并且让你的屁股离开椅子。</li></ul><p>接着生存指南聊点自己的 2019 年作为一名软件开发人员的感受，今年确实有点难，工作、生活、家庭很多方面都不尽人意，现实跟梦想完全是两码事。2018 年开始国内整体大环境确实不太好，有人说 2019 年是过去 10 年最差的一年，也是未来 10 年最好的一年，我持保留意见，公众号一篇《2019，中国互联网让人失望的一年》成爆款，不知道是不是因为过度贩卖焦虑，目前已被下架。今年同样很多公司关门倒闭，身边被裁员、主动离职的小伙伴，互联网公司集体进入“寒冬”，公司“开猿节流”，这就意味着同一份工作你要面对的竞争者更多，压力也越大，作为软件行业从业者需要更专业的技能，更优秀的职业素养，更强的学习能力，不努力肯定是要被这个快速发展激烈竞争的行业淘汰；但自己也没有有过于担心，这不是人生中的全部，我觉得人应该处在接近舒适适度焦虑的一个中间地带，因为一直呆在一个舒适的环境里才是需要保持警惕，这种环境很容易让人麻木甚至退化，有竞争有压力并不是坏事。比如遇到一些技术大牛，或跟一些很优秀的同事共事，我不会觉得因为他水平比我高太多就觉得自己低人一等，我想他也不会因为他代码码得多好会变得傲慢，越优秀的人越谦逊。以前有时候觉得这事做到“不错”已经够了，但是当看到一些更优秀的人甚至更加努力的时候，就会发现对“不错”不应该心存侥幸，还是应该把事情做到极致，哪怕是手头正在码的几行代码。另一个感受就是软件开发真的不仅仅意味着编写高效、优雅的代码，在尽可能地提升自己的专业水平外，也应该花时间在自身的成长上，例如去扩展自己的能力和视野、建立职业生涯规划、保持生活工作的平衡、认识更多优秀的人、建立一个经常交流、有价值的朋友圈等。</p><p>其它的一些书这里没有提到的，阅读过程也收获很多，例如<a href="https://book.douban.com/subject/11524204/" target="_blank" rel="noopener">《围城》</a>(很经典，忘了是第几遍看了)、<a href="https://book.douban.com/subject/27614523/" target="_blank" rel="noopener">《刷新：重新发现商业与未来》</a>、<a href="https://book.douban.com/subject/5346110/" target="_blank" rel="noopener">《穷查理宝典》</a>、<a href="https://book.douban.com/subject/27154533/" target="_blank" rel="noopener">《终身成长》</a>、<a href="https://book.douban.com/subject/1102715/" target="_blank" rel="noopener">《从一到无穷大》</a>，<a href="https://book.douban.com/subject/34800351/" target="_blank" rel="noopener">《半小时漫画经济学》</a>、<a href="https://book.douban.com/subject/34454607/" target="_blank" rel="noopener">《三分钟漫画汽车史》</a>等，今年也尝试开始看一些快速阅读、快速消化的内容，如漫画、FM电台节目等，这里就不再详细介绍，安利一波微信读书，整体来讲电子书数量、排版、阅读体验都还不错，唯一让人摸不着头脑的是他们搞的铺天盖地的各种朋友圈分享、组队、答题等活动，就不能单纯地好好做一款读书软件吗？把书籍数量、阅读体验再提升一个档次。回头看了 18 年立的 flag 要阅读更多的书，但其实 19 年的读书时长并没有增长，阅读情况反而有所下降，而且内容还是比较单一，涉及的领域也大多围绕我自身的互联网行业，希望 2020 年能有所改变吧。在写完这篇读书总结后我突然意识到我在读的过程或者在写的过程也好，差不多快对书的一些内容没有多少记忆了，包括对书中的一些问题、现象的思考还是太少，例如我花了很多时间再去总结整本书的内容，却花了较少的时间来思考这本书给我带来的影响，这一点在之后的阅读和总结中会加以调整。当然我还是一直相信多读书是有意义的，可能短期内无法看见它带来的收益，我很享受发现一本好书，并一页一页地翻完的过程，能有收获那更好了，并且会持续把这些收获、影响分享扩散出去。之前在知乎看到一个很棒的回答：“读很多书的意义并不在对内容的记忆，而在于对一个独立人格和思想的培养，这些独立思想总结起来就是你的生存、处事的哲学”。这部分哲学有助于我们树立正确的三观，世界观说白了就是你对这个世界的态度，你是激进的还是保守的，你是左派还是右派；人生观是你选择如何过这一生，积极还是悲观；价值观也很重要，那些事是对的，哪些是错的，影响我日常对一些事物的判断和决策。积极的心态和坚定的信念将会带来正面的影响，而日常的一些困难或打击会给人挫败感，导致一些负面情绪，我们能做的是尽可能地让正面的影响盖过负面的情绪。2020年 继续加油，对这个世界保持好奇心，永远相信自己，相信美好的事情一定会发生。</p><p>18 年的一些读书笔记戳这 <a href="https://wuxinhua.com/2018/12/29/The-Books-I-Read-In-2018/">今年看的书📚(2018)</a></p><p><img src="https://assets.wuxinhua.com//blog/assets/book-list-2019/summary-1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com/blog/assets/book-list-2019/2019-books.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;人总是会疲倦，但读书不会让人感到厌倦。跟往年一样，不谈理想，也不贩卖焦虑，总结一下这一年
      
    
    </summary>
    
    
      <category term="2019年书单" scheme="https://wuxinhua.com/tags/2019%E5%B9%B4%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>译文：从 Travis 迁移至 GitHub Actions</title>
    <link href="https://wuxinhua.com/2019/11/30/Migrating-from-travis-to-GitHub-Actions/"/>
    <id>https://wuxinhua.com/2019/11/30/Migrating-from-travis-to-GitHub-Actions/</id>
    <published>2019-11-30T06:02:06.000Z</published>
    <updated>2020-12-31T12:01:49.407Z</updated>
    
    <content type="html"><![CDATA[<p>声明一下！非原创，这是一篇翻译文章，发布于 GTCC 社区，一篇讲 CI 从 Travis 迁移到 GitHub-Actions 的英语文章， 我将它翻译成了中文，顺便学习了一下 GitHub Actions，如果你想了解作者和原文 🔽：</p><p>文章作者：<a href="https://www.markphelps.me" target="_blank" rel="noopener">markphelps</a><br>原文地址：<a href="https://www.markphelps.me/2019/09/migrating-from-travis-to-github-actions/" target="_blank" rel="noopener">https://www.markphelps.me/2019/09/migrating-from-travis-to-github-actions/</a></p><h2 id="从-Travis-迁移至-GitHub-Actions"><a href="#从-Travis-迁移至-GitHub-Actions" class="headerlink" title="从 Travis 迁移至 GitHub Actions"></a>从 Travis 迁移至 GitHub Actions</h2><p>周末的时候，我决定将我 Go 语言的开源项目 <a href="https://github.com/markphelps/flipt" target="_blank" rel="noopener">Flipt</a> 的 CI 流程从 TravisCI 转移到 GitHub Actions，我想要替换我现有的 CI，并尝试使用新的 GitHub Actions 将手动发版过程自动化。</p><p><em>说明</em>：我在 GitHub 工作，但不在 Actions 团队。我想在我的开源项目中配置 Actions，并且不从 Actions 团队或 GitHub 的任何人那里获得任何帮助。我没有被 Github 的同事要求写这篇文章，我的目的很简单，以一个用户的经验来使用这个平台。仅代表个人观点和想法。<br>This conversation was marked as resolved by polaris1119</p><p>不用说，经过我几个小时的调试，我成功了<a href="https://twitter.com/mark_a_phelps/status/1172935552947118081?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1172935552947118081&amp;ref_url=https%3A%2F%2Fmarkphelps.me%2F2019%2F09%2Fmigrating-from-travis-to-github-actions%2F" target="_blank" rel="noopener">twitter 链接</a>。</p><p><img src="https://i.loli.net/2019/11/30/BDy3YCr5ZwgEbdL.png" alt="推特截图"></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>我不打算对比 workflow (流程) 、job(任务)、step(步骤) 等细节， GitHub 有广泛的文档来介绍 Actions 的 <a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" target="_blank" rel="noopener">用法</a> 和 <a href="https://help.github.com/en/articles/about-github-actions#core-concepts-for-github-actions" target="_blank" rel="noopener">概念</a>，我认为我想要的是很普通的一个 CI/CD 流程：</p><p>. push 代码到分支后运行一些单元测试，最好能够使用 Go 的多个版本<br>. 在 PR 上，我还希望运行一些更广泛的集成测试，用来测试面向公众的 API 和 CLI<br>. 推送 tag 后，我想触发 <a href="https://github.com/goreleaser/goreleaser" target="_blank" rel="noopener">goreleaser</a> 来构建一个 Docker 镜像并推送到 <a href="https://hub.docker.com/r/markphelps/flipt" target="_blank" rel="noopener">Docker Hub</a>，同时打包一个发版的压缩文件<br>. 在新版本更新文档时更新 <a href="https://flipt.dev/" target="_blank" rel="noopener">文档网站</a> </p><p>前两个步骤主要的 TravisCI 工作是在这个 <a href="https://github.com/markphelps/flipt/blob/90bafa834aec29cdaa3620b8ea30aa89466fe7d0/.travis.yml" target="_blank" rel="noopener">config文件</a>配置的，虽然有一些差异:</p><ol><li>我只测试了 Go 一个版本 (1.12.x)，我知道我可以使用 travis-ci 的 <a href="https://docs.travis-ci.com/user/build-matrix/" target="_blank" rel="noopener">matrix</a>设置来测试多个版本，只是我从来没有这样去用。</li><li>我只针对 PR 在 Postgres DB 实体环境上运行测试，</li></ol><p>我缺少的是用于实际构建发版和更新文档的 CD (持续部署)部分。我在本地机器上运行脚本依赖于设置一些需要保密的环境变量，依然是一个手动操作过程。这不是最理想的情况。</p><h2 id="容易实现的目标"><a href="#容易实现的目标" class="headerlink" title="容易实现的目标"></a>容易实现的目标</h2><p>我创建的第一个 action 实际上是自动更改文档部分。这一部分会被移动到管道作业流的最后一步，但也是能正常运行的最简单的一步。</p><p>它主要由两个文件组成，一个 <a href="https://github.com/markphelps/flipt/blob/4157e9b154a01b09a4eb60a8e43484cd3928fc89/.github/actions/publish-docs/Dockerfile" target="_blank" rel="noopener">Dockerfile</a> 用于安装必要的依赖项，另一个<a href="https://github.com/markphelps/flipt/blob/master/.github/actions/publish-docs/entrypoint.sh" target="_blank" rel="noopener">脚本</a> 用于运行构建和部署步骤。<br>我使用 <a href="https://www.mkdocs.org/" target="_blank" rel="noopener">mkdocs</a> 来构建文档并发布到 <a href="https://help.github.com/en/articles/creating-project-pages-using-the-command-line" target="_blank" rel="noopener">GitHub pages</a>。</p><p>我(最终)把它连接起来作为发布工作流程的最后一步:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">name: Publish Docs</span><br><span class="line">uses: ./.github/actions/publish-docs</span><br><span class="line">env:</span><br><span class="line">  GITHUB_TOKEN: <span class="variable">$&#123;&#123; secrets.GITHUB_TOKEN &#125;</span>&#125;</span><br></pre></td></tr></table></figure><p>它将通知 Actions 我希望使用 <a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions#example-using-action-in-the-same-repository-as-the-workflow" target="_blank" rel="noopener">local action</a> 存在的 action，并设置 <code>GITHUB_TOKEN</code> 环境变量，该变量是推送到 GitHub pages 所必需的。</p><h2 id="这些繁琐的测试"><a href="#这些繁琐的测试" class="headerlink" title="这些繁琐的测试"></a>这些繁琐的测试</h2><p>接下来我做的是让管道的单元测试部分运作起来。因为 <a href="https://github.com/markphelps/flipt" target="_blank" rel="noopener">Flipt</a> 是一个服务端应用程序，所以我目前只针对 Linux 环境，因此我不需要测试 Windows 或 MacOS 环境。虽然我知道 Actions 很酷并且也支持 😉。</p><p>然而，我确实希望能够使用多个版本的 Go 进行测试(撰写本文时为 1.12 和 1.13 )。Actions的 [matrix strategy]矩阵策略特性让这一切变得超级简单。</p><p>对于我的 workflow 工作流，它看起来像这样:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">  name: Test</span><br><span class="line">  runs-on: ubuntu-latest</span><br><span class="line">  strategy:</span><br><span class="line">    fail-fast: <span class="literal">false</span></span><br><span class="line">    matrix:</span><br><span class="line">      go: [<span class="string">'1.12'</span>, <span class="string">'1.13'</span>]</span><br></pre></td></tr></table></figure><p>这里设置两个作业并行运行，运行下面的所有步骤，其中一个 <code></code> 设置为 <code>1.12</code>，另一个设置为 <code>1.13</code>。</p><p>稍后在工作流文件中，我创建了一个步骤，这些值来将被用来在虚拟机上安装可用版本的 Go:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">- name: Setup Go</span><br><span class="line">  uses: actions/setup-go@v1</span><br><span class="line">  with:</span><br><span class="line">    go-version: <span class="variable">$&#123;&#123; matrix.go &#125;</span>&#125;</span><br><span class="line">  id: go</span><br></pre></td></tr></table></figure><p>它使用 <a href="https://github.com/actions/setup-go" target="_blank" rel="noopener">actions/setup-go</a> action 来安装我们指定的Go版本。这很酷。</p><p>实际上，我几乎立刻就看到了使用多个 Go 版本运行测试的好处，因为 Go 1.13增 加了一些新功能，我的一些测试代码已经无法通过。</p><p>查看发布说明:</p><blockquote><p>测试 flags 标识现在被注册到新的 Init 函数中，该函数会在测试生成的主函数调用。因此，测试 flags 标识现在只在运行测试二进制文件时注册，并且包名为 flag。包初始化期间的解析可能导致测试失败。<br>说明太长不建议阅读。我曾经在我的一个 <a href="https://github.com/markphelps/flipt/blob/fdf45bff66c325d702b54ae334e53ae8e3cac176/storage/db_test.go#L88" target="_blank" rel="noopener">测试</a> 中使用 init 函数来打开一些调试日志，如果设置了一个标志的话。事实证明这在 Go 1.13.1 会出现 <a href="https://github.com/golang/go/issues/31859" target="_blank" rel="noopener">问题</a>。</p></blockquote><p>我不认为在我真正尝试更新 Flipt 到 Go 1.13 之前能发现这个问题，目前我能够通过完全的测试在早期发现这个问题，这很酷。</p><h2 id="不愿多谈的问题"><a href="#不愿多谈的问题" class="headerlink" title="不愿多谈的问题"></a>不愿多谈的问题</h2><p>我在前面提到过，我还希望使用正式环境的 Postgres 数据库中运行单元测试。这是因为 Flipt 同时支持 <a href="https://github.com/markphelps/flipt#database://github.com/markphelps/flipt#databases" target="_blank" rel="noopener">SQLite 和 Postgres</a>，我希望对代码进行同等的测试。</p><p>幸运的是运行 Actions 构建操作的 Ubuntu 虚拟机似乎已经安装了 SQLite 所需的库，但是它们似乎没有安装 Postgres，这点与 Travis 不同。你可以在<a href="https://help.github.com/en/articles/software-in-virtual-environments-for-github-actions" target="_blank" rel="noopener">文档</a>中看到每个 VM 的所有已安装软件/库的列表。</p><p>这意味着我需要想办法找到一个 Postgres 服务来运行我的构建，这样我才能完成测试。</p><p>我最初尝试使用的一个步骤是使用 Docker 容器内使用 <code>docker run</code> 命令来运行 Postgres 。然而我很快发现 Actions 有一个针对这类问题的内置解决方案 - <a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions#jobsjob_idservices" target="_blank" rel="noopener">services</a>!</p><p>事实证明，<code>services</code> 指令正是我所需要的:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  postgres:</span><br><span class="line">    image: postgres:11</span><br><span class="line">    ports:</span><br><span class="line">      - 5432:5432</span><br><span class="line">    env:</span><br><span class="line">      POSTGRES_DB: flipt_test</span><br><span class="line">      POSTGRES_USER: postgres</span><br><span class="line">      POSTGRES_PASSWORD: <span class="string">''</span></span><br></pre></td></tr></table></figure><p>这与我在 Docker 中通过在容器中运行 Postgres 所做的事情是一样的，但是这里是通过 Actions 来管理的。</p><h2 id="Bats-和-REST-API"><a href="#Bats-和-REST-API" class="headerlink" title="Bats 和 REST API"></a>Bats 和 REST API</h2><p>更进一步，测试管道一直存在于集成测试里。在这我希望能够验证 Flipt 能完成 <code>public API</code> 的方面所需要做的事情。我希望 Flipt 的 REST API 以及它的 CLI 都是公开的，因此应该对它们进行彻底的测试并防止版本回退。</p><p>幸运的是使用诸如 <a href="https://github.com/sstephenson/bats/" target="_blank" rel="noopener">bats</a> 之类的工具，CLI 的测试变得相当容易。我有一些现有的正在使用的 bats 测试 <a href="https://github.com/markphelps/flipt/blob/4157e9b154a01b09a4eb60a8e43484cd3928fc89/script/test/cli.bats" target="_blank" rel="noopener">脚本代码</a> 运行在 Travis 构建中，所以我只需要找到一种方法让他们运行在 Actions 上即可。</p><p>同样，看起来 Actions 的虚拟机并没有安装 bats，但是 GitHub Actions 的 fork 版本似乎已经意识到到了这一点，可以构建了一个你可以在工作流程中引用的 <a href="https://github.com/actions/bin/tree/master/bats" target="_blank" rel="noopener">bats action</a>。我就是这么做的:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- name: Test CLI</span><br><span class="line">  uses: actions/bin/bats@master</span><br><span class="line">  with:</span><br><span class="line">    args: ./script/<span class="built_in">test</span>/*.bats</span><br></pre></td></tr></table></figure><p>在 Linux VM 中的构建二进制文件之前，我还有一个步骤，由这个 bats action 来调用它来测试 CLI 输入/输出。</p><p>集成测试的最后一部分是测试 REST API。我之前发现了一个很酷的叫 <a href="https://github.com/robwhitby/shakedown" target="_blank" rel="noopener">shakedown</a> 的 bash 库，它让 HTTP 测试变得轻而易举。</p><p>因为 VM 虚拟机似乎已经安装了所需的依赖，我最初尝试在原来的 VM 上运行这些测试，但是我在彻底地完成运行测试时遇到了一些问题，所以我决定迁移到一个“干净的环境” - 只在容器中运行测试。</p><p>在对不同的基础 Docker 镜像进行了一些的修改并安装了必要的依赖项之后，我最终通过安装正确的工具构建了自己的 action，从而使 shakedown 测试能够正常工作。</p><h2 id="愉快的发版"><a href="#愉快的发版" class="headerlink" title="愉快的发版"></a>愉快的发版</h2><p>最后，管道的最后一部分是建立发版:</p><p>. 为 *nix 创建 tarball 文件<br>. 创建一个 Docker 镜像<br>. 推送 tarball 文件到 GitHub 并且发布新的版本<br>. 创建 Tag 版本推送 Docker 镜像到 Docker Hub<br>幸运的是 <a href="https://goreleaser.com/" target="_blank" rel="noopener">goreleaser</a> 已经为此做了 100% 工作! 我所需要做的就是在管道中的最后一步为它提供所需的环境变量，并使用正确的参数调用它。<br>我已经在本地<a href="https://github.com/markphelps/flipt/blob/c82b47b7522caf80bc3f5219ea62e9e37c416dd2/script/build/release" target="_blank" rel="noopener">使用脚本</a>运行，这意味着在调用脚本之前，我必须在本地机器上设置 <code>GITHUB_TOKEN</code>、<code>DOCKER_USERNAME</code> 和 <code>DOCKER_PASSWORD</code>。<br>为了将这个过程转移到 GitHub Actions 操作，我需要一种安全的方法来存储这些值并将它们注入到工作流中。幸运的是 GitHub 也为我们提供了对<a href="https://help.github.com/en/articles/virtual-environments-for-github-actions#creating-and-using-secrets-encrypted-variables" target="_blank" rel="noopener">保密</a>的支持:<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- name: Release</span><br><span class="line">  run: ./script/build/release</span><br><span class="line">  env:</span><br><span class="line">    GITHUB_TOKEN: <span class="variable">$&#123;&#123; secrets.GITHUB_TOKEN &#125;</span>&#125;</span><br><span class="line">    DOCKER_USERNAME: <span class="variable">$&#123;&#123; secrets.DOCKER_USERNAME &#125;</span>&#125;</span><br><span class="line">    DOCKER_PASSWORD: <span class="variable">$&#123;&#123; secrets.DOCKER_PASSWORD &#125;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码展示了如何引用 <code>secrets</code> 并将它们设置为脚本运行时使用的环境变量。这使我可以通过 Actions 运行 goreleaser，而不必担心这些保密文件被暴露在日志或仓库本身中。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果你决定迁移你的 pipelines 管道，这里有一些 ProTips™，可以帮助你:</p><ol><li><strong>从简单的开始</strong>。不要试图一下就替换掉整个 CI/CD 方案。看看是否有一些可以先迁移的非关键任务。</li><li><strong>保证现有 CI 系统正常运行</strong>。这个不用说，不要删除你的 <code>travis.yml</code> 文件，直到你确信新的 Actions 设置一切运行正常。</li><li><strong>优先寻找现有的解决方案</strong>。Actions 社区中已经有很多很酷的东西，包括 <a href="https://github.com/actions" target="_blank" rel="noopener">github/ Actions</a> 项目。在尝试创建自己的特定任务之前先查看一下，你会发现有可能已经存在了。</li><li><strong>阅读文档</strong>。认真地说文档有丰富的信息，可能会帮助你弄清楚如何去做你想做的事情，它能解决问题并且省下很多时间。</li></ol><p>正如你可能猜到的那样，使用 Actions 设置完美的 CI/CD 管道流需要一些工作，这主要需要阅读文档。每当我遇到困难的时候，最终都是因为我不理解这个系统是如何工作的。我欣赏 GitHub Actions 提供的扩展性和强大功能，因为你可以正确地用它做任何事情。这伴随着需要学习稍微不同的语法和一些规范，但我认为好处远远大于缺点。</p><p>我引用的所有工作流文件都可以在<a href="https://github.com/markphelps/flipt/tree/master/.github/workflows" target="_blank" rel="noopener">这里</a>找到。</p><p>via: <a href="https://www.markphelps.me/2019/09/migrating-from-travis-to-github-actions/" target="_blank" rel="noopener">https://www.markphelps.me/2019/09/migrating-from-travis-to-github-actions/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;声明一下！非原创，这是一篇翻译文章，发布于 GTCC 社区，一篇讲 CI 从 Travis 迁移到 GitHub-Actions 的英语文章， 我将它翻译成了中文，顺便学习了一下 GitHub Actions，如果你想了解作者和原文 🔽：&lt;/p&gt;
&lt;p&gt;文章作者：&lt;a h
      
    
    </summary>
    
    
      <category term="GitHub Actions" scheme="https://wuxinhua.com/tags/GitHub-Actions/"/>
    
  </entry>
  
  <entry>
    <title>适配 iOS 13</title>
    <link href="https://wuxinhua.com/2019/11/02/Whats-new-in-iOS-13-and-adapting-app-to-new-version/"/>
    <id>https://wuxinhua.com/2019/11/02/Whats-new-in-iOS-13-and-adapting-app-to-new-version/</id>
    <published>2019-11-02T15:56:46.000Z</published>
    <updated>2020-12-31T12:01:49.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前 iOS 可下载的最新正式版是 13.3，早在今年 6 月份苹果向公众推出 iOS 13 的开发者预览版，在 9 月份发布 iOS 13.0 版本后，苹果又接连推出了 13.1 / 13.1.1 / 13.1.2，iOS 13.2 还因为频繁杀后台被用户吐槽新版本 Bug 太多。目前市场上主流的 iPhone 机型(包括iPhone 6s、6s Plus、7、7Plus、8、8Plus、SE、X 、XS 、XS Max、XR、iPod touch 7代等）都兼容升级 iOS13 版本，但值得注意的是已不再支持 A7 或 A8 处理器的机型，仅限于 A9 处理器。</p><p>Apple 在 10 月份推送了 iOS13 公开版后，iOS 用户进行更新版本，如果应用没有做适配会导致 Crash 、兼容适配等问题，这里记录一下当时适配过程遇到的一些问题以及体验移动开发的一些收获，由于对 iOS 开发、Swift 等并不是很熟悉，如内容有误，请及时斧正。 </p><h2 id="功能更新"><a href="#功能更新" class="headerlink" title="功能更新"></a>功能更新</h2><p>在适配前应该先了解一下具体都做了哪些更新，先来看下这次的 iOS 13 带来的功能上的更新，有一些功能我也是比较期待的，这里归纳总结一下：</p><ul><li><p>视觉上的提升 - Dark mode</p><ul><li>毫无疑问 iOS 13 最受关注的功能点就是这个“能让你更方便熬夜”的暗黑模式，用户可以在 设置 - 显示与亮度 中更改深色模式设置，也可以在“选项”中根据日出与日落时间或者自定义时间段设置，目前 iOS 13 提供了根据日落时间和自定义时间段两种切换方式，这个版本系统还提供有针对黑夜模式的新壁纸。</li></ul></li><li><p>控制中心优化及增强可操作性</p><ul><li>允许从控制中心直接操作 WiFi 蓝牙，长按 WiFi 、蓝牙等选项会弹出当前可用的网络、蓝牙设备列表；</li><li>蜂窝煤提供低数据连接模式；</li><li>更新音量调节 UI，禁音操作后，会在顶部弹出一个静音模式的通知；操作侧边栏音量键后，会在按键侧出现显示音量大小的条形图，还可以用手指触摸条滑动来调整声音；</li></ul></li><li><p>增强 Safari</p><ul><li>在 Safari 中截屏的的时候多了一个屏幕选项，可以实现长截图了，甚至可以调整、编辑图片;</li><li>允许直接将网页保存为PDF;</li><li>增加下载管理器，可以在 设置 - Safari 浏览器 -下载项更改下载文件的默认存放位置；</li><li>Safari 会在你设置了安全性较弱的密码时弹出警告</li></ul></li><li><p>性能上的提升</p><ul><li>据 PPT 介绍 Face ID 解锁速度提升 30%，App Store 的应用程序提供新的压缩模式，使得 App 下载的体积减少 50% 左右，这意味着更快的应用更新速度，App 开启速度提升2倍。(具体数据这里没有实际测试);</li></ul></li><li><p>照片和相机改进</p><ul><li>新的浏览视图，编辑功能更好用了，iOS 13 增强了照片编辑功能，包括自动修图功能，提供更多编辑参数等;</li><li>相机功能优化，新的光效模式，更真实的人像效果，包括照片根据 AI 自动归类，照片标签会自动按照天、月以及年的时间进行分类;</li></ul></li><li><p>Sign In With Apple</p><ul><li>目前国内很多 app 都有做第三方登陆，例如微信、微博、github 登陆等，苹果也来抢饭碗，推出了自己的第三方登陆功能：Sign In With Apple，可以通过已有的 Apple ID 来快速登录其它 app 和网站，App 和网站只能索取你的姓名和电邮地址，在 WWDC大会 演示中看到苹果甚至还可以隐藏真实的邮箱地址，让第三方产品难以追踪该账号的数据。</li></ul></li><li><p>地图、Memoji、键盘优化等</p></li></ul><p>这里没有全面列举这次功能上的更新，具体可网上查看 iOS13 的更新列表。 </p><h2 id="API-层变动"><a href="#API-层变动" class="headerlink" title="API 层变动"></a>API 层变动</h2><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><p>私有 KVC 在 iOS 开发中可以说是一个黑魔法，因为 KVC 可以访问和修改私有变量，经常会用于动态取值和设值。在 iOS 13 中苹果已不再允许这样使用。原项目代码中存在比较多这样使用的代码，例如 UISearchBar 通过 forKey 获取 searchField 然后修改 backgroundColor ，在新版本系统中会直接导致应用崩溃，或者 valueForKey、setValue:forKey 等方法获取修改属性均会报错。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[_textField setValue:[<span class="built_in">UIColor</span> redColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br><span class="line"></span><br><span class="line">[_textField setValue:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>] forKeyPath:<span class="string">@"_placeholderLabel.font"</span>];</span><br></pre></td></tr></table></figure><p>兼容：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UITextField</span> *)set_searchTextField&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class="number">13.0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断xcode版本</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.searchTextField;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> valueForKey:<span class="string">@"searchTextField"</span>];</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> valueForKey:<span class="string">@"searchField"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Modal-Presentation-Style"><a href="#Modal-Presentation-Style" class="headerlink" title="Modal Presentation Style"></a>Modal Presentation Style</h2><p>在 iOS13 中, Apple 将视图控制器的默认显示样式从 iOS12 的全屏显示改为 Modal 模式显示，这种类似于弹窗模块的卡片需要你手动往下滑将其取消，这个改动可能会影响应用的一些交互。</p><blockquote><p>Defaults to UIModalPresentationAutomatic on iOS starting in iOS 13.0, and UIModalPresentationFullScreen on previous versions.By default UIViewController resolves UIModalPresentationAutomatic to UIModalPresentationPageSheet, but other system-provided view controllers may resolve UIModalPresentationAutomatic to other concrete presentation styles.</p></blockquote><p>针对 navigationController 增加兼容全屏的代码, Swift、OC 代码中分别设置 modalPresentationStyle 为fullScreen， 示例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// swift </span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">dismiss</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> navigationController = <span class="type">UINavigationController</span>(rootViewController: <span class="type">XTNoLoginTagGuideViewController</span>())</span><br><span class="line">    </span><br><span class="line">    navigationController.modalPresentationStyle = .fullScreen </span><br><span class="line">    </span><br><span class="line">    <span class="type">XTGlobalTools</span>.getCurrentVC()?.present(navigationController, animated: <span class="literal">true</span>, completion: &#123; </span><br><span class="line">      <span class="keyword">self</span>.removeFromSuperview() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objc</span></span><br><span class="line"><span class="built_in">UINavigationController</span> *navi = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:readXiaoceVC];</span><br><span class="line">[navi setModalPresentationStyle: <span class="built_in">UIModalPresentationFullScreen</span>];</span><br><span class="line">[currentVC presentViewController:navi animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h2 id="Dark-mode"><a href="#Dark-mode" class="headerlink" title="Dark mode"></a>Dark mode</h2><p>暗黑模式的适配稍微复杂一些，这里把兼容分为基本、中等、最高三个级别：</p><ul><li><p>最基本</p><p>不适配 dark mode，即用户切换 darkmode 的时和 lightmode 的时候 app 的样式一致，这样能保证用户正常使用。最基本层级的兼容比较容易，尝试直接在项目的 info.split 中更改 User Interface Style 为 Light, 可直接 Xcode 界面设置或更新 info.split 代码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;UIUserInterfaceStyle&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Light&lt;/string&gt;</span><br></pre></td></tr></table></figure><p>但这样强制使用 Light 模式带来的影响就是用户切换成 Dark mode ，如果 Status Bar 的显示未兼容会影响用户查看设备状态栏信息。iOS13 对Status BarAPI 做了修改，之前 Status Bar 有两种状态：</p><ul><li>default 默认文字黑色</li><li>lightContent 文字白色</li></ul><p>之后增加了文字白色，UIStatusBarStyleDefault 自动选择黑色或白色，如图所示：</p><ul><li>default 自动切换</li><li>lightContent 文字白色</li><li>darkContent 文字黑色</li></ul></li></ul><p><img src="https://assets.wuxinhua.com/blog/assets/ios13/status-bar.png" alt></p><ul><li><p>中等</p><p>中等适配主要是颜色相关，例如针对 dark mode 修改背景颜色和字体颜色， 需要UI配合针对目前正常的颜色值给出 dark mode 的颜色值，然后整体来修改替换。</p></li><li><p>最高</p><p>最高级别的适配除了颜色外，App 中所有涉及到需要兼容的 icon 或图片、webView 样式都需要进行适配，例如 icon 、图片需要准备两套。同样这部分也需要产品、UI 来配合。</p></li></ul><p>简单总结一下：</p><ul><li>两种模式的适配主要涉及颜色和图片两个方面的适配</li><li>从 iOS13 开始 UIColor 是一个动态的颜色，可自定义动态 UIColor，针对两种模式给对应的颜色</li><li>图片的适配在不同模式的情况下, 需要对 Assets.xcassets 中的图片选择 Appearances 为 light 和 dark 时准备两套不同的图片</li><li>更新 StatusBar 样式</li><li>更新 UIActivityIndicatorView 样式（已废弃了一些样式，iOS13 之后可以通过 color 属性设置你需要的样式）</li><li>有时我们还需要监听系统模式的变化，针对不同模式作出响应</li></ul><p>具体可以运行 WWDC 现场演示例子<a href="https://docs-assets.developer.apple.com/published/7ad8bd39bb/AdoptingIOSDarkMode.zip" target="_blank" rel="noopener">代码</a>。</p><h2 id="子线程修改界面导致崩溃"><a href="#子线程修改界面导致崩溃" class="headerlink" title="子线程修改界面导致崩溃"></a>子线程修改界面导致崩溃</h2><p>GCD（Grand Central Dispatch） 是苹果公司为多核的并行运算提出的解决方案, 允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行，主要分为 Main queue 、Global queue 和 Custom queue三种，分别对应串行的主线程、并行的全局队列，自定义队列，Custom Queues 默认是串行，当然也可以设置 attributes 为 concurrent，这样它变成了并行 queue。Main queue 运行在系统主线程的一个串行队列,我们所有的UI刷新都发生在 Main queue.如果我们在主线程外的地方做UI操作则会报错，需要将 UI 刷新操作放置 mainQueue 里，如下例子所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123; </span><br><span class="line">  <span class="comment">// view 更新操作</span></span><br><span class="line">  <span class="keyword">self</span>.view.reload()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h2><p>当你需要在应用里展示一些 HTML 页面的时候，就需要用到 webview, iOS中有 UIWebview 和 WKWebview 两种 Webview ，在 WWDC 2018 的演讲介绍中，官方已经宣布正式弃用 UIWebView，并建议之后采用 WKWebview API 构建。</p><blockquote><p>WKWebView has been around since 2014, so it’s not technically new. However, it’s worth mentioning again because we are now officially deprecating UIWebView. So, if you’re starting a new app, or a new project, and would like to display web content that’s not easily put into a native view, use the WKWebView.</p></blockquote><p>区别：</p><ul><li>UIWebView 使用 UIKit 框架，而 WKWebView 使用 WebKit.</li><li>WKWebView 运行在应用单独的一个线程上，并且它可以利用 Safari JavaScript 引擎进行优化，这意味着 WKWebView 加载页面更快更加高效，减少内存开销</li><li>WKWebView 加载本地文件在 iOS 9 中得到修复</li><li>WKWebView 中无法像在 UIWebView 中那样对页面进行缩放适应</li><li>WKWebView 增强了对 indexedDB 的支持</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// UIWebView</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIWebViewController</span>: <span class="title">UIViewController</span></span>&#123;</span><br><span class="line">   <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> webView: <span class="type">UIWebView</span>!</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">            <span class="keyword">let</span> url = <span class="type">URL</span> (string: <span class="string">"https://www.example.com"</span>)</span><br><span class="line">            <span class="keyword">let</span> requestObj = <span class="type">URLRequest</span>(url: url!)</span><br><span class="line">        webView.backgroundColor = <span class="type">UIColor</span>.blue</span><br><span class="line">            webView.loadRequest(requestObj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WKWebView</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WebKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WKWebViewController</span>: <span class="title">UIViewController</span>, <span class="title">WKNavigationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> webView : <span class="type">WKWebView</span>!</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">let</span> myUrl = <span class="string">"https://www.example.com"</span></span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: myUrl)</span><br><span class="line">        <span class="keyword">let</span> request = <span class="type">NSURLRequest</span>(url: url! <span class="keyword">as</span> <span class="type">URL</span>)</span><br><span class="line">        webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.view.frame)</span><br><span class="line">        webView.navigationDelegate = <span class="keyword">self</span></span><br><span class="line">        webView.load(request <span class="keyword">as</span> <span class="type">URLRequest</span>)</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(webView)</span><br><span class="line">        <span class="keyword">self</span>.view.sendSubview(toBack: webView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sign-In-With-Apple"><a href="#Sign-In-With-Apple" class="headerlink" title="Sign In With Apple"></a>Sign In With Apple</h2><p>使用苹果登陆是苹果推出的新功能，方便用户使用他们的苹果ID登录到你的应用程序或网站。无需填写登陆注册表单、验证电子邮件地址、选择新的密码等，可以使用“Sign In With Apple”建立一个帐户并快速开始使用该应用。苹果的在 WWDC2019 介绍PPT中提到：</p><ul><li>精简的账户注册（Name + Email addresses）</li><li>使用已验证邮箱地址（依赖 AppleID 做双重验证）</li><li>反作弊</li><li>安全地（APP只能访问名称和邮件，苹果不记录信息、可以隐藏邮箱地址）</li><li>跨平台（iOS macOS watchOS tvOS JavaScript）</li></ul><p>Apple 介绍的一些使用场景：</p><ul><li>用户在你的应用帐户系统功能有限的情况下创建一个帐户进行体验</li><li>用户在体验产品应用的功能后创建一个账户，例如保存进度、设置个人资料信息等</li><li>用户以访客身份完成购买后创建用户</li></ul><p><strong>移动端：</strong></p><p>接入分为以下四步，提供 “Sign In With Apple” 按钮 =&gt; 授权 =&gt; 认证 =&gt; 处理回调:</p><ol><li>在应用的登陆页面添加 “Sign In With Apple” 登陆按钮:</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add “Sign In with Apple” button to your login view</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setupProviderLoginView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> authorizationButton = <span class="type">ASAuthorizationAppleIDButton</span>()</span><br><span class="line">        authorizationButton.addTarget(<span class="keyword">self</span>, action: #selector(handleAuthorizationAppleIDButtonPress), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">        <span class="keyword">self</span>.loginProviderStackView.addArrangedSubview(authorizationButton)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>绑定按钮点击事件，给苹果发送授权请求:</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configure request, setup delegates and perform authorization request    </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleAuthorizationAppleIDButtonPress</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> appleIDProvider = <span class="type">ASAuthorizationAppleIDProvider</span>()</span><br><span class="line">        <span class="keyword">let</span> request = appleIDProvider.createRequest()</span><br><span class="line">        request.requestedScopes = [.fullName, .email]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> authorizationController = <span class="type">ASAuthorizationController</span>(authorizationRequests: [request])</span><br><span class="line">        authorizationController.delegate = <span class="keyword">self</span></span><br><span class="line">        authorizationController.presentationContextProvider = <span class="keyword">self</span></span><br><span class="line">        authorizationController.performRequests()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>针对苹果授权请求响应进行处理，成功即可在系统创建对应账号、保存账号到 keychain 等操作。</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LoginViewController</span>: <span class="title">ASAuthorizationControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 授权成功处理，拿到授权反馈后可以直接创建账号了</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">authorizationController</span><span class="params">(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> appleIDCredential = authorization.credential <span class="keyword">as</span>? <span class="type">ASAuthorizationAppleIDCredential</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> userIdentifier = appleIDCredential.user</span><br><span class="line">            <span class="keyword">let</span> fullName = appleIDCredential.fullName</span><br><span class="line">            <span class="keyword">let</span> email = appleIDCredential.email</span><br><span class="line">            <span class="comment">// Create an account in your system.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 授权失败处理</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">authorizationController</span><span class="params">(<span class="number">_</span>: ASAuthorizationController, </span></span></span><br><span class="line"><span class="function"><span class="params">                didCompleteWithError error: Error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>网页端</strong>：</p><p>苹果针对网页版应用提供了对应的JS SDK, 也能接入 “Sign In With Apple”，配置过程类似，示例如下：</p><ol><li>HTML 头部页面接入 Apple 的 JS:</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>可以使用 meta 标签或在 JavaScript 代码中配置授权 API 字段，并提供 Apple 登录按钮，如下例子所示:</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"appleid-signin-client-id"</span> <span class="attr">content</span>=<span class="string">"[CLIENT_ID]"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"appleid-signin-scope"</span> <span class="attr">content</span>=<span class="string">"[SCOPES]"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"appleid-signin-redirect-uri"</span> <span class="attr">content</span>=<span class="string">"[REDIRECT_URI]"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"appleid-signin-state"</span> <span class="attr">content</span>=<span class="string">"[STATE]"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 也可以在JavaScript代码中配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">         AppleID.auth.init(&#123;</span></span><br><span class="line"><span class="javascript">             clientId : <span class="string">'[CLIENT_ID]'</span>,</span></span><br><span class="line"><span class="javascript">             scope : <span class="string">'[SCOPES]'</span>,</span></span><br><span class="line"><span class="javascript">             redirectURI: <span class="string">'[REDIRECT_URI]'</span>,</span></span><br><span class="line"><span class="javascript">             state : <span class="string">'[STATE]'</span></span></span><br><span class="line"><span class="undefined">         &#125;);</span></span><br><span class="line"><span class="undefined">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>处理认证信息回调，Apple 处理授权请求后会将一个包含授权结果的HTTP POST请求发送到redirectURI 中提供的 URL 中。具体配置可以查看官方文档，参考使用官方提供的 demo。</li></ol><h2 id="LaunchImage-弃用"><a href="#LaunchImage-弃用" class="headerlink" title="LaunchImage 弃用"></a>LaunchImage 弃用</h2><p>启动页的图片设置方式有两种：</p><ul><li>通过 LaunchScreen.storyboard 设置</li><li>通过 Assets.xcassets 增加 iOS Launch Image 设置启动页图片，苹果设备的尺寸增多，意味着我们需要在对应的 assets 里放入对应尺寸的启动图。</li></ul><blockquote><p>‘UILaunchImages’ has been deprecated, use launch storyboards instead.</p></blockquote><p>当 Xcode 升级到11后，如果继续使用则会提示上面提示，建议在 storyboards 设置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次适配过程中的一些个人体会：</p><ol><li><p>苹果已经更新了 iOS13 的适配时间节点，从 2020 年 4 月份起，所有提交到 App Store 的应用都需要使用 iOS 13 SDK 或更高的版本来构建，并且还需要兼容 iPhone XS Max 、iPad Pro 等设备，如果提供了第三方登陆功能的应用还得兼容使用  “Sign In With Apple”  登陆，兼容暗黑模式，提供一个暗黑模式下的应用截图，所以建议尽早完成应用 iOS13 的适配。</p></li><li><p>由于目前并没有完成所有的适配工作，截止到目前开发过程遇到的一些报错基本都是 API 层改动造成的，阅读文档提示加上网上查找答案修改代码即可，只是稍微有一点点 swift 基础，但对 iOS 开发的认识其实远远不够，之后还需要多看多练习代码。</p></li><li><p>iOS 开发测试发版周期都较长，不像 web 端能快速更新部署上线，例如前期准准备 iOS 开发机器、熟悉Xcode 开发工具、iOS 测试设备、开发者账号、配置证书等需要做比较多的准备工作，后期的  App Store 发版还有可能被拒，所以对代码质量、发版前的测试质量要求都比较高。</p></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://developer.apple.com/documentation" target="_blank" rel="noopener">苹果开发文档</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019" target="_blank" rel="noopener">WWDC 2019</a></li><li><a href="https://developer.apple.com/documentation/xcode_release_notes/xcode_11_beta_release_notes" target="_blank" rel="noopener">Xcode 11 Release Notes</a></li><li><a href="https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/" target="_blank" rel="noopener">Dark Mode 介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前 iOS 可下载的最新正式版是 13.3，早在今年 6 月份苹果向公众推出 iOS 13 的开发者预览版，在 9 月份发布 iOS 13
      
    
    </summary>
    
    
      <category term="iOS 13 适配" scheme="https://wuxinhua.com/tags/iOS-13-%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>React Native 新手常见问题及体验总结</title>
    <link href="https://wuxinhua.com/2019/07/31/The-common-issues-and-errors-I-have-faced-as-a-react-native-beginner/"/>
    <id>https://wuxinhua.com/2019/07/31/The-common-issues-and-errors-I-have-faced-as-a-react-native-beginner/</id>
    <published>2019-07-31T09:46:47.000Z</published>
    <updated>2020-12-31T12:01:49.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com/blog/assets/react-native/react-native-article-banner.png" alt>  </p><p>之前有使用 React Native 的开发经历，记录下了开发过程的常见的错误和解决方案，也算是从头趟了一遍 RN 开发过程的坑，本篇主要包括日常踩得一些坑以及我使用 React Native 开发体验总结。</p><h3 id="State-update-on-an-unmounted-component"><a href="#State-update-on-an-unmounted-component" class="headerlink" title="#State update on an unmounted component"></a>#State update on an unmounted component</h3><blockquote><p>Can’t perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</p></blockquote><p>这是一个常见的错误，当我们初始化首页 screen 屏幕时会使用 fetch 做一些异步请求，请求成功后在回调方法里使用 setState 更新组件数据，但如果在请求 pending 状态下跳转到其它屏，组件已经销毁，这时再去 setState 会报 <code>Warning</code> ⚠️，这个问题的解决思路有两个：</p><ol><li>组件销毁时取消发出的 fetch 请求。</li><li>增加组件是否销毁判断字段，在 componentWillUnmount 方法里设置组件已销毁。</li></ol><p>如何中断一个 fetch 请求？可以尝试使用 AbortController API， <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchController" target="_blank" rel="noopener">AbortController</a> 接口是一个控制器对象，在 fetch 请求中增加 <code>signal</code> 参数，允许你在需要时中止一个或多个请求，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  abortController = <span class="keyword">new</span> AbortController();</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      data: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">    fetch(<span class="string">'https://my.api.com/api?query=reactnative'</span>, &#123; <span class="attr">signal</span>: <span class="keyword">this</span>.abortController.signal &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          data: result.data,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.abortController.abort()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用另一个更简单的方法，在调用 setState 方法更新数据前使用 <code>_isMounted</code> 字段来判断组件是否已经被销毁：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  _isMounted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      data: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    fetch(<span class="string">'https://my.api.com/api?query=reactnative'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._isMounted) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            data: result.data,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>._isMounted = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-60-版本添加-react-navigation"><a href="#0-60-版本添加-react-navigation" class="headerlink" title="#0.60 版本添加 react navigation"></a>#0.60 版本添加 react navigation</h3><p>React Native 升级到 0.60 后，支持 AndroidX 和 Autolinked 自动连接 package 包算是两个比较大的更新，具体可以查看更新 <a href="https://facebook.github.io/react-native/blog/2019/07/03/version-60" target="_blank" rel="noopener">blog</a>：</p><blockquote><p>AndroidX is a major step forward in the Android ecosystem, and the old support library artifacts are being deprecated. For 0.60, React Native has been migrated over to AndroidX. This is a breaking change, and your native code and dependencies will need to be migrated as well.</p></blockquote><p>但是坑出在有些文档没有及时更新，包括第三方库没有及时更新，导致我在使用 react navigation 、react-native-gesture-handler 第三方库时遇到的一连串的bug。包括 react-native-gesture-handler 使用了android support 的一些库，没有及时更新到 <a href="https://developer.android.com/jetpack/androidx?hl=zh-cn" target="_blank" rel="noopener">AndroidX</a>，因为 AndroidX 是谷歌支持库的替代品，目前 Android P 处于过渡阶段，下一个版本的 Android 可能只支持AndroidX。</p><blockquote><p>xxxx/node_modules/react-native-gesture-handler/android/src/main/java/com/swmansion/gesturehandler/react/RNGestureHandlerEvent.java:3: error: package android.support.v4.util doesn’t exist import android.support.v4.util.Pools; ^ xxxx/android/src/main/java/com/swmansion/gesturehandler/react/RNGestureHandlerEvent.java:19: error: package Pools doesn’t exist private static final Pools.SynchronizedPool<rngesturehandlerevent> EVENTS_POOL = ^ error: package android.support.v4.util doesn’t exist  import android.support.v4.util.Pools;</rngesturehandlerevent></p></blockquote><p>解决方法：</p><p>无法自动 link 的包可以手动链接依赖，例如在 iOS 平台手动 link <code>react-native-gesture-handler</code>、<code>react-native-svg</code>等包，建议先执行<code>unlink</code>命令，添加 <code>react-native.config.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  dependencies: &#123;</span><br><span class="line">    <span class="string">'react-native-gesture-handler'</span>: &#123;</span><br><span class="line">      platforms: &#123;</span><br><span class="line">        ios: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'react-native-svg'</span></span><br><span class="line">      platforms: &#123;</span><br><span class="line">        ios: <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 jetify 处理 AndroidX 导致的问题：</p><p>在<code>package.json</code>里添加 <a href="https://github.com/mikehardy/jetifier" target="_blank" rel="noopener">jetify</a>相关配置：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"postinstall": "npx jetify"</span><br></pre></td></tr></table></figure><p>使用 react navigation 开发路由导航过程中遇到的几个 bug 可以查看提的这几个 issues: </p><p><img src="https://i.loli.net/2019/07/10/5d25996d4655e23135.png" alt></p><ol><li><a href="https://github.com/react-navigation/react-navigation/issues/6066" target="_blank" rel="noopener">react-navigation/issues/6066</a></li><li><a href="https://github.com/kmagiera/react-native-gesture-handler/issues/649" target="_blank" rel="noopener">react-native-gesture-handler/issues/649</a></li><li><a href="https://github.com/kmagiera/react-native-gesture-handler/issues/494" target="_blank" rel="noopener">react-native-gesture-handler/issues/494</a></li></ol><h3 id="Flex-in-React-Native"><a href="#Flex-in-React-Native" class="headerlink" title="#Flex in React Native"></a>#Flex in React Native</h3><p>React Native 中同样也可以使用 flexbox 布局，和 web 上基本一致，如果不了解 flex 布局的可以查看之前总结的这篇 <a href="https://wuxinhua.com/2019/02/25/The-Guide-To-Flexbox/">Flexbox布局完全指南</a>，但也一些需要注意的地方：</p><ol><li>flex 的排列方向默认是竖直排列： flexDirection：column。</li><li>flex 只能指定一个数字值，它有三种状态：正数、零与负数。</li><li>alignItems 在 React Native 中默认是：alignItems: stretch。</li><li>部分属性在RN中不支持：align-content，flex-basis，order，flex-basis，flex-flow，flex-grow，flex-shrink。</li></ol><p>具体用法这里不再介绍，官方文档上有很详细的描述。 <a href="https://facebook.github.io/react-native/docs/flexbox" target="_blank" rel="noopener">Layout with Flexbox</a></p><h3 id="DeviceException-未连接设备"><a href="#DeviceException-未连接设备" class="headerlink" title="#DeviceException 未连接设备"></a>#DeviceException 未连接设备</h3><blockquote><p>error Failed to install the app. Make sure you have an Android emulator running or a device connected. Run CLI with –verbose flag for more details.<br>Error: Command failed: ./gradlew app:installDebug -PreactNativeDevServerPort=8081<br>FAILURE: Build failed with an exception.<br>What went wrong:<br>Execution failed for task ‘:app:installDebug’.<br>com.android.builder.testing.api.DeviceException: No connected devices!</p></blockquote><p>这个报错是安卓的 Virtual Devices 没有开启，可以使用 adb devices 命令查看当前设备，确保运行 react-native run-android 命令时开启调试设备，安卓平台可以在 Android Studio - Tools - AVD Manager 中打开。</p><p><img src="https://assets.wuxinhua.com/blog/assets/react-native/virtual-devices.jpg" alt></p><h3 id="YellowBox-ignore-Warnings"><a href="#YellowBox-ignore-Warnings" class="headerlink" title="#YellowBox ignore Warnings"></a>#YellowBox ignore Warnings</h3><p>使用 YellowBox 忽视一些警告 ⚠️，但不推荐这样做，毕竟一些警告还是比较有用的信息，例如 react native 提示componentWillMount 将会弃用，使用 componentDidMount 代替：</p><blockquote><p>Warning: componentWillMount is deprecated and will be removed in the next major version. Use componentDidMount instead. As a temporary workaround, you can rename to UNSAFE_componentWillMount.<br>Please update the following components: EventScreen<br>Learn more about this warning here:<br><a href="https://fb.me/react-async-component-lifecycle-hooks" target="_blank" rel="noopener">https://fb.me/react-async-component-lifecycle-hooks</a></p></blockquote><p>在开发环境可以使用 YellowBox 忽略这些警告：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; YellowBox &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line">YellowBox.ignoreWarnings([<span class="string">'Warning: ...'</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>RedBoxes and YellowBoxes are automatically disabled in release (production) builds.</p></blockquote><p>不过在发布或线上打包的版本中，YellowBoxes 的提示会被自动禁掉。</p><h3 id="引用第三方库-build-失败"><a href="#引用第三方库-build-失败" class="headerlink" title="#引用第三方库 build 失败"></a>#引用第三方库 build 失败</h3><p>例如使用 <a href="https://github.com/yorkie/react-native-wechat" target="_blank" rel="noopener">react-native-wechat</a> 集成微信的好友、朋友圈分享功能时，Android 环境 dev 本地开发环境一切正常运行，使用命令进行 apk 打包时提示 gradle build 失败：</p><blockquote><p>error: failed linking references.<br>FAILURE: Build failed with an exception.<br>What went wrong:<br>Execution failed for task ‘:RCTWeChat:verifyReleaseResources’.<br>com.android.ide.common.process.ProcessException: Failed to execute aapt<br>Try:<br>Run with –stacktrace option to get the stack trace. Run with –info or –debug option to get more log output. Run with –scan to get full insights.<br>Get more help at <a href="https://help.gradle.org" target="_blank" rel="noopener">https://help.gradle.org</a></p></blockquote><p>这类问题很多情况是第三方包 gradle 版本配置与主体项目下的配置不一致导致的，例如项目使用的 <code>28.0.3</code>，而第三方包使用的是更低的版本，建议将引用库 gradle 配置更新成与 RN 项目 android 文件下 build.gradle 文件配置一致，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        buildToolsVersion = <span class="string">"28.0.3"</span></span><br><span class="line">        minSdkVersion = <span class="number">16</span></span><br><span class="line">        compileSdkVersion = <span class="number">28</span></span><br><span class="line">        targetSdkVersion = <span class="number">28</span></span><br><span class="line">        supportLibVersion = <span class="string">"28.0.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line"></span><br><span class="line">        classpath(<span class="string">"com.android.tools.build:gradle:3.4.1"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何进行-React-Native-开发调试"><a href="#如何进行-React-Native-开发调试" class="headerlink" title="#如何进行 React Native 开发调试"></a>#如何进行 React Native 开发调试</h3><p>模拟器开启 Developer Menu:</p><p>iOS 模拟器可以通过 <code>Command⌘ + D</code> 快捷键来快速打开 Developer Menu，Android 模拟器可以通过 <code>Command⌘ + M</code> 快捷键来快速打开 Developer Menu。</p><p><img src="https://assets.wuxinhua.com/blog/assets/react-native/DeveloperMenu.png" alt></p><p>如果想查看组件的层级关系，可以全局安装 react 开发配套工具 react-devtools：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g react-devtools</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> react-devtools</span></span><br></pre></td></tr></table></figure><p>运行后 React Native 应用会自动连接，会出现 connectting 窗口，刷新 App 即可看到当前 screen 的组件层级情况：</p><p><img src="https://assets.wuxinhua.com/blog/assets/react-native/react-devtools-connect.jpg" alt></p><p><img src="https://assets.wuxinhua.com/blog/assets/react-native/react-dev-tools.jpg" alt></p><p>如果想看控制台输出 log 日志，可以输入以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> react-native <span class="built_in">log</span>-ios</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> react-native <span class="built_in">log</span>-android</span></span><br></pre></td></tr></table></figure><p><img src="https://assets.wuxinhua.com/blog/assets/react-native/log-android.jpg" alt></p><h3 id="万能的清除缓存和重启"><a href="#万能的清除缓存和重启" class="headerlink" title="#万能的清除缓存和重启"></a>#万能的清除缓存和重启</h3><p>经常碰到一些莫名其妙的错误，发现以下命令删除本地包，重装依赖重启总是很管用：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">watchman watch-del-all // 清除 Watchman：</span><br><span class="line">rm -rf node_modules &amp;&amp; yarn install // 删除 node_modules并重装</span><br><span class="line">react-native start --reset-cache // 清除 rn 缓存重启</span><br><span class="line">react-native run-ios 或 react-native run-android</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>先后有 Airbnb 和 Udacity 表示将弃坑 React Native，回归到原生开发上。具体可查看公司技术博客：  </p><blockquote><p>As a result, moving forward, we are sunsetting React Native at Airbnb and reinvesting all of our efforts back into native. - Airbnb</p></blockquote><p><a href="https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a" target="_blank" rel="noopener">1. Sunsetting React Native</a><br><a href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener">2. React Native: A retrospective from the mobile-engineering team at Udacity</a></p><p>我简要谈谈自己的体验和看法：</p><h4 id="“文档应当鲜活并保持更新”"><a href="#“文档应当鲜活并保持更新”" class="headerlink" title="“文档应当鲜活并保持更新”"></a>“文档应当鲜活并保持更新”</h4><p>当然这句话不是我说的，是 Eric Evans 在《领域驱动设计》这本书中的一句话，我引用它是想表达：如果代码能实现或体现最好，文档应该是起辅助作用的，而不是累赘；文档没及时跟上代码的更新将会给开发者带来很多麻烦。React Native 的文档已经被很多人吐槽过，RN 社区曾经有个 issue =&gt; <a href="https://github.com/react-native-community/discussions-and-proposals/issues/64" target="_blank" rel="noopener">What do you dislike about React Native?</a> 用来收集开发者在使用RN时的痛点，排在前三的就是：<strong>升级</strong>、<strong>调试</strong>加<strong>崩溃</strong>。一旦需要从 RN 的旧版本升级到一个新的大版本时就变得异常困难。</p><h4 id="第三方组件、库的支持"><a href="#第三方组件、库的支持" class="headerlink" title="第三方组件、库的支持"></a>第三方组件、库的支持</h4><p>虽然目前 React Native 社区已经发展得足够大，社区的开发者发布了很多组件、库等方便大家开发时引用，实现各种复杂的需求，提供对业务的支持。但问题出在很多库没有及时跟上RN的大版本发布及相关改动，或者说有些库的已经不再更新维护，在没有时间自己开发或寻找替代品的时候，这也是很棘手的一个问题。</p><h3 id="开发速度快但有一定的上手难度"><a href="#开发速度快但有一定的上手难度" class="headerlink" title="开发速度快但有一定的上手难度"></a>开发速度快但有一定的上手难度</h3><p>作为混合的跨平台解决方案，React Native 具有比较高的可行性, 相对于大公司移动端会有比较大的团队来开发维护原生 App，RN 比较适用于（2/3个开发人员）小团队成员，或者说没有足够的人员分别去开发原生应用的团队，小团队并且直接使用 JavaScript 生态系统的库、工具就能开发应用，一套代码两端适用，开发速度上有大幅度提升，也节约了人力成本的开支。有经验的 JavaScript 和 Web 开发人员能很快得入手，但是对于新手，尤其是对 React 及相关概念不了解的同学，会有一定的上手难度。</p><p>没有使用其它混合方案框架例如 Fluter、Weex 等进行开发混合应用，这里无法进行对比，只是总结最近一段时间使用 React Native 的开发体验，从初始化项目到应用上架整个过程并不是很流畅，真机调试过程经常有应用崩溃的情况发生，代码排查错误或者找问题的过程花费了我比较多的时间，另一方面是使用第三方组件、库等是一个踩坑过程，文档等没有及时更新，在添加配置的过程出现很多问题，可能是我刚好碰上 <strong>60</strong> 这个大版本，总的来说我认为 React Native 应该还是目前比较好并且稳定的混合应用开发方案，但在开发者使用体验上社区和团队需要进一步优化改善。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>参考学习的一些资料：</p><ol><li><a href="https://facebook.github.io/react-native/blog/2019/07/03/version-60" target="_blank" rel="noopener">Announcing React Native 0.60</a>  </li><li><a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c" target="_blank" rel="noopener">React Native at Airbnb</a> </li><li><a href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener">React Native: A retrospective from the mobile-engineering team at Udacity</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com/blog/assets/react-native/react-native-article-banner.png&quot; alt&gt;  &lt;/p&gt;
&lt;p&gt;之前有使用 React Native 的开发经历，记录
      
    
    </summary>
    
    
      <category term="React Native" scheme="https://wuxinhua.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>ES10(ECMAScript2019)特征预览</title>
    <link href="https://wuxinhua.com/2019/04/27/A-Preview-Of-ECMAScript2019-ES10/"/>
    <id>https://wuxinhua.com/2019/04/27/A-Preview-Of-ECMAScript2019-ES10/</id>
    <published>2019-04-27T04:32:49.000Z</published>
    <updated>2020-12-31T12:01:49.405Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com//blog/assets/es10/es2019.png" alt> </p><p> 2019年1月末的时候，ECMA TC39终于确定了ES2019版JavaScript的新增内容，ES2019 将会增加arrays, objects, strings, symbols, try/catch 和 JSON 等方面的特征。</p><p><img src="https://assets.wuxinhua.com//blog/assets/es10/mathias.png" alt></p><h2 id="Array-flat-flatMap"><a href="#Array-flat-flatMap" class="headerlink" title="Array#{flat,flatMap}"></a>Array#{flat,flatMap}</h2><p>Array的原型链上增加了新的两个方法：Array.flat(<a href="https://tc39.github.io/proposal-flatMap/" target="_blank" rel="noopener">tc39 proposal</a>) 和 Array.flat(<a href="https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flat" target="_blank" rel="noopener">tc39 proposal</a>) 能够进行扁平化多维数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]]]; </span><br><span class="line">arr.flat(); <span class="comment">// [1, 2, 3, 4, 5, 6, Array(4)]</span></span><br></pre></td></tr></table></figure><p>等同于<code>arr.flat(1)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.flat(<span class="number">1</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, Array(4)]</span></span><br></pre></td></tr></table></figure><p>逐个展开：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.flat().flat() <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, Array(3)]</span></span><br><span class="line">arr.flat().flat().flat() <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br><span class="line"><span class="comment">// 超出可扁平化范围结果保持不变</span></span><br><span class="line">arr.flat().flat().flat().flat() <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br><span class="line"><span class="comment">// 当然也等同于</span></span><br><span class="line">arr.flat(<span class="number">2</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, Array(3)]</span></span><br><span class="line">arr.flat(<span class="number">3</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br><span class="line">arr.flat(<span class="literal">Infinity</span>); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法类似于数组的<code>map</code>方法，对数组的每一项使用传入的<code>function</code>，结果得到的是扁平化的数组，值得注意的是所有的结果将不会折叠，而是展示为一维数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]]]; </span><br><span class="line">arr.flatMap(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>); <span class="comment">// [2, 4, 6, NaN]</span></span><br><span class="line"><span class="comment">// map vs flatMap</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> [item, item * <span class="number">2</span>]); <span class="comment">//  [Array(2), Array(2), Array(2), Array(2)]</span></span><br><span class="line">arr.flatMap(<span class="function"><span class="params">item</span> =&gt;</span> [item, item * <span class="number">2</span>]); <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>BigInt 是一个新的类型，用于表达大于 2^53 的值</p><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><p>我们已经知道可以使用<code>Object.entries</code>返回对象自身可枚举属性键值对数组，而Object.fromEntries(<a href="https://github.com/tc39/proposal-object-from-entries" target="_blank" rel="noopener">tc39 proposal</a>)则可以看做是这一过程的逆转，用数组返回可枚举对象，loadash里提供了<a href="https://lodash.com/docs/4.17.11#fromPairs" target="_blank" rel="noopener">_.fromPairs(pairs)</a>类似的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">baz</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">//  [Array(2), Array(2)] =&gt;  [['foo', 1], ['baz', 2]]</span></span><br><span class="line"><span class="built_in">Object</span>.fromEntries([[<span class="string">'foo'</span>, <span class="number">1</span>], [<span class="string">'baz'</span>, <span class="number">2</span>]]); <span class="comment">// &#123;foo: 1, baz: 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="String-trimStart-trimEnd"><a href="#String-trimStart-trimEnd" class="headerlink" title="String#{trimStart,trimEnd}"></a>String#{trimStart,trimEnd}</h2><p>这两个方法应该是弥补<code>trim</code>的不足，trim会直接把两头的空白均移除，<code>trimStart()</code>方法用于移除字符串开头的空白，<code>trimEnd()</code>用于移除字符串末尾的空白。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">' ECMAScript 2019  '</span>;</span><br><span class="line">str.trim(); <span class="comment">// "ECMAScript 2019"</span></span><br><span class="line">str.trimStart(); <span class="comment">// "ECMAScript 2019  "</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>Symbol类型增加<code>description</code>属性，返回Symbol对象的可选描述的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'ECMAScript2019'</span>).description; <span class="comment">// ECMAScript2019</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'ECMAScript2019'</span>).description; <span class="comment">// string</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">''</span>).description;  <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">Symbol</span>().description; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="try-catch-optional-binding"><a href="#try-catch-optional-binding" class="headerlink" title="try { } catch {} // optional binding"></a>try { } catch {} // optional binding</h2><p>opitionam binding<a href="https://github.com/tc39/proposal-optional-catch-binding" target="_blank" rel="noopener">tc39 proposal</a> catch参数可选。经常会有这种情况，并没有使用到catch内的参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do something when success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (unused) &#123;</span><br><span class="line">  <span class="comment">// do something when error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后可以这样写：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON-⊂-ECMAScript"><a href="#JSON-⊂-ECMAScript" class="headerlink" title="JSON ⊂ ECMAScript"></a>JSON ⊂ ECMAScript</h2><p>JSON也有两处的优化：行分隔符（U+2028）和段分隔符（U+2029）符号现在允许在字符串文字中，与JSON匹配。 以前，这些符号在字符串文字中被视为行终止符，因此使用它们会导致SyntaxError异常。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'"\u2028"'</span>); <span class="comment">// ""</span></span><br></pre></td></tr></table></figure></p><h2 id="优化JSON-stringify"><a href="#优化JSON-stringify" class="headerlink" title="优化JSON.stringify"></a>优化JSON.stringify</h2><p>改进了<code>JSON.Stringify()</code>方法，防止返回不符合规范Unicode字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uD800'</span>); <span class="comment">// '"�"'</span></span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uD800'</span>); <span class="comment">// '"\\ud800"'</span></span><br></pre></td></tr></table></figure><h1 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString"></a>Function.prototype.toString</h1><p>toString()方法现在能返回源代码字符串，包括空行和注释：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">a</span> <span class="title">comment</span> */ <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.toString() <span class="comment">// "function /* a comment */ foo () &#123;&#125;"</span></span><br></pre></td></tr></table></figure></p><h2 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a>Array.prototype.sort</h2><p>ECMAScript2019版的<code>sort</code>会确保Array.sort方法是稳定的。</p><p>之前总结的 ES6 新特征点这 =&gt; <a href="https://wuxinhua.com/2017/08/28/The-es6-features-learning-notes/">ES6(ECMAScript 6.0)新特征</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com//blog/assets/es10/es2019.png&quot; alt&gt; &lt;/p&gt;
&lt;p&gt; 2019年1月末的时候，ECMA TC39终于确定了ES2019版JavaScript的新增内容，ES2019
      
    
    </summary>
    
    
      <category term="ES2019" scheme="https://wuxinhua.com/tags/ES2019/"/>
    
  </entry>
  
  <entry>
    <title>Flexbox布局完全指南</title>
    <link href="https://wuxinhua.com/2019/02/25/The-Guide-To-Flexbox/"/>
    <id>https://wuxinhua.com/2019/02/25/The-Guide-To-Flexbox/</id>
    <published>2019-02-25T10:47:45.000Z</published>
    <updated>2020-12-31T12:01:49.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex.png" alt></p><h2 id="为什么写这样一篇文章"><a href="#为什么写这样一篇文章" class="headerlink" title="为什么写这样一篇文章"></a>为什么写这样一篇文章</h2><p>欢迎来到 flexbox 的世界。我很乐意接受新的思想、观念，或者尝试新的工具，虽然这个过程并不是很顺利。使用 flexbox 对页面进行布局的时间不是很长，发现它真的很好用，日常使用还不够熟练，还得经常翻阮老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>，于是索性自己总结一篇，一边在实际应用中使用flexbox，一边学习基础理论知识。本篇适用于所有刚接触到 flexbox 布局的同学，也适用于那些想更近一步了解 flexbox 的人，我将尽可能详细地用文字、图片、代码介绍、学习 flexbox 布局。</p><h2 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h2><h3 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h3><p>可以说<code>display</code>是开发者最为熟悉的一个属性，也是最为重要的一个属性，它指定元素的显示行为，准备得来说是规定了外部和内部显示属性的规则，来看 MDN 上对它的定义：  </p><blockquote><p>display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。</p></blockquote><p>例如我们常用的一些：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line"><span class="selector-tag">dispaly</span>: <span class="selector-tag">table</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">grid</span>;</span><br></pre></td></tr></table></figure><p>事实上每一个HTML标签都有一个默认的 <code>display</code> 属性值，例如：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code> 等默认是<code>block</code> 块状元素，而 <code>span</code>、<code>img</code>、<code>svg</code> 等默认 <code>inline</code> 行内元素，二者比较大的区别：</p><p>block元素：</p><ol><li>block 块状元素会占满整行的空间；</li><li>常规布局中块级是基于竖直方向的，即紧接着的另一个块级元素会另起一行排列；</li><li>能被设置 width、height 宽高；</li><li>能作为其它块状元素、行内元素的父标签；</li></ol><p>inline元素：</p><ol><li>inline 行内元素则刚好相反，只占用它们需要的空间;</li><li>内联基于水平方向，行内元素一个紧挨着另一个；</li><li>不能被设置 width、height 宽高；</li><li>只能作为行内元素的父标签；</li></ol><h3 id="BFC与FFC"><a href="#BFC与FFC" class="headerlink" title="BFC与FFC"></a>BFC与FFC</h3><p>flexbox 布局重新定义了格式化上下文，这套规则叫 <code>FFC(Flex Formatting Contexts),Formatting context</code> 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)<br>FFC类似于 BFC(block formatting context)，BFC对于前端开发来说一个必须了解掌握的概念，这里只做简单描述：</p><p>BFC(block formatting context”块级格式化上下文”)</p><ol><li>内部的块盒子会在垂直方向，一个接一个的布局；</li><li>box垂直方向的距离由margin决定，两个相邻的box margin会重叠；</li><li>BFC是一个隔离的独立容器，容器里的子元素不会影响到外面的元素，反之亦然；</li><li>计算BFC的高度时，浮动元素也参与计算；</li></ol><p>FFC(Flex Formatting Contexts”自适应格式化上下文”)</p><p>display 值为 flex 或 inline-flex 的元素会变成一个 flex 容器，内部元素变成子项目。容器是一个相对独立的渲染区域，会按照自适应渲染规则来布局。</p><h2 id="flex基本概念"><a href="#flex基本概念" class="headerlink" title="flex基本概念"></a>flex基本概念</h2><h3 id="什么是flexbox"><a href="#什么是flexbox" class="headerlink" title="什么是flexbox"></a>什么是flexbox</h3><h3 id="flex容器"><a href="#flex容器" class="headerlink" title="flex容器"></a>flex容器</h3><p>flexbox 主要由 flex 容器和 flex 子项目组成，对应的有分别作用于这两者的一些属性；想要使用flex布局，得先指定一个容器，这样容器内的元素就能使用flex来进行布局，容器有两个取值 flex 和 inline-flex, 简单地来说，如果你的容器是一个块级元素，可以使用 <code>flex</code>，而行内元素则可以使用 <code>inline-flex</code>，值得注意的是二者均能将容器实现flex布局，不同的地方在用 <code>flex</code> 将会使容器变为块级元素，而 <code>inline-flex</code> 使容器变成行内元素。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex | inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子项"><a href="#子项" class="headerlink" title="子项"></a>子项</h3><p>有了容器相应的也就有了容器内的<code>item</code>子项，后续会逐个介绍子项的一些属性：order flex-grow flex-shrink flex-basis flex align-self 等。</p><h2 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="# flex-direction"></a># flex-direction</h3><p><code>flex-direction</code> 属性控制Flex项目沿着主轴（Main Axis）、侧轴（Cross-Axis）的排列方向，在flex 世界中存在两个主轴：Main-Axis（主轴） 和 Cross-Axis（侧轴）它有以下选项：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-direction: row(默认) | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure><p><code>row</code> flex容器的主轴与文本方向相同，以行（水平）方向排列:<br><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-direction-row.png" alt><br><code>column</code> 以列（垂直）方向排列:  </p><p><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-direction-column.png" alt><br>而 <code>row-reverse</code>和<code>column-reverse</code> 分别是行列的反向，如下图所示:  </p><p><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-direction-row-reverse.png" alt><br><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-direction-column-reverse.png" alt></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="# flex-wrap"></a># flex-wrap</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">flex-wrap: wrap(默认) | nowrap | wrap-reverse</span><br></pre></td></tr></table></figure><p>决定 flex项目在容器内是否不换行排列，<code>nowrap</code> 默认是项目不进行换行:</p><p><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-wrap-nowrap.png" alt></p><p>当 flex 容器无法在一行内容纳所有的 flex 项目时会进行换行:</p><p><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-wrap-wrap.png" alt></p><p>wrap-reverse 同样是多行排列，只是方向是相反的: </p><p><img src="https://assets.wuxinhua.com//blog/assets/flexbox/flex-wrap-wrap-reverse.png" alt></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="# flex-flow"></a># flex-flow</h3><p><code>flex-flow</code> 是一个 flex-direction 及 Flex-wrap 组合简写。默认值为：row nowrap，例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">wrap</span>;</span><br><span class="line">// 等同于</span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span></span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">wrap</span></span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="# justify-content"></a># justify-content</h3><p><code>justify-content</code> 定义了项目在主轴上的对齐方式。取值分别是：flex-start（左对齐）、 flex-end（右对齐）、center（居中）、 space-between（两端对齐）、space-around（均分间距，间距两侧对齐）、space-evenly（均分间距）均匀排列每个元素，每个元素之间的间隔相等</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure><p>justify-content: flex-start 起始处左对齐<br><img src="https://assets.wuxinhua.com/blog/assets/flexbox/justify-content-flex-start.png" alt>  </p><p>justify-content: center 居中对齐<br><img src="https://assets.wuxinhua.com/blog/assets/flexbox/justify-content-center.png" alt></p><p>justify-content: center 右对齐<br><img src="https://assets.wuxinhua.com/blog/assets/flexbox/justify-content-flex-end.png" alt></p><p>justify-content: space-between 两端对齐<br><img src="https://assets.wuxinhua.com/blog/assets/flexbox/justify-content-space-between.png" alt>  </p><p>justify-content: space-between 间隔相等<br><img src="https://assets.wuxinhua.com/blog/assets/flexbox/justify-content-space-around.png" alt>  </p><h3 id="align-items"><a href="#align-items" class="headerlink" title="# align-items"></a># align-items</h3><p><code>align-items</code> 定义项目在交叉轴方向上的对齐方式</p><p>flex-start：项目元素向侧轴起点对齐、flex-end：元素向侧轴终点对齐。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-items: stretch | flex-start | flex-end | center | baseline;</span><br></pre></td></tr></table></figure><p>flex-start：交叉轴的起点对齐<br>flex-end：交叉轴的终点对齐<br>center：交叉轴的中点对齐<br>baseline: 项目基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</p><p>以上几个都是设置在容器上的一些属性，接下来看下项目上可设置的属性：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">order</span></span><br><span class="line"><span class="selector-tag">flex-grow</span></span><br><span class="line"><span class="selector-tag">flex-shrink</span></span><br><span class="line"><span class="selector-tag">flex-basis</span></span><br><span class="line"><span class="selector-tag">flex</span></span><br><span class="line"><span class="selector-tag">align-self</span></span><br></pre></td></tr></table></figure><h3 id="order"><a href="#order" class="headerlink" title="# order"></a># order</h3><p><code>order</code>定义项目在容器里的排列顺序，默认为 0，数字越小，排得越前</p><p>如何控制容器内的“剩余空间”，这里需要使用到三个很重要的属性：<br>flex-basis、flex-grow、flex-shrink</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="# flex-basis"></a># flex-basis</h3><p>这个属性日常用得比较少，其实就是 width 属性的替代品，并且优先级 flex-basis &gt; width，即在分配空间前会预留出 flex-basis 的空间，它的默认值是 aotu，即项目本来的大小。</p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="# flex-grow"></a># flex-grow</h3><p><code>flex-grow</code> 能够控制项目在容器中所占空间的大小，它接受一个数字值，默认为0。如果其它项目flex-grow 设置为1，其中一个子元素的值是2，在空间允许的条件下它将占用前者两倍的空间。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="# flex-shrink"></a># flex-shrink</h3><p><code>flex-shrink</code> 前面的grow是扩大，对应的shrink是缩小，即如果容器空间不足，项目将缩小宽度来适应容器，该属性定义了项目的缩小比例，默认为 1，为0 表示不减少，值越大缩小得就越厉害，</p><h3 id="flex"><a href="#flex" class="headerlink" title="# flex"></a># flex</h3><p><code>flex</code> 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="# align-self"></a># align-self</h3><p><code>align-self</code> 允许单个项目和其它项目有不一样的align对齐方式，默认值为auto，表示继承父元素的align-items属性。可选的属性值即align-items属性值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>(#待更新)</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>参考学习的一些资料：</p><p>1、<a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">理解Flexbox：你需要知道的一切</a><br>2、<a href="https://www.w3cplus.com/blog/tags/157.html" target="_blank" rel="noopener">flexbox</a><br>3、<a href="https://flexboxfroggy.com/" target="_blank" rel="noopener">flexboxfroggy一款练习flexbox的小游戏</a><br>4、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener">display MDN</a><br>5、<a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/" target="_blank" rel="noopener">写给自己看的display: flex布局教程</a><br>6、<a href="https://flaviocopes.com/flexbox/" target="_blank" rel="noopener">The Flexbox Guide</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com//blog/assets/flexbox/flex.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么写这样一篇文章&quot;&gt;&lt;a href=&quot;#为什么写这样一篇文章&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>今年看的书📚(2018)</title>
    <link href="https://wuxinhua.com/2018/12/29/The-Books-I-Read-In-2018/"/>
    <id>https://wuxinhua.com/2018/12/29/The-Books-I-Read-In-2018/</id>
    <published>2018-12-29T02:46:46.000Z</published>
    <updated>2020-12-31T12:01:49.409Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com/blog/assets/book-read-2018/book.jpg" alt></p><p>年底了来复盘一下今年的读书情况，今年读的一些书确实开阔了我的视野，发现好的书总是有一种很神奇的力量让人很放松，一方面通过阅读能走进作者的内心世界，去了解作者的思维模式，另一方面可以透过不同的视角来观察理解这个世界、反思自己。学习能力是人一生中最重要的能力之一，其中阅读是学习手段中最便捷的一个，阅读本身就是探索未知的过程，是一种乐趣，能够带来乐趣的是读书本身这个过程；另一个乐趣是结果，获取知识的的过程是不可逆的，在你知道的那一瞬间，它已经改变了你对一些事物的看法，之后也一直影响着你。这篇阅读总结拖了有一段时间，利用周末和空余时间总算写完，这篇文章不贩卖焦虑，也没有心灵鸡汤，仅仅是一篇阅读总结，结构大致是书的主体内容加我自己的一些看法；今年一共阅读了近30本书，真正已经读完的有18本，挑了其中的一些，总结一下这些书的内容，翻阅了留下的读书笔记，聊聊当时的一些想法，如果以下文字能带给你一些思考，那就够了。</p><h3 id="《硅谷钢铁侠-埃隆·马斯克的冒险人生》"><a href="#《硅谷钢铁侠-埃隆·马斯克的冒险人生》" class="headerlink" title="《硅谷钢铁侠-埃隆·马斯克的冒险人生》"></a><a href="https://book.douban.com/subject/26759508/" target="_blank" rel="noopener">《硅谷钢铁侠-埃隆·马斯克的冒险人生》</a></h3><blockquote><p>“If something is important enough, even if the odds are against you, you should still do it.” - Elon Musk</p></blockquote><p>现实世界中的埃隆·马斯克就像漫威世界里的钢铁侠一样备受人们的关注，硅谷的马斯克经常因为一些大新闻进入人们的视野，我很喜欢他，因为他的学习能力真的太强了，而且还真的很“酷”。这位被誉为“硅谷钢铁侠”的传奇人物从未停止过自己的步伐，一直在做着改变人类历史的事情，他应该是硅谷继乔布斯之后最具传奇色彩的人物之一，文中也多次提到乔布斯，并且拿他进行对比，艾萨克森曾说若要描述历史，就应着眼于那些创造了历史的人物，乔布斯和马斯克应该都属于这一类人。之前读过沃尔特·艾萨克森的<a href="https://book.douban.com/subject/6798611/" target="_blank" rel="noopener">《乔布斯传》</a>，目前为止它应该是我读过的最好的自传类型的书，展现了乔布斯不为人知的一面，比较可惜的读埃隆这本书的时候并没有当时那种迫切地想读完、甚至二刷的感觉。  </p><p>书写得不好，但整体来说这本书的描述还是比较客观的，从他的出生开始讲起，天生带着冒险的基因、移民加拿大、开发<a href="https://en.wikipedia.org/wiki/Zip2" target="_blank" rel="noopener">Zip2</a>、组建<a href="https://en.wikipedia.org/wiki/PayPal" target="_blank" rel="noopener">PayPal</a>、创立<a href="https://en.wikipedia.org/wiki/Tesla,_Inc." target="_blank" rel="noopener">特斯拉</a>、<a href="https://en.wikipedia.org/wiki/SpaceX" target="_blank" rel="noopener">SpaceX</a>的历程，也通过马斯克身边的人、朋友、同事等的角度来了解马斯克的另一面。值得思考的是到底是什么样的社会体制、文化背景、商业环境下造就了这样的一个创业传奇？中国有没有机会出现类似特斯拉、SpaceX这样的公司?</p><p>我也是马斯克的脑残粉之一，这里我挖掘了一些关于Elon Musk的趣事：  </p><ol><li>Elon Musk本身就是一个很奇怪的名字，Elon在希伯来语是橡树的意思(但他不是犹太人)，来自于他的祖父John Elon Haldman，而她的母亲的名字叫Maye Musk。  </li><li>伊隆很小的时候，他的父母曾以为他是个聋子，因为他太专注于一些事情而没有注意到父母正在跟他讲话。  </li><li>他对太空极其着迷，12岁的时候，完成了一个软件“Blaster”(太空小游戏)，并且卖了500美元。</li><li>1995他考入了斯坦福大学学习物理，但只读了两天就辍学了；而在Tesla，伊隆象征性地领1美元的年薪，这两点跟乔布斯也是极其得相似。</li><li>伊隆对人工智能非常担忧，引用他的说法“就像是在召唤恶魔”，但他却成立OpenAI和Neuralink人工智能和脑机接口公司。</li><li>他非常喜欢一部叫《October Shy》的电影，中文名叫《火箭男孩》,在《钢铁侠2》中他有出境，还在《生活大爆炸》第九季中客串和Howard厨房洗盘子互动。</li><li>SpaceX的火箭取名“Falcon(猎鹰)”,一级引擎叫“Merlin(译作梅林或灰背隼)”，而Falcon和Merlin均取自于电影《星球大战》。</li><li>而“龙飞船”的名字来源于美国民谣组合在20世纪60年代发行并广为流传的一首歌《Puff.the Magic Dragon》（魔法龙帕夫）。</li><li>其实他还有一点点低俗趣味，接任PayPal首席执行官之后，想立即将公司的名字由PayPal重新改为X.com,遭到公司大多数的人反对，因为这个名字听起来就像个色情网站，下面这件事同样。</li><li>特斯拉的CUV新车取名Model Y,之前的SUV叫Model X，轿车Model S,而Model 3原本是想命名为Model E,但是由于版权问题没有通过（组合起来就是SEXY）;而之所以取名Model,是致敬福特公司第一款汽车Model T的问世。</li><li>伊隆还有一个管道公司叫Boring company，通过在大城市之间挖隧道来解决交通拥堵问题，而这个公司当时是当一个玩笑成立的。(Boring还有挖掘的意思)。</li><li>伊隆的第一任妻子作家Justine Musk,她其实喜欢老男人(准确地来说应该是成熟男人)，她喜欢“骑着摩托车停在女生宿舍楼下，穿着深棕色夹克，站在昏暗的路灯下喊我名字的罗密欧”那样的男人。</li><li>你能在电影《盗梦空间》的二层梦里找到Elon的第二任妻子Talulah Riley, 而在HBO美剧《西部世界》第一季的第二集中，她扮演了一个sexbot(性爱机器人)。</li><li>Justine在收到这本书的时候，估计也想不到伊隆的新女朋友在电影《傲慢与偏见》中饰演了一个配角。</li><li>他很喜欢金黄色头发的女人。  </li></ol><h3 id="《Into-The-Air-，进入空气稀薄地带》"><a href="#《Into-The-Air-，进入空气稀薄地带》" class="headerlink" title="《Into The Air ，进入空气稀薄地带》"></a><a href="https://book.douban.com/subject/3063889/" target="_blank" rel="noopener">《Into The Air ，进入空气稀薄地带》</a></h3><blockquote><p>世界上没有比心更高的山峰，也没有比脚步更远的路。</p></blockquote><p>据说这是一本登山爱好者上山前的必读的书籍之一，作者对一场造成严重死亡的山难进行了详细的描述，作者是个很会讲故事的人，动人的描述有种让我身临其境的感觉，《户外》杂志的编辑即本书的作者麦拉考加入了一个商业探险队，负责记录一次攀登珠穆朗玛峰的活动，这次登顶让这个探险队付出了惨痛的代价，登顶的5个人中有4个人在下撤的途中不幸遇难，同期登山的4个登山队中共有9个人死亡。引发了人们对登山运动、登山商业化的重新思考。登山是一件伟大而又壮丽的事情，如同书中说的那样登山是一项充满危险的运动，危险构成了这些运动的基本要素，没有危险，登山就无法同其它几百种轻松安逸运动区分开来，为什么这么多人不顾危险前赴后继地投身到这项运动中去呢？没有很好的答案能回答这个问题，或许就如同乔治·马洛里的在回答记者时说的那样：因为山就在那里。</p><p>书中让我印象很深刻的地方：</p><ol><li>测量员擅自用印度一个测量站前局长的姓氏命名了这座山峰，珠峰在西方世界里的名称“埃佛勒斯”一直沿用至今。</li><li>人的大脑在高海拔地区产生的记忆极不可靠，在接近8000米高的海拔，由于大脑无法中稀薄的空气中获取足够的氧气，人的智力会下降，导致靠近峰顶的登山者没有看到任何预示致命的暴风雪正在逼近的迹象。</li><li>登山队雇佣尼泊尔的夏尔巴人搬用行李和搭建营地，而夏尔巴人丧命于珠峰的人数异乎寻常的高，超过了攀登死亡总人数的1/3。</li><li>马洛里为了打发这位记者没好气地留下了他的传世名言：“Because it is there(因为山就在那里)”。</li><li>登山者一直都明白，登山是一项充满危险的运动，也正是因为危险吸引了成千上万的前赴后继的加入登山行列。</li><li>自上世纪50年代以来，登山者留在珠峰上的垃圾已超过140吨，而清理这些垃圾至少需要10年时间，而组织清理垃圾活动甚至比登山更加危险，19年政府将严格限制登山人数。</li></ol><h3 id="《从0到1，开启商业与未来的秘密》"><a href="#《从0到1，开启商业与未来的秘密》" class="headerlink" title="《从0到1，开启商业与未来的秘密》"></a><a href="https://book.douban.com/subject/26297606/" target="_blank" rel="noopener">《从0到1，开启商业与未来的秘密》</a></h3><blockquote><p>我们想要一辆会飞的汽车，得到的却是140个字符 - Peter Thiel</p></blockquote><p>这是一本创业者的必读书之一，它也让我更了解了创业及创业的艰辛。由于篇幅过长，我把它单独放在了这<a href="https://wuxinhua.com/2018/12/28/Book-Review-Zero-To-One-By-Peter-Thiel/">《从0到1 - 如何创造未来 》书评</a>  这篇里。</p><h3 id="《区块链：定义未来金融与经济新格局》"><a href="#《区块链：定义未来金融与经济新格局》" class="headerlink" title="《区块链：定义未来金融与经济新格局》"></a><a href="https://book.douban.com/subject/26831424/" target="_blank" rel="noopener">《区块链：定义未来金融与经济新格局》</a></h3><blockquote><p>The Times 03/Jan/2009 Chancellor on brink of second bailout for banks - Satoshi Nakamoto</p></blockquote><p>作者张健前火币CTO，创立”交易即挖矿”概念的FCoin，短时间内交易量就冲到全球榜首。作者和内容还是比较靠谱的，可以说这是一本入门级的介绍区块链的书籍，基本上讲清了什么是区块链？比特币的历史、区块链的应用场景、区块链使用的技术等。中本聪（Satoshi Nakamoto）用创世块拉开了数字货币和价值互联网的大幕，上面引用的这句话是他在创世块的留言，这句话也是泰晤士报当天的头版文章的标题，是对金融危机中旧有的脆弱银行系统的冷嘲热讽。毫无疑问，区块链可能是21世纪最让人兴奋和值得期待的技术之一，它创造性地使用非常低的成本解决了在没有第三方机构参与下双方交易的身份识别和个人信用问题，点对点的交易避免了传统的集中式清算结构，很大程度上提升了金融系统的甚至整个经济系统的运行效率。说到区块链，人们脑海里的第一反应可能就是比特币、ICO、挖矿等，年初我看这本书的时候，BTC快冲到16000美元的高峰，今天已经跌落到3700美元的谷底。</p><p>区块链的本质是一种去中心化的记账系统。比特币是这个系统上承载的“以数字形式存在”的货币，区块链是作为比特币的基础设施发明的，随着技术的发展，利用去区块链创造的货币也越来越多，目前来说，比特币的影响力是最大的。2008年10月31日下午2点10分，在一个普通的密码学邮件列表中，几百个成员均收到了自称是中本聪的人的电子邮件，￼“我一直在研究一个新的电子现金系统，这完全是点对点的，无需任何可信的第三方”，然后他将收件人引向一个九页的白皮书，其中描述了一个新的货币体系。同年11月16日，中本聪发布了比特币代码的先行版本。￼2009年中本聪在位于芬兰赫尔辛基的服务器中挖出了比特币的第一个区块，也叫创世块，比特币正式诞生，对于比特币这里不再详细描述，想了解的可以参考附录中的链接，有一份详细的学习Bitcoin资料大全。</p><p>比特币背后的技术支持得益于一个叫Cypherpunker(密码朋克)的团体，是一个由密码天才组成的团体。这些朋克们的观点是：现代社会不断蔓延着对个人隐私和权利的侵蚀。而利用密码学可以解决这一问题，这一理念在比特币中也得到体现：去中心化，对匿名的拥抱，自由主义原则等。</p><p>本书的开篇还涉及到了一些经济学的知识，遗憾的是我对经济学的认知基本为0，我最近也在看吴晓波著的<a href="https://book.douban.com/subject/3151575/" target="_blank" rel="noopener">《激荡三十年》</a>、<a href="https://book.douban.com/subject/30175590/" target="_blank" rel="noopener">《激荡四十年》</a>系列，发现经济学真的是一门难懂却很有意思的学科，在读这两本书的同时也在思考一些问题：</p><ul><li>财富得源头，财富到底从哪里来？</li><li>货币的本质是什么？货币的发行量又是由哪些因素决定的？</li><li>通货膨胀的原因，如何解决通货膨胀问题？</li><li>人们常说的政府宏观调控，到底在调控什么？</li></ul><h3 id="《白说》"><a href="#《白说》" class="headerlink" title="《白说》"></a><a href="https://book.douban.com/subject/26831424/" target="_blank" rel="noopener">《白说》</a></h3><blockquote><p>树欲静而风不止，而你唯一能做的唯一选择是：无论风怎么动，树静。 -白岩松</p></blockquote><p>读过媒体人的一些作品，目前觉得最好的还是去年读的柴静的<a href="https://book.douban.com/subject/20427187/" target="_blank" rel="noopener">《看见》</a>，今年翻开了同为央视记者白岩松的《白说》，想进一步去了解一个媒体人、新闻评论员、主持人的思想和内心世界。这是他的一本演讲稿合集，作者回顾了一些焦点新闻事件，并且用他独特的视角，去看、理解新闻的正面与对立面，去分析一些焦点问题，讲幸福、创造力、媒体、价值观等，作者是一个敢于讲真话的人，在作者的引领下，也引发我对一些事件的思考。 </p><p>我罗列一下做笔记的的一些句子：</p><ol><li>幸福可以无限靠近，无法永远到达。</li><li>当文字停止的时侯，音乐开始了。</li><li>做传媒得学会讲故事。</li><li>智商决定对手，情商决定结果。</li><li>让生命中总有一点儿闲，这是一个人和一个社会进步与健康的标志。</li><li>失败意味着成功的开始，漂亮的失败是另一种成功。</li><li>学会接受平淡，享受青春，不用过于焦虑。</li><li>好的媒体人不是无冕之王，而是细节之王。</li><li>与其抱怨，不如改变；想要改变，必须行动。</li><li>教育的本质不是让人性变好，而是约束人性中的负面欲望、扬善弃恶。</li><li>媒体有时真的需要就事论事，而不是迎合情绪。</li></ol><p>看完这两本书发现干媒体这行的人真是不容易，经常是夹杂在谎言和真相、善与恶之间，就像作者说的一样：“我和同行偶尔让这个世界变得更好；大多时间里，都是想办法不让这个世界变得更坏”。带着吃地沟油的胃，却操着中南海的心，可见有多累，不但要敢讲，心还得细，太按规矩办事，观众老爷们不买账，按规律办事，上级领导又不高兴，太敢讲了也不行，随时还有可能丢了饭碗，上一个说代表亚洲的现在还没出来。文中的一点说的非常好，理性，是目前中国舆论场上最缺乏的东西，有理性，常识就不会缺席。而非理性是当下中国的现状。这几年来不断有央视的名嘴、记者评论员辞职，有跳槽下海经商的，也有加盟互联网公司的，互联网的发展对传统的媒体行业冲击还是挺大的，可以说互联网已经改变了内容的分发渠道和分发模式，举个例子：现在凡是大点的事，娱乐圈的也好，政府行政相关的也好，都先去发个微博，有些连发布会都省了，很多热门事件我们也都是先从微博了解到的，为什么？因为微博用户基数大，有影响力，传播效果好，成本也低。传统媒体逐渐演变至新媒体，到现在又发展出了自媒体，微博很多大v署名微博自媒体，什么是自媒体，字面意义即自己就是媒体，微信公众号应该是自媒体人的主战场，不搞个公众号，你都不好意思说干这行的。有人说这本书有鸡汤嫌疑，内容跟这个书名一样，至于这是不是白说，完全取决于你。</p><h3 id="《我们台湾这些年》"><a href="#《我们台湾这些年》" class="headerlink" title="《我们台湾这些年》"></a><a href="https://book.douban.com/subject/4113090/" target="_blank" rel="noopener">《我们台湾这些年》</a></h3><p>这是一本台湾青年写给大陆同胞看的书，从作者出生1977年写起，以一个台湾平民的视角，讲述了30多年来台湾社会的大事件和小故事，回顾了1977 - 2009台湾岛内的大事件，生动地讲述了30年下岛内的政治巨变，台湾老百姓自己的悲喜人生，感谢作者，感谢这本书，让我们也从一个普通人的眼里看到了不一样的台湾。</p><p>主要的大事件时间轴：</p><ul><li>1977 出生在被赶出联合国后风雨飘摇的台湾</li><li>1978 蒋经国继任与“十大建设”</li><li>1979 台湾当局与美国“断交”</li><li>1980 “美丽岛”事件改变台湾民主进程</li><li>1983 “六义士”劫机</li><li>1984 轰动岛内的“江南案”</li><li>1994 千岛湖事件</li><li>1995 李登辉“私人访美”</li><li>1998 台北市长世纪之战：马英九击败陈水扁</li><li>1999 金援科索沃</li><li>2002 澎湖空难</li><li>2005 高雄捷运“泰劳”示威，牵出陈水扁家族弊案</li><li>2006 “红衫军”倒扁<br>…</li></ul><p>我没有去过台湾，对台湾了解甚少，没有办法多讲，我所知道的台湾大多是别人眼里的台湾，说到台湾，我脑海里联想到的是台湾的一些景点和作家，如日月潭、101大厦、余光中、当然还有各种台剧，记忆中看过印象比较深刻的两部台湾电影：《赛德克·巴莱》和《艋舺》，一部讲岛内少数民族抗争史，看完觉得日本的殖民统治给台湾带来的影响还是蛮大的。另一部讲岛内黑道帮派、兄弟爱恨情仇，跟香港的黑帮片类似。现实生活有幸在旅途中接触到一个台湾来北京做交换生的朋友，人很nice，很热心地用相机帮我拍了几张照片，还互相加了微信，可惜后来没有太多的交流。日常也会关注两岸的新闻，在电视上经常看到的是岛内蓝绿阵营拉票各种互掐闹剧，某明星政客又发表了什么台独言论，或者两岸经济文化交流活动等，但不管历史怎么变迁，国际政治形势走向，两岸关系如何发展，人们对祖国实现统一的期盼是不变的。</p><p>宝岛台湾作为我国最大的一个岛屿，面积约3.6万平方公里，20年前如日中天的“亚洲四小龙”之一，台湾制造业确实很发达，尤其在半导体芯片、点子制造业、精密制作行业，例如全球代工晶片制造商台积电、把苹果组装线开到大陆的鸿海精密，而PC制造行业也是强项，质量和服务都挺好（我买的第一台笔记本就是华硕，七八年了现在还能跑起来）。芯片行业、精密制造行业，这些我觉得都是大陆需要向台湾企业取经的地方，制造业一直都是国力强盛的核心元素，制造兴国，德国和日本就是最好的例子，2015年国务院就已经提出“中国制造2025”战略，是实施制造强国战略的第一个10年计划，加快信息技术与制造业的融合，由原来的“制造”升级为“智造”。想起前一段时间的中兴被罚事件，特朗普推特一发，中兴的很多产品生产线就得拉闸，落后就会挨打，专利、核心科技都在人家手上，还被人家抓到了把柄，只能认栽；而最近的发生的一系列跟华为相关的事件也可以看出特朗普已经将目标对准了中国另一个通信公司华为，禁止华为移动设备进入美国市场、逮捕华为CFO、多国禁止华为参与5G试验与合作等，而目的就是打压华为，狙击“中国制造2025”战略。</p><h3 id="《腾讯传》"><a href="#《腾讯传》" class="headerlink" title="《腾讯传》"></a><a href="https://book.douban.com/subject/26929955/" target="_blank" rel="noopener">《腾讯传》</a></h3><blockquote><p>don’t make me think</p></blockquote><p>如果你喜欢腾讯或者想进一步了解这家公司，那么这本书应该加入到你的书单中。我罗列了书中的一些内容，可以帮你更好地了解腾讯：</p><ol><li>QQ起源于OICQ, 而OICQ是腾讯在以色列人开发的ICQ的基础上进行创新；</li><li>腾讯的几次重大的产品上的创新如： QQ秀、QQ空间、游戏、微信都决定性地影响了腾讯的发展；</li><li>3Q大战改变了腾讯的战略，腾讯开始尝试从封闭走向开放，在这一点上，腾讯应该感谢360的“碰瓷”；</li><li>而马化腾在产品上的7个武器：<ul><li>产品极简主义</li><li>用户驱动战略</li><li>内部赛马机制</li><li>生态养成模式</li><li>资本整合能力</li><li>专注创业初心</li></ul></li><li>在选择香港还是美国上市问题上，马化腾为了兑现员工期权的承诺，最终选择在香港上市；</li><li>Martin、James等高盛投资经理人的加入，让腾讯开启了买买买的战略；</li><li>腾讯通过无需注册，使用QQ号直接登录的优势建立了在游戏领域的优势，并通过入股和并购一步步成为“游戏之王”；</li><li>腾讯通过张小龙的微信拿到了进入移动互联网的门票，雷军的米聊跟微信一样都是模仿kiki，但米聊却没有成为像微信一样的国民现象级产品；</li></ol><p>看了一些人物传记，企业传看得不多，对于我们90后这一代来说，这只戴着红色围巾的呆萌企鹅并不陌生，挂QQ升级、买钻、空间偷菜、被”艰难地决定”弹窗刷屏、甚至一边充值一边骂狗日的腾讯..这些体验很多人估计都有过，我接触QQ算是比较晚的了，09年在一个小县城的网吧里注册了第一个QQ号，那会对我来说还挺稀奇的，后来上了网，发现还真离不开QQ，哪都有QQ的身影，一旦有哪个软件、游戏火了，马上会有类似的带QQ前缀的山寨品出来，那时的腾讯也被网友嘲笑“一直在山寨，从未被起诉”。有一次在深圳大学闲逛，发现跟网络世界一样走到哪抬头都能看到马路对面的腾讯大楼，这究竟是一个什么样的公司？开始想去了解腾讯，而这本书从腾讯诞生讲起，展现了腾讯崛起的经历，讲述腾讯如何从一个小型创业公司一步步成长为互联网巨头，如何从封闭走向开放，穿插着中途发生的一些大事件，例如QQ秀QQ空间的诞生、3Q大战、微信的诞生等。比较遗憾的是作者整篇的内容对腾讯的失败有所避讳，这本书中我们看到的几乎是腾讯光鲜亮丽的一面，腾讯的失败、问题被一笔带过，甚至在描述3Q大战时让人有种腾讯在这场战争中是个弱者的形象。  </p><p>批评的声音总是刺耳的，前有计算机世界的《狗日的腾讯》，后有潘乱的《腾讯没有梦想》，前者跟腾讯刚正面，腾讯的抄袭、对创新的打压让所有创业者深恶痛绝，后者近万字阐述腾讯正在失去创新能力，在对腾讯股价大涨一致吹捧的的局面下，重新思考腾讯的战略，点醒高层，并反思腾讯在搜索、电商、短视频..等战场的溃败。腾讯到底有没有梦想我不敢说，但结合近期发生的一些事情来看，腾讯在除社交外的一些领域正在失去竞争能力，to C端短视频端一直干不过抖音，7月份抖音公布全球月活到达5亿，国内月活3亿，除此外目前国内过5亿的应该只有微信和支付宝，亲儿子微视一直是是不温不火的状态，甚至还榜上微信的大腿，下半年微信拍摄菜单栏还多出一项“用微视拍摄”的选择（目前已经移除）；公有云市场，阿里云在市场份额上遥遥领先（45%左右），腾讯云第二，这个赶超还有很长的一段路要走，而腾讯云宣传中承诺的99.99999%可用率似乎并不真实，之前的硬盘故障导致一家叫“前沿数控”的创业公司数据全部丢失，事故频出对腾讯云的品牌和口碑的打击来说雪上加霜。</p><p>腾讯强在产品不无道理，CEO马化腾工程师、产品出身，在产品的理解、用户需求的分析上做得很到位,一直说“百度的技术；阿里的运营；腾讯的产品”，百度内部工程师文化很浓厚，重技术、重算法、重搜索，注重技术、重视人才固然是好事，但搞研发的并不一定是最理解用户需求及产品的使用模式的人，带来的结果就是产品做得烂，“工程师文化 == 产品烂”这个等式我觉得有一定的道理。  </p><p>马化腾说 “要容忍失败，允许适度浪费，鼓励内部竞争内部试错，不尝试失败就没有成功。在面对创新的问题上，要允许适度的浪费。怎么理解？就是在资源许可的前提下，即使有一两个团队同时研发一款产品也是可以接受的，只要你认为这个项目是你在战略上必须做的。” 小马哥的气度还是大啊。</p><p>聊聊腾讯内部赛马机制，赛马机制在很多公司都存在，阿里内部也有赛马。玩过腾讯的一些游戏会发现同类型的游戏在腾讯会存在好几款，《王者荣耀》和《全民超神》是“赛马”的产物，其实微信也是赛马的产物，为了激励员工做出好产品，腾讯在一些项目或创新领域同时投入两三个团队做同一件事情。赛马机制是诞生优秀产品很好的一个方式，但赛马机制也存在一些弊端例如同时多个部门开展一个业务，公司资源的整合变得愈加困难，容易造成企业资源的浪费; 二者赛马本质上是优胜劣汰，胜者为王，这对于竞争失败的团队来说打击是比较大的，如果是战略产品，同时利用两个团队开发推进是否真的有必要？ </p><h3 id="《被仰望的和被遗忘的》"><a href="#《被仰望的和被遗忘的》" class="headerlink" title="《被仰望的和被遗忘的》"></a><a href="https://book.douban.com/subject/26929955/" target="_blank" rel="noopener">《被仰望的和被遗忘的》</a></h3><blockquote><p>“我没打算开创新新闻主义，我只想写得像菲兹杰拉德” - 盖伊·特里斯</p></blockquote><p>没有想过新闻特稿还可以这样写，盖伊·特里斯用文字替纽约写传记，从他的文字里看到了纽约这座城市的灵魂。很难想象在纽约这样的大城市生活是怎样的一种体验，凌晨后的纽约是一种什么样的景象，不知道纽约是不是也像北京一样有雾霾，早上的城铁会不会挤成这样？…</p><p>盖伊·特里斯，美国《纽约时报》的资深记者。新新闻主义的杰出和代表人物，我们知道新闻的撰稿都有一定的格式，传统新闻要求记者称述事实，真实胜过一切，盖伊的风格不同于传统新闻报道风格，他在非虚构写作方面的创新是加入了小说的技法，让他所写的故事具有短篇小说的结构，从旁观者的角度来描述新闻，这种风格后来被人冠名为“新新闻主义”。</p><p>这本书分为三章，可以理解为纽约城的三部分故事：</p><p>第一部分： 纽约 一位猎奇者的足迹  </p><p>这部分记录的是作者时代纽约城里人生活中的各种奇闻轶事及一些底层人物的故事，例如每天纽约人要喝下46万加仑啤酒，吃掉350万磅肉，每天约250人死去，460人出生。“哥谭市”拥有300万人，而姓史密斯的有3277人，其中近500名巫师，5000名妓女，25万名同性恋，8485名接线员，200个核桃贩子，1.2万名清洁女工，她们大多是乌克兰人，3.8万名出租车司机，30万只鸽子，600尊雕像和纪念碑的城市，每天有9万人拨打电话询问天气，7万人查询时间，还有65万人不知道打什么电话而拨打411，纽约城里有名目繁多的各种委员会，有解放爱沙尼亚委员会、和平利用核能委员会…等等，通过这些大多数人都不知道的人物和事件的详细描述，为读者展现了不为人知的一面。  </p><p>第二部分： 大桥  </p><p>建桥工人的故事，当时建桥者一生中最具挑战性的工作，连接纽约泰登岛与布鲁克林的悬索桥-韦拉扎诺海峡大桥，1964年完工之初即成为当时世界上跨度最大的悬索桥。作者花了数个月的时间在工地上，走访工棚，对这些修桥工人进行观察研究，对修桥工的工作和生活进行极为细致感人的描述，修桥工的生活几乎是流动性，哪里有工程就奔赴哪里，其中的一些人甚至为修桥丢了性命。如作者所说：“他们把一个个地方用大桥连接起来，可他们自己的生活已经支离破碎”。 </p><p>第三部分： 走向深处  </p><p>《走向深处》由11篇美国社会知名人物的小传构成，这些人中有家喻户晓的明星弗兰克.辛纳屈、前拳击世界冠军帕特森、文艺十足的花花公子、棒球明显乔.迪马乔等，描绘了曾经活跃在社会舞台上的几位名人的梦想和辉煌。</p><p>纽约，也被世人称为“国际大都会”，世界上语言和人口族群最为多元化的城市，据维基百科显示显示这一地区使用的语言多达800种。1524年，乔瓦尼·达韦拉扎诺成为第一个历史记载的造访纽约的欧洲人，海峡建的大桥取名应该就是为了纪念这位 探险者，1624年荷兰殖民者在这块地建立贸易站，取名新阿姆斯特丹，荷兰人取名为Nieuw-Nederland（新尼德兰）。1664年，新尼德兰总督彼得·斯特伊维桑特投降，将新阿姆斯特丹拱手让给英国人，英国人将此地更名为New york“纽约”，据说名字来源英国的York镇，以海军大臣约克公爵命名。说到美国的一些地名，发现还是有一些规律，美国的很多地名跟独立前的殖民历史有关系，例如美国东部沿海几个州都是英国殖民地，英语普及度最高，甚至不少直接照搬了英国的地名，加上New 形成新的地名，例如：Newark、New London等，而西部各州的名称来源则多为西班牙词汇，例如加州这块地，之前属于墨西哥的领土，是西班牙的殖民地，会发现有一大堆San或Santa开头的城市，例如湾区的旧金山（San Francisco）、圣何塞（San jose）、（圣莫尼卡）Santa Monica等，有些是当年西班牙传教士的名字，San是男性名字，Santa则是女性。  </p><h3 id="《黑客与画家》"><a href="#《黑客与画家》" class="headerlink" title="《黑客与画家》"></a><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与画家》</a></h3><blockquote><p> 程序写出来是给人看的，顺带能在机器上运行</p></blockquote><p>这本书是硅谷创业之父，<a href="https://www.ycombinator.com/" target="_blank" rel="noopener">Y Combinator</a>创始人<a href="http://www.paulgraham.com/" target="_blank" rel="noopener">Paul Graham</a>（保罗.格雷厄姆）的文集，由大牛<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a>翻译，Paul带我们走进黑客的世界，讨论黑客的成长、黑客对世界的贡献、创造财富、计算机编程等，Paul自己也是一位Lsip程序员。这本书适用于所有程序员、互联网创业者，以及所有对计算机行业感兴趣的人。</p><p>总结了书中的一些观点：</p><ol><li>程序写出来是给人看的，顺带能在机器上运行。</li><li>在创业公司，每天都像在战斗，在大公司，就像在窒息中挣扎。</li><li>金钱只是财富的一种表达方式，但财富不等于金钱，致富需要两样东西： 可测试性和可放大性。</li><li>致富的最好办法是创造财富（我理解为创业），而不是掠夺。</li><li>表面上这是一个机器的时代，但是实际上是机器的设计者决定了我们的时代。</li><li>黑客的三个特点： 好玩、高智商、探索精神。</li><li>关于设计：好的设计一定是简单的设计，是能解决问题的设计，也是模仿大自然的设计。</li><li>随着工业化时代的来临，手工艺人越来越少，目前还存在的最大的手工艺人群体就是程序员。</li><li>那些做出伟大作品的人，你会发现他们的共同点就是非常努力地工作。</li><li>格雷厄姆总结的创业公式：<br>a. 搭建原型<br>b. 上线运营（先跑起来，别管bug）<br>c. 收集反馈<br>d. 调整产品<br>e. 成长壮大</li></ol><p>关于程序、机器：</p><p>认同好的设计一定是简单的设计，好的设计一定是解决问题的设计这句话，编程和软件构建是一门大学问，代码、程序的设计也一样，例如两段代码都得到同样的结果，都能解决问题，应该寻求最优的解决方案，当然做选择时还需考虑其它的很多因素，例如代码的可读性，一项研究发现，程序员在重构一段代码时至少需要经过10个程序员的修改，重构前还需花去50%到60%的时间来搞懂他们要维护的代码（parikh and Zvegintzov），我们是在为人写代码，其次才是机器，代码最终会被机器执行，但机器才不关心你的代码是否好读，它更善于读二进制指令，例如写注释这件事，有没有注释对机器来关系不大，但对下一个读这行代码的人影响很大，注释跟文档不同，写注释也是一件技术活，好的注释能节省时间，差的注释只会浪费时间，而无用的注释只会增加后者在阅读这段代码时彪脏话的次数，但当人们从事创造性的工作时，好像容易忘记保存简单的这个原则，我自己也经常会范这类错误，这也是为什么很多工程师隔一段时间再回过头去看自己以前写的一些代码时有那种反胃的感觉。</p><p>前段时间有人跟我开玩笑说他这几年坚持最久的一件事就是每天都玩手机，一开始想笑，但一想还真是，手机已经像空气、食物一样变成了生活的一项必需品，我们对手机对WiFi对网络的依赖已经超出了想象。在当前这个时代，每个人生活的很大一部分都离不开计算机，离不开网络，人与机器的互动越来越多，甚至未来的人类生活更多地是人与机器的互动，人与网络之间的互动，要想更好地跟这个世界交流，计算机是一个很好的媒介，想要了解计算机，最好的方式就是了解那些创造计算机及程序背后的人。你看到的触控到的界面是UI、UX工程师帮你设计的，你执行的流程可能是PM帮你设定的，而你吐槽的一些bug极有可能是工程师未检查某行代码执行异常留下的后遗症，就像作者所说的表面上这是一个机器的时代，但是实际上是机器的设计者决定了我们的时代，创造这个产品或机器的人的品质决定了它好不好用，工程师的审美决定了这个东西能带给用户多大的视觉冲击、美感。未来机器将从人类手头夺走太部分重复性并且不需要创造性的工作，未来软件工程师这一职业是否会消失不好说，但目前人类已经开始训练机器从事这方面的尝试，例如利用AI生成海报、训练神经网络自我解决bug…未来的机器应该会具备编程能力，自我训练解决问题的能力。</p><h3 id="《异类》"><a href="#《异类》" class="headerlink" title="《异类》"></a><a href="https://book.douban.com/subject/3688489/" target="_blank" rel="noopener">《异类》</a></h3><blockquote><p>成功不是随机事件，成功是一系列可预见的、强有力的优势环境和机遇构成的。</p></blockquote><p>这是一本研究成功的书，分析了成功人士的共同特点，导致他们能够成功的一些因素，总结下来就是一句话：成功不是随机事件，成功是一系列可预见的、强有力的优势环境和机遇构成的。再简单一点用中国的老话就是：天时地利人和。书名中的“异类”指的是那些获得特殊机遇、耐心等待、并且一把把握住机遇的人。我对一些成功学、鸡汤类的书不是很感兴趣，简单总结一下这本书的内容和观点：</p><p>内容：</p><ol><li>冰球球员的生日集中在1月、2月、3月，年龄上的优势开始突显出来。</li><li>披头士在德国脱衣舞夜总会的提高了他们的演唱水平，为日后走红奠定了基础。</li><li>盖茨生逢其时，智商和时代导致了他的成功。</li><li>很多著名的律师事务所都是犹太人的出生，祖辈大多从事服装业。</li><li>大韩航空事故频发的根本问题在于团队协作和沟通上。</li></ol><p>观点：</p><ol><li>不存在什么“与生俱来”的天才，但也不存在10000小时定律，即使你的努力程度比别人高，但不见得你一定会比他成功。</li><li>一份满意的工作应该具备的3点属性：自主性、复合性、付出和回报的关联性。</li><li>在社会学领域，所谓的成功就是“优势积累”的结果。</li><li>智力和成就之间并不存在太大的关联。</li><li>努力工作是所有成功人士的共性。</li><li>10000小时理论有一定的道理。</li></ol><h3 id="《撒哈拉的故事》"><a href="#《撒哈拉的故事》" class="headerlink" title="《撒哈拉的故事》"></a><a href="https://book.douban.com/subject/1361264/" target="_blank" rel="noopener">《撒哈拉的故事》</a></h3><blockquote><p>“生命的过程，无论是阳春白雪，青菜豆腐，我都得尝尝是什么滋味，才不枉来走这么一遭啊”</p></blockquote><p>这应该是我第三次翻开三毛的书了，高中在门口书店偶尔翻到这本书，结果一发不可收，很惊叹这个奇女子，真性情、善良又洒脱，佩服三毛可以这么用心、能用简短的文字把故事写得这么动人。《撒哈拉的沙漠》也是三毛最受欢迎的作品集，里面的一篇篇的小故事让人动容，在《白手起家》里，她在撒哈拉这片没有花朵的荒原里把破漏的土房子变成了精致、带绿色的温馨小窝；在《悬壶济世》里三毛用黄豆治好了当地人的疖子，用指甲油帮人补牙齿，哇！还可以这么玩；在《沙巴军曹》里讲述了一个被仇恨吞噬但最后却舍身救撒哈威孩子的军人；在《哭泣的骆驼》里，三毛在屠宰房里，亲眼目睹沙伊达的惨死，讲述了当地巴西里（游击队的领袖）与沙伊达（拥有绝美容颜的女子）那不被世人祝福的爱情故事，以及悲惨的结局等等。</p><p>虽然后面种种原因，三毛用自杀的方式结束了自己的生命，但至少从这本书中我能感受到的三毛对生活的乐观，例如文中的一些句子：“我想，来了沙漠，不经过生活物质上的困难，是对每一个人在经验上多多少少的损失。”， “我并不气馁，人，多几种生活经验总是可贵的事”。对恶劣沙漠环境、各种搞笑甚至刁难的邻居，她没有屈服，总是想着如何去改善环境，克服物质和精神上的一些困难。想到自己，其实我没有正在体验过所谓“生活物质上困难“的状况，还得我的父亲给我讲他年轻时的困境，就是那种家里贫穷到缸里的米只剩当天的量，吃完挨个亲戚去借米下锅，很庆幸从出生到现在一直活在一个和平富足的年代，虽然父母都是普普通通的农民，家里的条件也不太好，但父母至少在衣食住行基本的教育等方面还是满足了子女的需求，我也很感激他们的努力付出，他们从来没有教会我如何赚钱，他们要我勤俭节约；他们没有教我如何同朋友交往，他们叫我要真诚善良；他们没有教我如何付出，他们要我学会感恩；父母能给的不一定是最好的，但一定是他们竭尽全力的所有。工作前我的情感一直很脆弱，我曾因一些考试的失败而痛哭流涕，出了校门也曾经常因为一些工作的事情困扰，总结一下都是我自己心态的问题。有时会想面子重要吗？或许内在修养更重要；职称重要吗，或许实打实的成长、收获更重要，钱重要吗？钱很重要，但家庭、朋友、健康这些都更重要…目前来说这个世界上除了生死，其他的都是可控制的，都能迈过去，“看开点”以及在特定的环境里调整好自己的心态真的是很重要，无论是生活的一些琐事，还是工作上的烦恼，这些就像天气，有阴晴不定，有瓢泼大雨，也有云开日见，一切都是正常的，我想表达的就是：在很多情况下，你可能无法去改变环境，那就尝试着去调整自己。</p><h3 id="《奈飞文化手册》"><a href="#《奈飞文化手册》" class="headerlink" title="《奈飞文化手册》"></a><a href="https://book.douban.com/subject/30356081/" target="_blank" rel="noopener">《奈飞文化手册》</a></h3><blockquote><p>“我们只招成年人”</p></blockquote><p>Netflix 是一家流媒体巨头，前段时间刚看完《毒枭.墨西哥》，他家的电视剧质量真的没得说，所以这几年的股价也是蹭蹭地往上涨。这本书带我们走进奈飞这家公司，了解奈飞的公司文化。总结起来Netflix公司文化的核心就是：自由和责任。我估计很多HR都读过这本书，我认同书中的一些观点，遗憾的是我认为目前来讲书中的一些观点并不适用于当前中国的互联网公司，毕竟地域不同、文化不同、公司结构环境、用人标准等都有差异，照搬一定行不通，可以借鉴的是把这些文化发展成“中国特色”的企业文化，衍生出自己的企业文化，让中国的互联网公司发展得更好，走得更远。</p><p>奈飞的企业文化：</p><ol><li>自由和责任为核心。</li><li>我们只招成年人。</li><li>要让每个人都理解公司业务。</li><li>绝对坦诚，才能获得真正高效的反馈。</li><li>只有事实才能捍卫观点，坚持你的观点，用事实捍卫它。</li><li>组建你未来需要的团队。</li><li>员工和岗位应该是高度匹配。</li><li>价值==薪水，保证每个人都获得市场上最高水平的薪水。</li><li>离开时也要好好说再见。</li></ol><p>我的一些理解：</p><ol><li>自由和责任为核心。所谓的自由前提应该是员工能够高度自律，放眼现在所有的公司根本不存在绝对的自由，当员工知道哪些是该做的哪些不该做的时候，责任自然在了，三流公司靠人管理，二流公司靠人管理，一流公司靠企业文化；公司规模发展到一定程度的时候，用人来管人是效率最低的，这个时候需要制定相应制度，并且充分利用公司企业文化，国内这方面做得最好的就是阿里了，马云一直讲这三个利器决定公司能否走的远：使命愿景价值观。</li><li>我们只招成年人。成年人不再需要各种规章制度来约束，成年人犯错率也更低，相对来说公司在管理、培训上的支出也可以缩减。</li><li>要让每个人都理解公司业务，这其实是在培养基层员工的高层视角，不管是哪个岗位理解公司的业务都有助于工作的顺利开展以及应对公司策略层面的变化。</li><li>绝对坦诚，才能获得真正高效的反馈。坦诚是沟通的前提，工作中最有效的沟通方式应该是就是面对面的沟通。</li><li>只有事实才能捍卫观点，坚持你的观点，用事实捍卫它。用我们的话讲就是做到就事论事，对事不对人，我之前就碰到过开会争论升级到人身攻击的事，真是一地鸡毛。</li><li>组建你未来需要的团队。在国内来讲，针对当前现状来组件团队，适时调整优化应该是最有效的。</li><li>员工和岗位应该是高度匹配，价值==薪水，保证每个人都获得市场上最高水平的薪水。这两点估计在硅谷是适用的，伟大工作与福利无关、不和面试者谈需求，这些放在中国，与当前环境显得格格不入。</li><li>离开时也要好好说再见。而实际情况是员工离职和原雇主闹上法庭的事情每天都在发生，为什么硅谷提倡要和离职的人好好说再见？我之前在笔记中写过，与硅谷的“背叛”文化相对应的，是硅谷的宽容，加州法律比较倾向于支持跳槽者，不像纽约、新泽西州等地严格的执行同业竞争条款，在硅谷你周五离职了，甚至都来不及跟别人分享这一信息，周一就可以去新的公司上班，员工辞职或者跳槽之后，可以继续从事原来的工作，甚至与前雇主直接竞争。另一方面大公司倾向于对辞职的员工的创业公司进行投资，而不是“赶尽杀绝”，因为如果通过诉讼，大公司从“叛逃”员工身上获得的受益不会太多，却要陷入旷日持久的法律诉讼程序中，相反通过对“叛逃”员工进行投资，换取优先收购权或者购股权，获得的收益反而更高。</li></ol><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>还有一些书例如李笑来的<a href="https://book.douban.com/subject/25749845/" target="_blank" rel="noopener">《把时间当做朋友》</a>、桥水基金创始人达利欧写的<a href="https://book.douban.com/subject/27608239/" target="_blank" rel="noopener">《原则》</a>、<a href="https://book.douban.com/subject/26789567/" target="_blank" rel="noopener">《如何有效阅读一本书》</a>等都觉得挺好，读完也有收获，阅读比写作更容易，有些想法却不知道怎么更好地用文字表达出来，所以没有把它们一一列出来。写这篇笔记的目的并不是彰显自己读过多少书，也不是为了自己的想法获得多少人的认同，仅仅是做一次总结及知识分享，毕竟阅读量和广度都有限，我的看法只是我的，甚至有可能是错误的，恳请斧正，如果你有更好的见解也欢迎交换交流探讨。</p><p>今年发生了很多事，2018年是改革开放40周年，中美贸易争端还在持续，年中互联网企业扎堆上市，滴滴安全事故频出，摩拜卖身美团，ofo没落，电竞火了手机厂商却倒了…年底各种裁员潮等等，借用上帝视角来看2018年可以说是中国互联网行业发展剧变的一年，风口没了，流量的红利也不存在了，企业也在寻求变革，2018年对互联网从业者来说并不太友好，目前阿里等大公司已开始缩减hc，很多大公司也开始裁员并停止社招，而创业公司在挣扎着熬过这个互联网寒冬。陆陆续续看了很多人的年终总结，我也曾尝试去debug一下自己的这一年，一直都期待能收获更多的东西，或能力上有提升，或工作上有收获，或自己变得更稳重可靠，或多交几个朋友…遗憾地发现这一年收获很小，一年整整8760个小时，到头来没有一两件能拿出来让自己觉得有成就感、幸福的事情，看来还是不够努力；人生不如意事十之八九，生活的本质或许就是这样，你想要的，它偏偏没有。  </p><p>2019年已经开始了，今年又立了一些flag，当然不变的那一个还是尽可能多地阅读，做笔记，做一颗有思想的芦苇，希望年底再来写读书笔记的时候能收获更多。用马丁.路德金的一句话结束这篇文章，希望与大家共勉，19年继续努力。</p><blockquote><p>失望是有限的，我们必须接受它，但希望是无限的，我们永远不能失去它。 </p></blockquote><p>2017年看的一些书戳这<a href="https://wuxinhua.com/2017/12/22/The-reading-book-list-in-2017/">今年看的书📚(2017)</a>。</p><p><img src="https://assets.wuxinhua.com//blog/assets/weread-2018-screenshot.png" alt></p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><a href="https://lopp.net/bitcoin.html" target="_blank" rel="noopener">1、Jameson Lopp 整理的关于 bitcoin 的优质学习材料</a><br><a href="https://blog.codingnow.com/2011/05/bitcoin.html" target="_blank" rel="noopener">2、云风Bitcoin 的基本原理</a><br><a href="http://www.ruanyifeng.com/blog/2018/12/elon-musk.html" target="_blank" rel="noopener">3、埃隆·马斯克和特斯拉汽车的故事</a><br><a href="https://www.wired.com/story/elon-musk-tesla-life-inside-gigafactory/" target="_blank" rel="noopener">4、Dr. Elon &amp; Mr. Musk: Life Inside Tesla’s Production Hell</a><br><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">5、Bitcoin: A Peer-to-Peer Electronic Cash System</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com/blog/assets/book-read-2018/book.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;年底了来复盘一下今年的读书情况，今年读的一些书确实开阔了我的视野，发现好的书总是有一种很神奇的力量让
      
    
    </summary>
    
    
      <category term="阅读" scheme="https://wuxinhua.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>《从0到1 - 如何创造未来 》书评</title>
    <link href="https://wuxinhua.com/2018/12/28/Book-Review-Zero-To-One-By-Peter-Thiel/"/>
    <id>https://wuxinhua.com/2018/12/28/Book-Review-Zero-To-One-By-Peter-Thiel/</id>
    <published>2018-12-28T15:26:20.000Z</published>
    <updated>2020-12-31T12:01:49.405Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com/blog/assets/Zero-To-One/zero-to-one.jpg" alt></p><p>这可能是我写的最长的一篇书评，共4587字，TL;DR。 </p><p>这本书的电子版、纸质版我都有买，收获很大，颠覆了我对创业、资本、团队…的一些看法，我也浏览Blake Masters整理发布在网上的笔记，事实上讲义的内容更加精彩，建议大家网上自行获取阅读。<br>我会对这本书的章节和观点进行总结，也加入我自己的一些想法，希望这些能帮助你更好地理解这本书。</p><h3 id="这本书的一些背景知识"><a href="#这本书的一些背景知识" class="headerlink" title="这本书的一些背景知识"></a>这本书的一些背景知识</h3><p>彼得·蒂尔，PayPal的联合创始人及天使投资人，被誉为硅谷的创投教父。这本基于Peter Thiel在斯坦福大学的CS183讲义整理而成（截选了其中的14章），一个叫Blake Masters的学生将讲义的笔记整理发布在网上，引起了轰动。0到1的概念正是因为这本书火起来，这本书还有另一个名字“How To Build The Future”，可以理解为是作者对未来的一些思考，其实我更喜欢这个标题。</p><h3 id="第一章：未来的挑战和创业思维"><a href="#第一章：未来的挑战和创业思维" class="headerlink" title="第一章：未来的挑战和创业思维"></a>第一章：未来的挑战和创业思维</h3><p>未来确实充满挑战：人口问题、自然能源枯竭、空气污染、食品安全…世界的未来由全球化决定，但是事实上科技更具有影响力,丢掉科技创新的全球化不会长久，只有科技创新未来才有希望。<br>关于创业思维，创业是实现0到1的跨越，是垂直进步，而复制已存在的成功是1到n的过程，是水平进步。<br>为什么创业能解决这些难题呢？两个原因：</p><ol><li>初创公司是新科技的诞生地。  </li><li>大团体更保守、不愿冒险，要发展新事物很难。  </li></ol><h3 id="第二章：像1999年那样狂欢"><a href="#第二章：像1999年那样狂欢" class="headerlink" title="第二章：像1999年那样狂欢"></a>第二章：像1999年那样狂欢</h3><p>回顾1990-2000年科技乐观主义，硅谷对新技术的渴望及创业者的狂热，然而2003年纳斯达克指数的崩泻标注了这个时代的结束。<br>得到的教训就是:</p><ol><li>循序渐进（大胆尝试胜过于平庸保守）</li><li>保持精简和灵活性（坏计划也好过于没计划）</li><li>在改进中竞争（竞争性市场很难赚钱）</li><li>专注于产品而非营销（营销和产品同样重要）  </li></ol><p>这几年确实是技术的狂欢年，我列几个事件大家来感受一下这场互联网及资本的狂欢：<br>Netscape 即大家俗称的<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF" target="_blank" rel="noopener">网景</a>，1990年代中期浏览器市场份额达到了惊人的90%，1995年8月9日，网景首次公开募股获得巨大成功，原定的股价14美元临时倍增至28美元，第一天收市股价蹿升至美股75美元，获得了几乎是创纪录的“首日获利”。<br>曾经的天之骄子<a href="https://zh.wikipedia.org/wiki/%E9%9B%85%E8%99%8E" target="_blank" rel="noopener">Yahoo!</a>(雅虎因为Yahoo商标被抢注，公司在Yahoo后面加上了!)，于1996年4月12日，雅虎公司首次公开募股，以每股13美元的价格卖出260万股，筹资1亿3380万美金。随后在4年之内，雅虎股票翻了100倍左右！到1999年底，雅虎股价已经达到了惊人的100美元，市值突破1000亿美金，是整个互联网行业里第一家市值突破千亿美金的公司  </p><h3 id="第三章：所有成功的企业都是不同的"><a href="#第三章：所有成功的企业都是不同的" class="headerlink" title="第三章：所有成功的企业都是不同的"></a>第三章：所有成功的企业都是不同的</h3><p>用航空公司和谷歌来阐述竞争和垄断的区别，垄断企业都有以下几个特征（作者在第四章详细阐述）：</p><ol><li>专利技术</li><li>网络效应</li><li>规模经济</li><li>品牌优势  </li></ol><p>而建立垄断企业的方法：  </p><ol><li>占领小市场</li><li>扩大规模</li><li>不要搞破坏  </li></ol><p>并且不要相信垄断企业说的谎言，垄断者通常把自己的市场描述成若干个大市场的并集来伪装它的垄断性。垄断企业的崛起靠的是解决了独一无二的问题而获得霸主的地位，成为垄断性企业才是一个公司应有的状态。那为什么企业会失败呢？原因只有一个：都无法逃避竞争。  </p><h3 id="第四章：竞争意识"><a href="#第四章：竞争意识" class="headerlink" title="第四章：竞争意识"></a>第四章：竞争意识</h3><p>并不是初创公司竞争，大公司同样在较劲，Microsoft vs Google, Bing vs Google Search, Chrome vs IE, Office vs Docs， Outlook vs Gmail等，竞争有时会导致另一个巨头的诞生，而有时会导致资本、企业的合并。竞争并没有什么原因，这是与生俱来的，是一种天性，但竞争容易让人分心，甚至容易产生幻觉。<br>第五章：后发优势<br>一家公司的估值是由后几年的现金流决定的，这也是为什么现在很多公司在持续亏损，估值却在攀升的原因。先发优势并不一定是最好的，后发优势、持续的现金流增长同样重要。  </p><h3 id="第六章：人生不是买彩票"><a href="#第六章：人生不是买彩票" class="headerlink" title="第六章：人生不是买彩票"></a>第六章：人生不是买彩票</h3><p>你并不是一张靠概率决定命运的彩票，你自己掌握了能否成功的钥匙。成功的原因靠运气还是靠技能？记住一点：成功不是靠运气。一个人的成功能归结于他与生俱来的天赋吗？优越家庭背景？或者运气？靠10000小时的练习？其实都不是。如同《异类》一书阐述的一样：成功并不等于天赋+努力，在生活学领域，所谓的成功就是“优势积累”的结果，成功不是随机事件，一系列可预知的 、强有力的优势环境和机遇导致了成功。  </p><h3 id="第七章：向钱看"><a href="#第七章：向钱看" class="headerlink" title="第七章：向钱看"></a>第七章：向钱看</h3><p>80-20法则及风投中的幂次法则：社会80%的财富掌握在20%的手里。风投中的回报并不遵循正态分布，而是遵循幂次法则：一小部分公司可以完胜其他所有公司。风险投资的一个规则就是只投资给有潜力达到整个投资基金总值的公司，而第二条规则就是因为这条规则太可怕了，所以投资不需要其它规则，及你投资的公司分类中只存在两类：主要投资公司和其它公司。  </p><h3 id="第八章-秘密"><a href="#第八章-秘密" class="headerlink" title="第八章 秘密"></a>第八章 秘密</h3><p>秘密分为两种：关于自然未知世界和关于人的，在思考创建公司时需要思考两个问题：自然没有告诉你的秘密是什么？人类没有告诉你的秘密是什么？而为什么现在人们不相信秘密？因为人们觉得世界地图上已经没有什么空白之处，人们总是在规避风险，人们害怕因为探索秘密导致的犯错，人们满足于现在所创造的成就，另一个原因是世界的“扁平化”影响了我们对秘密的理解。我们不应该活在一个恪守成规的世界里，应该相信秘密的存在，事实上有很多秘密等待我们去探索，这也是建立公司的意义所在。成功的企业是建立于开放却未知的秘密之上。  </p><h3 id="第九章-基础决定命运"><a href="#第九章-基础决定命运" class="headerlink" title="第九章 基础决定命运"></a>第九章 基础决定命运</h3><p>美国为什么能成为世界的霸主？美国的宪法在建立之初至今只修改过17次。Thiel的定律就是：<strong>A startup messed up at its foundation cannot be fixed</strong>。创业初期的决定将是至关重要的，基础没有打好的创业公司都是没有未来的，你无法在有缺陷的基础上创建一个伟大的企业。在建立初创公司团队的时候应该考虑以下几点：</p><ol><li>能互补的合伙人最为理想；</li><li>妥善地解决由于公司所有者、运营者、投资者导致的问题；</li><li>董事会成员越少越好，小型公司三个董事是最理想、最稳妥的组合方式（为什么？三角形永远是最稳定的）；</li><li>薪酬问题；</li><li>股权分配问题，股权报酬能让员工全力以赴；  </li></ol><h3 id="第十章-帮派结构（文化）"><a href="#第十章-帮派结构（文化）" class="headerlink" title="第十章 帮派结构（文化）"></a>第十章 帮派结构（文化）</h3><p>讲述PayPal的公司人员结构，以及如何选择应聘者，如何建立公司文化。每个员工都应该与众不同，每个员工都应该专注于一件事。<br>我了解到的是早期的PayPal有一条原则就是不主动解雇任何一个员工。团队开始雇佣他们自己信任的朋友，但是渐渐地这条规则就不适用了，因为他们不得不解雇那些招进来的什么都不了解的人。“不解雇”的原则也带来了一些好的影响，那就是招聘变得战争一样，容易带来不好的后果，必须得谨慎。  </p><h3 id="第十一章-顾客不会主动上门"><a href="#第十一章-顾客不会主动上门" class="headerlink" title="第十一章 顾客不会主动上门"></a>第十一章 顾客不会主动上门</h3><p>销售人员和技术精英同样重要。永远不要低估销售的重要性，技术人员总是以为好的产品在创造出来后就应该被神奇地分销出去，但这是不正确的，在技术领域，解决方案不是奏效就是失效，但这个判断规则在销售领域不适用。任何形式的销售都是隐形的，第一要务是说服，而不是真诚，并且不动声色的销售最为有效。销售技巧：</p><ol><li>产品本身应当具备销售能力，好的产品本身就是一种推销；</li><li>公司的每个人都是销售，首席执行官应当是公司最好的销售，包揽复杂型销售任务；</li><li>一些简单的销售任务应该组建销售团队来做；</li><li>市场营销和广告对那些缺失病毒式推广方法的低价产品极为有效，对初创公司同样凑效；</li><li>如果产品的核心功能能够鼓励用户邀请其它朋友成为用户，可以采用病毒式营销；</li><li>幂次法则同样适用于销售领域；</li><li>销售除产品以外的东西；</li></ol><h3 id="第十二章-人类和机器"><a href="#第十二章-人类和机器" class="headerlink" title="第十二章 人类和机器"></a>第十二章 人类和机器</h3><p>作者阐述人类和机器的关系。机器会取代人类吗？每个人都在期待机器（这里主要指计算机）能干更多的事情，那么未来还有什么是人类可以做的事情？蒂尔的观点是：1、全球化是替代效应，科技意味着补充。2、人机是互补关系，不是取代关系，进化计算机的能力应该是为了增加人类的能力，而不是去取代人类。</p><h3 id="第十三章-绿色能源"><a href="#第十三章-绿色能源" class="headerlink" title="第十三章 绿色能源"></a>第十三章 绿色能源</h3><p>为何很多新能源公司死掉？需要从以下几个方面来反思：工程问题，你的技术是否是否具备突破性？；现在是否是一个合适的时机来做这件事；团队问题，你有合适的团队来完成和销售你的产品吗；持久问题，是否能再未来的10-20年里保持自己的市场地位；秘密问题，这是否是一个在解决尚未解决的难题的项目。而特斯拉的成功是很好地解决了上述问题。  </p><h3 id="第十四章-创始人的悖论"><a href="#第十四章-创始人的悖论" class="headerlink" title="第十四章 创始人的悖论"></a>第十四章 创始人的悖论</h3><p>这章介绍特立独行的6个PayPal创始人，创始人貌似都拥有一些极端的特质，但事实上并不像他们所表现的那么极端，这些特质可能被夸大了。</p><h3 id="我对创业的一些思考"><a href="#我对创业的一些思考" class="headerlink" title="我对创业的一些思考"></a>我对创业的一些思考</h3><p>创业绝非易事，当今的中国有无数人倒在创业的路上，但鲜有人能停下来对失败进行复盘反思，我们肯定知道世界的最高峰是珠穆朗玛峰，却很少人关注第二高的山峰，在当下的中国，对那些胜利者，我们报以掌声唯成功马首是瞻，对失败者，嗤之以鼻，避而远之；但实际上，我们从失败者身上能学到的远多于成功者；这种风气并不利用养成良好的创业环境，因为创业10有9空，创业从来就没有随随便便的成功。我的一位同事向我推荐了易到创始人周航写的书《重新理解创业：一个创业者的途中思考》，我也推荐大家可以读读这本书，这是周航回过头来对创业的复盘和剖析，对失败的反思总结。我将结合易到及易到失败这个例子能否支撑和验证文中的观点。</p><h4 id="1、定位至关重要"><a href="#1、定位至关重要" class="headerlink" title="1、定位至关重要"></a>1、定位至关重要</h4><p><strong>“Pick a small market and dominate it” - Peter Thiel</strong><br>我没有创过业，但我觉得这句决定值得被划重点，选择很小的一个市场，然后占领它。很多的创业公司在成立的那一天注定了要失败，因为pick这个动作并不是每个人都能拿捏得准，创业的出发点是概念先行还是问题驱动值得仔细思考。拿易到来说，易到的出发点是好的，从真正的解决打车难的问题，这是一个真实存在的需求，而不是为了追赶新概念而衍生出的新项目，这方面的最典型的例子就是打着共享经济概念创造出来的一系列伪需求的创业项目，共享充电宝、共享雨伞…创业应该是以解决实际问题出发，考虑能够提供什么样的差异化产品。那即使你的定位是准确的，你找到了可靠人组成了很棒的团队，你需要时刻把握大方向，你做的决策影响公司的命运，并且还需要在竞争中存活下来…</p><h4 id="2、创业过程的每一个决策都影响公司的未来"><a href="#2、创业过程的每一个决策都影响公司的未来" class="headerlink" title="2、创业过程的每一个决策都影响公司的未来"></a>2、创业过程的每一个决策都影响公司的未来</h4><p>CEO最难的一件事就是做正确的决策。书中的一段话给我很大的启发：“2014年，移动支付把打车当作前沿阵地，巨头的加入让打车市场迅猛加速。即便这样，公司C轮融资的时候，我们本有机会拿到非上市融资里面最大的钱，但我们没要。没过几个月，那笔钱就到了竞争对手手中，这导致易到在之后的补贴大战中过得很悲惨。”如果易到拿了那笔钱，在补贴大战中应该还能有一战之力，我这样说有点事后诸葛，后来的易到找到了乐视这座靠山，但结局是这个选择可能更为致命，易到成功陷入了乐视这个大泥潭。15年10月起，乐视启动了对易到并购式的投资，管理层入驻易到，再后来，原来的创始人被扫地出门。有很多人都问过他，为什么要在那个时候选择乐视的钱？周航的回答是当时的我一定是做了我认为可能是最好的选择，因为放在那个节点上，他已经没有选择的余地。</p><h4 id="3、创业竞争不可避免，唯一能做的就是去赢下这场战争"><a href="#3、创业竞争不可避免，唯一能做的就是去赢下这场战争" class="headerlink" title="3、创业竞争不可避免，唯一能做的就是去赢下这场战争"></a>3、创业竞争不可避免，唯一能做的就是去赢下这场战争</h4><p>竞争应该是创业公司的常态。竞争是全方位的：市场的竞争，人才的竞争，资源的竞争..如果你规避竞争或不重视竞争，你最会越来越被动，失败是必然结果。我有时会想滴滴为什么能走到今天，成为打车行业的独角兽公司（但今年的滴滴过得不好过），滴滴目前已经成为中国最大的互联网公司之一，估值一度达到350亿美元，滴滴在扩张的过程中一路干掉了大黄蜂、快的、滴答拼车、易到、Uber…等30家竞争公司。易到最初的认识是专车和出租车的场景不一样，但实质是一样的，因为不管你叫什么车，你的目的是一致的：到达目的地，而易到在创建后的18月里都没有意识到潜在的竞争对手，并且陷入思维盲区，周航对竞争的认知是：面对竞争最好的方法是不竞争；忽略竞争对手是极为致命的。</p><h4 id="4、创业的首要任务应该是先活下来，而不是追求完美"><a href="#4、创业的首要任务应该是先活下来，而不是追求完美" class="headerlink" title="4、创业的首要任务应该是先活下来，而不是追求完美"></a>4、创业的首要任务应该是先活下来，而不是追求完美</h4><p>创业过程容易犯得一个错就是追求完美。什么都想做、并且做好的一个后果就是造成精力和资源的分散。易到想的太完美了，车要好；司机要好，有口音的不行，抽烟的不行；除了线下好还不够线上App也要好，设计要好，算法要好；可想而知这对一个创业公司来说是最为致命的，拼命解决问题的同时不断得给自己创造了新的问题。另一方面易到把很多资源精力花费在了营销上，这些表面上很酷的东西，实质没有作用。同期的滴滴则大力加强地推，扩大自己的入伙车辆及司机数量，有了车才会有更多的用户，另一方寻求更大资本投入来赢得“补贴战”上的优势。但这一切的前提是你得先活下去。</p><h4 id="5、钱真的是万能的"><a href="#5、钱真的是万能的" class="headerlink" title="5、钱真的是万能的"></a>5、钱真的是万能的</h4><p>就像这本书中说的一样，“<strong>follow the money</strong>”。 永远不要低估资本的力量，胡晓波说的那句话真真实“资本是你屁股后的那根鞭子，融的越多，鞭子越粗，但屁股被抽得越痛。”那什么时候融资？周航给出的答案就是抓住好的时机赶紧去融资，在别人看好你的时候尽量多融资，而可以融多少钱并不是由你的估值决定的，而真正的融资规模应该是你的核心业务需求。对融资这块了解甚少，如果你有这块的经历或经验，欢迎评论补充。  </p><p><strong>“There is no silver bullet”</strong><br>用软件工程的一句名言来结束这篇书评，创业同样没有银弹。那些创业过程中遇到的难题、挑战以及解决方案，应该都不可能在目前市面上所有跟创业有关的书籍中找到，如果有答案，那创业就没有那么难了。创业的法则就应该是：没有法则，真正的难题、挑战永远存在未来未知的世界里。另外，世界上第二高的山峰是乔戈里峰。</p><p>以上，欢迎交流、拍砖 ❤️。  </p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><a href="http://blakemasters.com/peter-thiels-cs183-startup" target="_blank" rel="noopener">1. Blake Masters整理的CS183讲义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com/blog/assets/Zero-To-One/zero-to-one.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这可能是我写的最长的一篇书评，共4587字，TL;DR。 &lt;/p&gt;
&lt;p&gt;这本书的电子版、纸
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>www背后的故事</title>
    <link href="https://wuxinhua.com/2018/11/16/Story-behind-the-www-in-domain/"/>
    <id>https://wuxinhua.com/2018/11/16/Story-behind-the-www-in-domain/</id>
    <published>2018-11-16T13:47:06.000Z</published>
    <updated>2020-12-31T12:01:49.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么存在这个问题"><a href="#为什么存在这个问题" class="headerlink" title="为什么存在这个问题"></a>为什么存在这个问题</h1><p>我在建立我的博客的时候有人跟我说 www 的网站更适合做SEO，而实际上我对这两者的区别并不了解，为什么域名的URL会需要带上www？有的网站二者都能访问，有的却不能？刷推的时候也发现了一个奇怪的账号<a href="https://twitter.com/www_deprecated" target="_blank" rel="noopener">@www_deprecated</a>,现在在主张废弃 www吗？今天这篇文章会概括二者的区别及理清楚背后的原理。</p><h1 id="一些背景知识"><a href="#一些背景知识" class="headerlink" title="一些背景知识"></a>一些背景知识</h1><p>说到 www ，就不得不提万维网，1991年8月6日，世界上诞生了第一个 www (World Wide Web)网站(这个网站至今还可以访问~ =&gt; <a href="http://info.cern.ch/" target="_blank" rel="noopener">http://info.cern.ch/</a>)，发明者来自欧洲核子研究中心（CERN）的蒂姆·博纳斯李（Tim BernersLee），他把Hypertext(超文本)概念和传输协议（也就是我们现在仍在使用的w3c协议）、域名系统绑定在一起，提出了万维网的概念，他还设计了实现了第一个3w 浏览器和 web 服务器。而后续建立的非盈利性的W3C（万维网联盟）对web 进行标准化，创建并维护3w标准，那网站以www开头，是World Wide Web的简称吗？可以这么认为。</p><p>在万维网出现之前，是存在互联网的，但是它并不是用来浏览网页罢了，它被用来干很多事，例如telnet、email、gopher、FTP传输等，在那个时期，人们通常习惯把域名跟功能绑在一起，例如：smtp.example.com代表这是一个使用SMTP协议的邮件服务，ftp.example.com代表这是一个FTP服务器。同样的到了1990年，人们使用 www.example.com 来区分这是个web服务器。</p><h1 id="DNS解析记录"><a href="#DNS解析记录" class="headerlink" title="DNS解析记录"></a>DNS解析记录</h1><p>在网络世界中，我们知道ip地址才是网站或者应用资源的真正地址，但网站的数目很多，如果用IP来访问，使用者很难记住，于是有了域名，我们记住了域名，也就记住了资源的地址；那互联网是如果通过域名找到正确的IP地址呢？这个过程需要使用到DNS服务器，也就是网络世界的通讯地址簿，通过DNS解析把这两者联系起来。 </p><p>域名注册购买后，我们只是拥有了域名的使用权，还无法通过域名直接访问自己的网站，因为互联网只识别IP地址，只有在域名解析服务商处建立域名和IP地址对应关系记录后，才能通过域名访问到该网站。拿阿里云的DNS解析服务来说（并非给阿里云打广告，可自行选择），域名下有个DNS服务器选项，配置阿里的DNS服务器后，它会将网站域名解析成网站的IP地址，从而将最终用户的访问路由到相应的网站或应用资源上。  </p><p>在网址中，http:// 或 https:// 后的第一个子字符串称之为域，也就是网站资源所在服务器的名称，实际上这是不同的两个域，即www是一个子域名，它甚至可以被设置成不同的IP地址。在做域名解析时，我们通常会同时添加两条A记录，分别是www和@，记录值指向同一个IP地址，这样确保加上www和不带www均能访问。</p><h1 id="关于SEO"><a href="#关于SEO" class="headerlink" title="关于SEO"></a>关于SEO</h1><p>www网站真的对SEO更友好？看看谷歌怎么说：</p><blockquote><p>“If you specify your preferred domain as <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> and we find a link to <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a>, we’ll consider both links the same.”  </p></blockquote><p>谷歌说我们的引擎并没有偏向于喜欢抓哪个，那我们能改吗？例如把裸域名网站切换到www域名上？最好不要，加和不加对SEO来说是有很大区别的，因为不加www的域名是主网站，而加上www的相当于一个二级域名，对于搜索引擎来说，example.com和www.example.com完全是两回事，经常更换不利于搜索引擎准确地抓取到内容。</p><h1 id="关于Cookie"><a href="#关于Cookie" class="headerlink" title="关于Cookie"></a>关于Cookie</h1><p>两者带来的一些问题也体现在cookie上，cookie设置在主域名上，也可以传递给子域名，举例：如果主站example.com设置了cookie，那么在访问 www.example.com或email.example时浏览器也能拿到这些cookie，相反如果在www.example.com上设置了cookie，它并不能传递到主域名和其它子域名上<a href="https://tools.ietf.org/html/rfc6265" target="_blank" rel="noopener">RFC6265</a>。带来的问题是在你在共享cookie的同时一方面请求带上并不需要的cookie会影响网页响应性能，另一方面可能存在安全性的问题。如果你坚持使用裸域名的时候，那么cookie会被传递到所有的子域名上，这样还可能导致子域名对静态内容的访问出现问题，例如<a href="https://twitter.com" target="_blank" rel="noopener">Twitter</a>就是使用的裸域名，为了避免这个问题，它使用了另一个新的域名来存放静态资源。</p><h2 id="废弃-www"><a href="#废弃-www" class="headerlink" title="废弃 www"></a>废弃 www</h2><ul><li>不加www的域名更加简短优雅，更容易被记住，加上3w是多余的，意味着你还需要多按下3个w，并且现在大多数的网页在没有www的情况下也能正常访问。  </li><li>多余的字符意味着占用更多的空间和带宽，www 将会额外占用32 bits，在DNS解析这个域名时也将耗费更长的时间。  </li><li>容易造成一些困惑，例如在使用邮箱时，www 不应该出现在邮箱后缀。  </li></ul><h2 id="坚持www"><a href="#坚持www" class="headerlink" title="坚持www"></a>坚持www</h2><ul><li>www 意味着web服务，利用人们理解，对于一些有着悠久历史的网站来说，我认为保留www或许是一个更好的选择。</li><li>如果你的网站需要在cdn上存放、更新静态资源，那么www 子域名是一个很好的选择，有些host服务商裸域名(example.com) 不能使用CNAME记录。  </li><li>另一个是使用www不会带来cookie共享的问题。  </li></ul><p>那用还是不用，这取决于你。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>1、<a href="https://support.google.com/webmasters/answer/44231?hl=zh-Hans" target="_blank" rel="noopener">webmaster 设置首选域使用www还是非www?</a><br>2、<a href="https://www.yes-www.org/why-use-www/" target="_blank" rel="noopener">为什么使用www</a><br>3、<a href="https://stackoverflow.com/questions/486621/when-should-one-use-a-www-subdomain" target="_blank" rel="noopener">When should one use a ‘www’ subdomain?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么存在这个问题&quot;&gt;&lt;a href=&quot;#为什么存在这个问题&quot; class=&quot;headerlink&quot; title=&quot;为什么存在这个问题&quot;&gt;&lt;/a&gt;为什么存在这个问题&lt;/h1&gt;&lt;p&gt;我在建立我的博客的时候有人跟我说 www 的网站更适合做SEO，而实际上我对这两者的
      
    
    </summary>
    
    
      <category term="www domain" scheme="https://wuxinhua.com/tags/www-domain/"/>
    
  </entry>
  
  <entry>
    <title>认识Docker</title>
    <link href="https://wuxinhua.com/2018/09/25/Dive-Into-Docker/"/>
    <id>https://wuxinhua.com/2018/09/25/Dive-Into-Docker/</id>
    <published>2018-09-25T07:18:46.000Z</published>
    <updated>2020-12-31T12:01:49.406Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://assets.wuxinhua.com/blog/assets/dive-into-docker/docker_logo.png" alt="Docker">  </p><p>出于工作的需要，今年才真正开始接触到Docker，买了一些容器相关的书，读了大牛一系列的文章博客，希望深入了解Docker的一些核心概念，Docker运行原理等，并在公司同事的帮助下玩一把容器技术，了解学习Docker最好的方法是阅读<a href="https://docs.docker.com/" target="_blank" rel="noopener">文档</a>，本篇主要记录下这个学习过程中积累的一些知识，通过这篇可以了解到Docker相关的基础知识。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>在介绍Docker前，先了解一下容器的概念：</p><blockquote><p>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</p></blockquote><p>有了容器，把软件运行所需的所有资源(代码和依赖资源)打包到一个隔离的容器中，多个容器能够在一台机器上运行，并且共享操作系统内核。</p><h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><p>根据官方的定义，Docker是世界领先的软件容器平台。</p><blockquote><p>an open platform to build, ship, and run any app, anywhere  </p></blockquote><p>Docker正式发布开源版本是在2013年3月，Docker并不是一项新技术，至今已经走过了5年的历程，最初是 dotCloud 公司创始人 <a href="https://github.com/shykes" target="_blank" rel="noopener">Solomon Hykes</a> 在法国期间发起的一个公司内部项目，dotCloud现已更名为<a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>，Docker以 Go 语言进行开发，核心代码托管在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 平台上,(出于商业化的目的，Docker在2017年已经改名为Moby，具体详见<a href="https://github.com/moby/moby/pull/32691" target="_blank" rel="noopener">pr#32691</a>)，基于Linux内核的 cgroup，namespace 等技术，Docker对进程进行了封装隔离，属于操作系统层面的虚拟化技术，是轻量级的虚拟化技术，与传统的虚拟机比更具优势。Docker容器的特点：</p><ul><li>轻量，一台机器上可以运行多个Docker容器，并且共享这台的操作系统内核。</li><li>标准化，Docker容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows、VM等平台上运行。</li><li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施，Docker默认提供最强的隔离，因此如果某个应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li></ul><h3 id="Docker能为我们做什么"><a href="#Docker能为我们做什么" class="headerlink" title="Docker能为我们做什么"></a>Docker能为我们做什么</h3><p>从Docker公司的员工<a href="https://twitter.com/jpetazzo" target="_blank" rel="noopener">Jérôme Petazzoni</a>分享的slide<a href="https://www.slideshare.net/jpetazzo/docker-automation-for-the-rest-of-us" target="_blank" rel="noopener">Docker: automation for the rest of us</a>中，很明确地说明了Docker为我们做的事情：</p><blockquote><p> Get a well-defined, reproducible environment。<br> Define this environment in a Dockerfile。<br> Build this Dockerfile into a container image。<br> Run this container image anywhere Same behavior, guaranteed 。</p></blockquote><p>Docker是一个提供能在任何地方构建、发布、运行应用的能力的开放平台。通过 Dockerfile 定义一个可复用的环境，并且利用Dockerfile构建容器的镜像，动态运行同一个Dockerfile编译的镜像能够确保容器行为的一致性，开发过程中需要面对的常见一个问题就是环境的构建，经常听到开发调侃说：我这里能跑起来啊！很多时候开发、测试、线上的环境都存在差异，Docker的镜像提供了初内核外的完整运行所需资源，确保了应用运行环境的一致性，所以也不用担心系统的升级、迁移导致的环境变化而无法正常运行的情况。</p><h3 id="虚拟机和Docker容器的区别"><a href="#虚拟机和Docker容器的区别" class="headerlink" title="虚拟机和Docker容器的区别"></a>虚拟机和Docker容器的区别</h3><p>虚拟化技术是使用软件的方法重新定义这些资源，传统的虚拟机技术是虚拟一套硬件后，在上面运行一套完整的操作系统，而容器虚拟化的是操作系统，与虚拟机相比，占用的资源较少，并且更容易移植，效率更高。虚拟机的本质是在物理机上模拟一台或多台逻辑计算机设备，这些计算机可以运行不同的操作系统，互不影响物，而如何管理和动态分配物理机的资源(包括CPU、内存等)，需要再补充一下Hypervisor（也叫Virtual Machine Monitor（VMM））相关技术。  </p><p>Hypervisor 是一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件，可以说是虚拟机的宿主也是监工，Hypervisor 又分为裸机型和主机型，通常我们电脑上装的 VirtualBox 或 Vmware 等属于后者。</p><p>主机型Hypervisor会构建出一整套虚拟硬件平台，注意硬件二字，这些包括CPU/Memory/Storage等，在这个硬件平台上你需要再去安装所需的OS、应用软件等，这样底层的OS和上层的OS是就完全无关了，例如物理机是Windows虚拟出一套Linux的开发环境，代表的有VMware Workstation, VMware Player, VirtualBox等。  </p><p>裸机型Hypervisor去掉了底层的操作系统，通过Hypervisor直接调用物理机的硬件设施。代表的有Xen, Oracle VM Server for SPARC, Microsoft Hyper-V and VMware ESX/ESXi等。</p><p><img src="https://assets.wuxinhua.com/blog/assets/dive-into-docker/vm_vs_docker.png" alt="区别">  </p><p>Docker背后的思想是创建软件程序可移植的轻量容器，让其可以在任何安装了Docker的机器上运行，而不用关心底层操作系统。从这种对比图可以看出（图片截至Docker官网），在虚拟机架构中，最底层是物理架构层，可以是我们的电脑、或者运行在云服务提供商的vps等，上层安装对应的操作系统，而操作系统类型取决于底层物理环境，在操作系统之上即 hypervisor，该层承载一定数量的虚拟机，例如安装每个虚拟机需要800MB的存储空间，那么意味着底层的物理机需要为虚拟机准备 800 * 3的磁盘空间；在之上是每个应用所需的bin、lib包和环境，例如如果APP1是基于NodoJS的web前端应用，可能需要准备例如git、npm、NodeJS、Nginx等运行环境。</p><p>再来看下Docker的架构，底部两层类似于vm，同样需要物理环境、操作系统层，这个host层没有限制，能跑Docker的即可，之上Docker daemon取代了Hypervisor，Docker daemon是一个用于运行在底层OS环境中用于管理任何和Docker相关的服务。在上层类似于vm，相应的lib、bin和我们的App应用，所需的这些会在Dockefile中申明，构建成独立的Docker images镜像， Docker daemon则运行管理这些由images镜像构建生成的容器。  </p><p>总结一下二者的异同：</p><ul><li>Docker 容器并不是轻量的虚拟机，两者有本质上的区别。</li><li>在资源隔离上，虚拟机是高度隔离，而 Docker 达不到虚拟机所能提供的资源隔离水平。</li><li>你可能需要花很长时间去安装虚拟机准备环境，但是花很短时间运行 Docker 容器（毫秒和分钟的区别）。</li><li>在虚拟机架构中，底层OS需要准备额外的资源分配给上层虚拟机，Docker 放弃了虚拟机层的OS，所以 package 会小很多，但并不代表Docker 不存在这个问题，只是没有虚拟机严重罢了，所以更快更轻。</li><li>虚拟机需要硬件虚拟化技术支持，所有只能运行在物理机上，Docker 没有硬件虚拟化，可以运行在物理机、虚拟机、甚至 Docker 里面（Docker in Docker）。</li><li>Docker 运行于Linux上，但目前已经实现在OS X或Windows上运行Docker。</li></ul><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>Docker 有两个很重要的部分：构建前的叫 image 镜像，构建后的是 container 容器。</p><p>Docker 容器使用 cgroup 实现了CPU、内存、文件系统等资源的隔离，那 Docker 没有文件系统怎么运行，其实Docker镜像就是一个特殊的文件系统，镜像文件描述了容器运行所需的初始文件系统，包含所需环境依赖，而镜像是通过 Dockerfile 来构建的，在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由多层文件系统联合组成，镜像是只读的，创建容器是在镜像上新建可写层，不需要复制整个文件系统，因此可以实现毫秒级的创建。</p><p>Docker把整个应用、操作系统、配置打包成一个静态的镜像，这个镜像可以快速得启动、运行、关闭形成一个动态的运行容器，容器可以理解为是镜像运行时的实体。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>通过上面我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。我们把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，而这个脚本就是Dockerfile。Dockerfile提供以下指令，指令具体的参数、用法参见文档：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ADD</span><br><span class="line">COPY</span><br><span class="line">ENV</span><br><span class="line">EXPOSE</span><br><span class="line">FROM</span><br><span class="line">LABEL</span><br><span class="line">STOPSIGNAL</span><br><span class="line">USER</span><br><span class="line">VOLUME</span><br><span class="line">WORKDIR</span><br><span class="line">MAINTAINER</span><br><span class="line">RUN</span><br><span class="line">CMD</span><br><span class="line">ENTRYPOINT</span><br><span class="line">ONBUILD</span><br></pre></td></tr></table></figure></p><p>顺带提一下 .dockerignore 文件，.dockerignore 类似于我们日常使用到的 .gitignore 文件一样，用来排除构建镜像时不需要的文件或目录，在Docker CLI将脚本内容发送给Docker daemon前，它会先寻找.dockerignore文件，如果文件存在，CLI会根据.dockerignore将内容进行过滤，避免在使用ADD、COPY时将体积较大、有影响的文件添加进daemon中。</p><h3 id="Play-With-Docker"><a href="#Play-With-Docker" class="headerlink" title="Play With Docker"></a>Play With Docker</h3><p>在开始前，推荐一下非常炫酷的<a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener">PWD</a>在线实验室上,我在上面简单的实践了一下，Play With Docker(Docker在线实验室) 是一个运行在浏览器中的Docker Playground，无需安装任何环境，就可以在线体验 Docker。进入实验室后点击左侧“增加一个实例”，PWD会帮我们生成一个节点，在面板上会显示当前节点的相关信息：  </p><p><img src="https://assets.wuxinhua.com/blog/assets/dive-into-docker/pwd_portal.png" alt="PWD面板"><br>这里有一个session倒计时，在有效的session内，在新的tab页复制当前链接能同时操作当前节点，厉害了：</p><p><img src="https://assets.wuxinhua.com/blog/assets/dive-into-docker/pwd_session.png" alt="PWD session"></p><p>在命令行输入:  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://assets.wuxinhua.com/blog/assets/dive-into-docker/pwd_helloworld.png" alt="helloworld"><br>Docker daemon会在本地搜索hello-world镜像，没有找到再去远程拉取镜像，并构建容器环境。<br>紧接着我需要在容器中构建Nginx环境，输入：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker  run -d -p 8080:80 nginx</span><br></pre></td></tr></table></figure></p><p>同样的Docker下载镜像并且运行容器，-d将容器置于后端运行，-p用于暴露端口，点击上方<code>8080</code>即可访问web应用路径。  </p><p><img src="https://assets.wuxinhua.com/blog/assets/dive-into-docker/pwd_nginx.png" alt="helloworld">  </p><h3 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h3><h4 id="Nodejs-应用"><a href="#Nodejs-应用" class="headerlink" title="Nodejs 应用"></a>Nodejs 应用</h4><p>又到了程序员最爱的Hello World环节 😆，这个例子足够的简单：我们使用express监听 80 端口，在浏览器端访问后，node端返回Hello world即可,开始我们的docker之旅：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir hello-world</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> hello-world</span><br><span class="line"></span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p>我们只需安装<code>express</code>依赖，创建index.js文件用来启动、监听服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i express --save</span><br><span class="line"></span><br><span class="line">touch index.js .gitignore Dockerfile .dockerignore</span><br></pre></td></tr></table></figure><p>在index.js文件中粘贴以下代码并保存文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> post = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// response Hello world in root url</span></span><br><span class="line">app.get(<span class="string">'/helloworld'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res </span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello world!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen server on port 80</span></span><br><span class="line">app.listen(post, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'App listensing on: '</span> + post)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建.gitignore 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/node_modules</span><br><span class="line">/dist</span><br><span class="line">/package-lock.json</span><br></pre></td></tr></table></figure><p>加入.dockerignore 文件：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git DS_Store etc</span></span><br><span class="line">.git</span><br><span class="line">.svn</span><br><span class="line">.ipynb_checkpoints/*</span><br><span class="line">/DOCUMENTS/*</span><br><span class="line">/notebooks/*</span><br><span class="line">/unused/*</span><br><span class="line">Dockerfile</span><br><span class="line">.DS_Store</span><br><span class="line">.gitignore</span><br><span class="line">README.md</span><br><span class="line">env.*</span><br><span class="line">/devops/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To prevent storing dev/temporary container data</span></span><br><span class="line">*.csv</span><br><span class="line">/tmp/*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> debug</span></span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></p><p>在本地使用 node 运行测试该应用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><h4 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h4><p>我们需要把安装、构建、操作镜像的命令都写入一个脚本，这个脚本就是上面提到的 Dockerfile，Dockerfile命令的使用方法详见<a href="https://docs.docker.com/engine/reference/builder/#usage" target="_blank" rel="noopener">文档</a>，这里我稍微注释了每一行命令的作用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile <span class="keyword">for</span> nodejs image</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MAINTAINER M1seRy &lt;wuxinhua.cn@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Specify the node base image from docker hub.</span></span><br><span class="line">FROM node:6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set working dir <span class="keyword">in</span> the container to /app.</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy package.json to /app directory.</span></span><br><span class="line">COPY package.json /app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install dependencies.</span></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy application file.</span></span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run our application.</span></span><br><span class="line">CMD node index.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> replace this with your application<span class="string">'s default port.</span></span></span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t hello-world .</span><br></pre></td></tr></table></figure><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><p>使用docker run命令运行该镜像，并且暴露本地的8081端口来访问应用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8081:80 -d hello-world</span><br></pre></td></tr></table></figure><p>(以上)</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://en.wikipedia.org/wiki/Hypervisor" target="_blank" rel="noopener">关于Hypervisor</a><br><a href="https://www.youtube.com/watch?v=YFl2mCHdv24&amp;t=204s" target="_blank" rel="noopener">Learn Docker in 12 Minutes 🐳</a><br><a href="https://www.slideshare.net/jpetazzo/docker-automation-for-the-rest-of-us" target="_blank" rel="noopener">docker-automation-for-the-rest-of-us</a><br><a href="https://github.com/hangyan/docker-resources/blob/master/README_zh.md" target="_blank" rel="noopener">docker-resources</a><br><a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener">Play with Docker</a><br><a href="https://coolshell.cn/articles/18190.html" target="_blank" rel="noopener">GO语言、DOCKER 和新技术</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://assets.wuxinhua.com/blog/assets/dive-into-docker/docker_logo.png&quot; alt=&quot;Docker&quot;&gt;  &lt;/p&gt;
&lt;p&gt;出于工作的需要，今年才真正开始接触到Docker，买了一些容
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://wuxinhua.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>contenteditable 踩坑记</title>
    <link href="https://wuxinhua.com/2018/07/05/Contenteditable-The-Good-Part-And-The-Ugly/"/>
    <id>https://wuxinhua.com/2018/07/05/Contenteditable-The-Good-Part-And-The-Ugly/</id>
    <published>2018-07-05T15:33:21.000Z</published>
    <updated>2020-12-31T12:01:49.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于富文本编辑器"><a href="#关于富文本编辑器" class="headerlink" title="关于富文本编辑器"></a>关于富文本编辑器</h2><p>知乎上有个问题<a href="https://www.zhihu.com/question/38699645" target="_blank" rel="noopener">为什么都说富文本编辑器是天坑？</a>,很早就听说了实现一个富文本编辑器需要填很多的坑，“有幸”接触到富文本编辑器，记录下遇到的一些问题及解决方案。  </p><p>富文本编辑器的实现一般有两种：</p><ol><li>通过设置<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable" target="_blank" rel="noopener">contenteditable</a>属性，使得在HTML中的任何元素都可以编辑，加上使用一些JavaScript事件处理逻辑，可以将你的网页转换为完整且快速的富文本编辑器。</li><li>基于<a href="https://draftjs.org/" target="_blank" rel="noopener">Draft.js</a>实现编辑器功能，Draft.js是Facebook开源的开发React富文本编辑器开发框架。<br>而使用contenteditable无疑是最简单的一种方式，但是 DOM 的处理存在很多兼容性的问题，并且处理起来异常麻烦，😢详情查看<a href="https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480" target="_blank" rel="noopener">为什么说contenteditable很糟糕</a>，而这里主要记录使用contenteditable属性实现一个简单编辑器过程的一些坑。</li></ol><p>之所以不直接使用<code>input</code>、<code>textarea</code>，是因为考虑到实现以下功能<code>contenteditable</code>更具有优势：</p><ol><li>输入框的高度无限制，并且自适应</li><li>对一些特定文本进行样式高亮调整等自定义工具栏</li><li>指定位置插入图片、表情等内容</li><li>所见即所得（What you see is what you get）</li></ol><p>伴随而来的就是一堆需要解决的问题(这只是其中的很小的一部分…)：</p><ol><li>placeholder提示语</li><li>获取输入框的内容</li><li>光标位置</li><li>使用delete缩进时，插入多余的dom节点</li></ol><h2 id="placeholder提示语"><a href="#placeholder提示语" class="headerlink" title="placeholder提示语"></a>placeholder提示语</h2><p><code>input</code>和<code>textarea</code>能轻松实现<code>placeholder</code>提示语的效果，但作用于<code>contenteditable</code>的元素，<code>placeholder</code>不起作用，可以通过<code>css</code>的<code>:empty</code>解决：  </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[contenteditable=true]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(placeholder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取输入框的内容"><a href="#获取输入框的内容" class="headerlink" title="获取输入框的内容"></a>获取输入框的内容</h2><p>可以利用<code>innerHTML</code>、<code>innerText</code>、<code>textContent</code>获取输入框的内容，详细对比介绍一下这几个方法：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML" target="_blank" rel="noopener">innerHTML</a> 返回或修改标签之间的内容，包括标签和文本信息，基本上所有浏览器都支持。 </p><p><a href>innerText</a> 打印标签之间的纯文本信息，会将标签过滤掉,此功能最初由Internet Explorer引入，在Firefox上存在兼容问题。</p><h3 id="innerText-textContent"><a href="#innerText-textContent" class="headerlink" title="innerText !== textContent"></a>innerText !== textContent</h3><p><code>innerText</code>和<code>textContent</code>均能获取标签的内容，但二者存在差别，使用的时候还需注意浏览器兼容性：</p><ol><li>textContent会获取style元素里的文本（若有script元素也是这样），而innerText不会</li><li>textContent会保留空行、空格与换行符</li><li>innerText并不是标准，而textContent更早被纳入标准中</li><li>innerText会忽略<code>display: none</code>标签内的内容，textContent则不会</li><li>性能上textContent &gt; innerText</li></ol><p>具体查看下面的例子:</p><iframe height="333" scrolling="no" title="innerHTML vs innerText vs TextContent" src="//codepen.io/amnEs1a/embed/ajmYXo/?height=333&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/amnEs1a/pen/ajmYXo/" target="_blank" rel="noopener">innerHTML vs innerText vs TextContent</a> by kevin (<a href="https://codepen.io/amnEs1a" target="_blank" rel="noopener">@amnEs1a</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h3 id="光标的位置"><a href="#光标的位置" class="headerlink" title="光标的位置"></a>光标的位置</h3><p>首先遇到的一个问题是利用上述方法实现<code>placeholder</code>后，输入框的光标在Firefox中的位置会比其它浏览器要高一截。<br>图片例子来自<a href="https://github.com/yabwe/medium-editor/issues/234" target="_blank" rel="noopener">medium-editor</a>:<br><img src="https://cloud.githubusercontent.com/assets/104138/11337627/a7ef8274-91ee-11e5-8cc7-a999e9b4f19b.gif" alt><br>请在friefox浏览器下查看这个bug<a href="https://jsfiddle.net/wooLksnx/" target="_blank" rel="noopener">https://jsfiddle.net/wooLksnx/</a></p><p>尝试了很多方法来解决均无果，最终发现默认放置 &lt;\br&gt; 标签后，光标位置正常了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rich-editor"</span> <span class="attr">data-placeholder</span>=<span class="string">"Placeholder Text"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我的另一个需求是需要准确地在光标位置的后面插入指定的内容，获取光标位置，然后插入内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getSelection、createRange兼容</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isSupportRange</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">document</span>.createRange === <span class="string">'function'</span> || <span class="keyword">typeof</span> <span class="built_in">window</span>.getSelection === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取光标位置</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getCurrentRange</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> selection = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (isSupportRange()) &#123;</span><br><span class="line">    selection = <span class="built_in">document</span>.getSelection()</span><br><span class="line">    <span class="keyword">if</span> (selection.getRangeAt &amp;&amp; selection.rangeCount) &#123;</span><br><span class="line">      range = <span class="built_in">document</span>.getSelection().getRangeAt(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    range = <span class="built_in">document</span>.selection.createRange()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> range</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入内容</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertHtmlAfterRange</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> selection = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> range = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (isSupportRange()) &#123;</span><br><span class="line">    <span class="comment">// IE &gt; 9 and 其它浏览器</span></span><br><span class="line">    selection = <span class="built_in">document</span>.getSelection()</span><br><span class="line">    <span class="keyword">if</span> (selection.getRangeAt &amp;&amp; selection.rangeCount) &#123;</span><br><span class="line">      <span class="keyword">let</span> fragment, node, lastNode</span><br><span class="line">      range = selection.getRangeAt(<span class="number">0</span>)</span><br><span class="line">      range.deleteContents()</span><br><span class="line">      <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span><br><span class="line">      el.innerHTML = html</span><br><span class="line">      <span class="comment">// 创建空文档对象,IE &gt; 8支持documentFragment</span></span><br><span class="line">      fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> ((node = el.firstChild)) &#123;</span><br><span class="line">        lastNode = fragment.appendChild(node)</span><br><span class="line">      &#125;</span><br><span class="line">      range.insertNode(fragment)</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (lastNode) &#123;</span><br><span class="line">        range = range.cloneRange()</span><br><span class="line">        range.setStartAfter(lastNode)</span><br><span class="line">        range.collapse(<span class="literal">true</span>)</span><br><span class="line">        selection.removeAllRanges()</span><br><span class="line">        selection.addRange(range)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection &amp;&amp; <span class="built_in">document</span>.selection.type != <span class="string">'Control'</span>) &#123;</span><br><span class="line">    <span class="comment">// IE &lt; 9</span></span><br><span class="line">    <span class="built_in">document</span>.selection.createRange().pasteHTML(html)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用delete缩进时，Chrome插入多余的dom节点"><a href="#使用delete缩进时，Chrome插入多余的dom节点" class="headerlink" title="使用delete缩进时，Chrome插入多余的dom节点"></a>使用<strong>delete</strong>缩进时，Chrome插入多余的dom节点</h3><p>发现的另一个<code>bug</code>是在编辑器进行删除缩进操作时，浏览器会在<code>dom</code>节点中插入节点。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是第一行的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是第二行的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当年使用<code>delete</code>进行缩进成一行时，其它浏览器正常显示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是第一行的内容这是第二行的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而Chrome会插入span标签，并且带上继承的一些style属性，font-family, font-size, line-height等：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是第一行的内容<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"line-height: 1.5em"</span>&gt;</span>这是第二行的内容<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案是使用方法动态移除这些多余的标签，如<a href="http://jsfiddle.net/THPmr/6/" target="_blank" rel="noopener">http://jsfiddle.net/THPmr/6/</a>。</p><p>参考的一些资料：  </p><ol><li><a href="http://kellegous.com/j/2013/02/27/innertext-vs-textcontent/" target="_blank" rel="noopener">INNERTEXT VS. TEXTCONTENT</a></li><li><a href="https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480" target="_blank" rel="noopener">Why ContentEditable is Terrible</a></li><li><a href="https://www.neotericdesign.com/articles/2013/3/working-around-chrome-s-contenteditable-span-bug" target="_blank" rel="noopener">Working around Chrome’s contenteditable span bug</a></li></ol><p>几款不错的开源富文本编辑器：   </p><ol><li><a href="https://github.com/yabwe/medium-editor" target="_blank" rel="noopener">medium-editor</a></li><li><a href="https://github.com/wangfupeng1988/wangEditor" target="_blank" rel="noopener">wangEditor —— 轻量级web富文本框</a> </li></ol><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于富文本编辑器&quot;&gt;&lt;a href=&quot;#关于富文本编辑器&quot; class=&quot;headerlink&quot; title=&quot;关于富文本编辑器&quot;&gt;&lt;/a&gt;关于富文本编辑器&lt;/h2&gt;&lt;p&gt;知乎上有个问题&lt;a href=&quot;https://www.zhihu.com/question
      
    
    </summary>
    
    
      <category term="contenteditable,富文本编辑器,踩坑" scheme="https://wuxinhua.com/tags/contenteditable-%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Good Code vs Bad Code in Golang</title>
    <link href="https://wuxinhua.com/2018/04/30/Good-Code-vs-Bad-Code-in-Golang(%E7%BF%BB%E8%AF%91)/"/>
    <id>https://wuxinhua.com/2018/04/30/Good-Code-vs-Bad-Code-in-Golang(翻译)/</id>
    <published>2018-04-30T06:04:21.000Z</published>
    <updated>2020-12-31T12:01:49.407Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习<code>Go</code>，也顺便在<a href="https://studygolang.com/gctt" target="_blank" rel="noopener">GCTT</a>社区帮忙翻译了一些文章。</p><p>原文地址：<a href="https://teivah.io/blog/good-code-vs-bad-code-in-golang/" target="_blank" rel="noopener">Good Code vs Bad Code in Golang</a><br>作者：<a href="https://teivah.io/" target="_blank" rel="noopener">Teivah Harsanyi</a></p><p>最近我被问到关于<code>Golang</code>好代码和不好的代码的一些细节问题，我发现这个问题非常有趣，有趣到可以就这个问题写一篇文章。为了阐明我的观点，我举了一些我在<code>Air Traffic Management</code>（<code>ATM</code>）航空交通管制领域的代码例子，这些代码托管在<a href="https://github.com/teivah/golang-good-code-bad-code" target="_blank" rel="noopener">Github</a>上。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先，简短地描述一下项目的背景。</p><p><code>Eurocontrol</code>(欧洲航管组织)是一个管理欧洲各国航空交通的组织。<code>Eurocontrol</code>和<code>Air Navigation Service Provider</code>(<code>ANSP</code>)之间共同的数据交换网络称为<code>AFTN</code>。这个网络主要用来交换两种格式的信息： <code>ADEXP</code> 和 <code>ICAO</code>(国际民航组织)格式信息。每一种信息都有它们自己的语法格式，但在语义上，或多或少它们是相同的。在这个背景下，性能必须是实现的关键因素。</p><p>这个项目需要提供基于<code>GO</code>语言的用于转换<code>ADEXP</code>格式信息的两种实现(<code>ICAO</code>格式的转换并没有体现在这次对比中)：</p><ul><li><p>不好的实现方式（<code>package</code>包名：<a href="https://github.com/teivah/golang-good-code-bad-code/tree/master/bad" target="_blank" rel="noopener">bad</a>）  </p></li><li><p>重构之后的实现方式（<code>package</code>包名：<a href="https://github.com/teivah/golang-good-code-bad-code/tree/master/good" target="_blank" rel="noopener">good</a>）  </p></li><li><p><code>ADEXP</code>格式的信息例子可以在<a href="https://raw.githubusercontent.com/teivah/golang-good-code-bad-code/master/resources/tests/adexp.txt" target="_blank" rel="noopener">这里</a>找到。</p></li></ul><p>这次对比的结构里，在<code>ADEXP</code>信息中，解析处理部分只是一个子集，至今它仍然跟<code>Go</code>中常见的一些错误有关系。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>概括地讲，一个<code>ADEXP</code>信息是一个<code>tokens</code>的集合，可以是下面任意一种：</p><ul><li><p>简单的</p><blockquote><p>-ARCID ACA878</p></blockquote></li></ul><p>代表<code>ARCID</code>(航班<code>ID</code>) 是<code>ACA878</code>。</p><ul><li><p>循环的</p><blockquote><p>-EETFIR EHAA 0853<br> -EETFIR EBBU 0908</p></blockquote></li></ul><p>这个例子代表的是一个<code>FIR</code>(飞行情报区)列表，第一个航班是<code>EHAA 0853</code>,第二个<code>EBBU 0908</code>。</p><ul><li><p>复杂的</p><blockquote><p>-GEO -GEOID GEO01 -LATTD 490000N -LONGTD 0500000W<br>-GEO -GEOID GEO02 -LATTD 500000N -LONGTD 0400000W</p></blockquote></li></ul><p>一个循环的<code>tockens</code>列表，每一行包含一个子<code>token</code>列表（在这个例子中是<code>GEOID</code>， <code>LATTD</code>， <code>LONGTD</code>）。</p><p>结合项目背景，实现一个并行执行的转化代码变得很重要。所以有以下算法：</p><ul><li><p>实现一个对输入进行清理和重新排列的预处理过程（我们需要清除可能存在的空格，重新排列例如<code>COMMENT</code>等的多行<code>tokens</code>）</p></li><li><p>然后分割每一行至一个协程中。每一个协程将会负责处理一行<code>tokens</code>，并且返回结果。</p></li><li><p>最后一个步骤同样重要，整合结果并且返回一个<code>Message</code>消息)结构体，这是一个公共的结构，不管是<code>ADEXP</code>还是<code>ICAO</code>类型的信息。</p></li></ul><p>每一个包包含一个<code>adexp.go</code>文件暴露主要的<code>ParseAdexpMessage()</code>方法。</p><h2 id="逐步对比"><a href="#逐步对比" class="headerlink" title="逐步对比"></a>逐步对比</h2><p>现在我们逐步来看下我认为的不好的代码，并且我是如何重构它的。</p><h2 id="String类型-vs-byte类型"><a href="#String类型-vs-byte类型" class="headerlink" title="String类型 vs  []byte类型"></a>String类型 vs  []byte类型</h2><p>限制输入类型为字符串类型并不好。<code>Go</code>对<code>byte</code>类型的处理提供了强大的支持（例如基础的<code>trim</code>, <code>regexp</code>等），并且输入将会很大程度上类似于<code>[]byte</code>(鉴于<code>AFTN</code>信息是通过<code>TCP</code>协议来接收的)，实际上没有理由强制要求字符串类型的输入。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误的处理实现有点糟糕。</p><p>我们会发现忽视了在第二个参数中返回的一些可能存在的错误：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">preprocessed, _ := preprocess(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure><p>好的实现方式是捕获每一个可能的错误：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">preprocessed, err := preprocess(bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Message&#123;&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在下面这种不好的代码中也能找到犯的一些错误：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"Input is empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个错误是语法上的。根据Go的语法，错误提示的字符串既不是大写也不是以标点符号结尾。</p><p>第二个错误是如果一个错误信息是一个简单的字符串常量（不需要格式化），使用轻量的<code>errors.New()</code>性能会更好。</p><p>好的实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"input is empty"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免嵌套"><a href="#避免嵌套" class="headerlink" title="避免嵌套"></a>避免嵌套</h2><p> <code>mapLine()</code>函数就是一个很好的例子来说明避免嵌套调用。不好的代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapLine</span><span class="params">(msg *Message, in <span class="keyword">string</span>, ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !startWith(in, stringComment) &#123;</span><br><span class="line">        token, value := parseLine(in)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">""</span> &#123;</span><br><span class="line">            f, contains := factory[<span class="keyword">string</span>(token)]</span><br><span class="line">            <span class="keyword">if</span> !contains &#123;</span><br><span class="line">                ch &lt;- <span class="string">"ok"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data := f(token, value)</span><br><span class="line">                enrichMessage(msg, data)</span><br><span class="line">                ch &lt;- <span class="string">"ok"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ch &lt;- <span class="string">"ok"</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ch &lt;- <span class="string">"ok"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反，好的代码表示得很清晰：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapLine</span><span class="params">(in []<span class="keyword">byte</span>, ch <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Filter empty lines and comment lines</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(in) == <span class="number">0</span> || startWith(in, bytesComment) &#123;</span><br><span class="line">        ch &lt;- <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token, value := parseLine(in)</span><br><span class="line">    <span class="keyword">if</span> token == <span class="literal">nil</span> &#123;</span><br><span class="line">        ch &lt;- <span class="literal">nil</span></span><br><span class="line">        log.Warnf(<span class="string">"Token name is empty on line %v"</span>, <span class="keyword">string</span>(in))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sToken := <span class="keyword">string</span>(token)</span><br><span class="line">    <span class="keyword">if</span> f, contains := factory[sToken]; contains &#123;</span><br><span class="line">        ch &lt;- f(sToken, value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Warnf(<span class="string">"Token %v is not managed by the parser"</span>, <span class="keyword">string</span>(in))</span><br><span class="line">    ch &lt;- <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我看来，这使得代码易读性更强。此外，这种扁平化的处理方式也应该加到错误捕获代码中，下面的例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, err := f1()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    b, err := f2()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该被修改成：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, err := f1()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">b, err := f2()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>同样，第二段代码的可读性更好。</p><h2 id="传值采用value还是reference"><a href="#传值采用value还是reference" class="headerlink" title="传值采用value还是reference"></a>传值采用value还是reference</h2><p>预处理方法的实现并不好：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preprocess</span><span class="params">(in container)</span> <span class="params">(container, error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合项目的背景来说(考虑性能)，考虑到一个信息的结构体有可能会比较大，更好的方式是在<code>container</code>结构内传入指针，否则，在上面例子的代码中<code>container</code>的值将会在每一次调用的时候被覆盖掉。</p><p>好的实现代码将不会有这个问题因为它单个的处理方式(一个简单的24字节的结构，不管什么类型数据)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func preprocess(in []byte) ([][]byte, error) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更广泛地说，无论是根据引用还是数值传递参数都不是一个符合语言习惯的用法。通过数值传递数据也能帮助确定一个方法将不会带来任何的副作用（就像在函数的输入中传递数据一样）。这样做有几个好处，例如单元测试、在代码并发上的重构（否则我们需要检查每个子函数来确定传递是否完成）</p><p>我确信这种这种写法需要根据实际项目背景小心地使用。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>不好的实现方式源于一个最初的好的想法：利用协程并发处理数据（一个协程处理一行）。</p><p>这导致了在一个协程里反复调用<code>mapLine()</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i := 0; i &lt; len(lines); i++ &#123;</span><br><span class="line">    go mapLine(&amp;msg, lines[i], ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapLine()</code>方法三个参数：</p><p>- 返回指向最后一个<code>Message</code>结构的指针。这意味着每个<code>mapLine()</code>将会被同一个变量填充。</p><ul><li><p>当前行</p></li><li><p>一个<code>channel</code>通道用于处理行完成时发送消息</p></li></ul><p>为了共享<code>Message</code>消息而去传递一个指针违背了Go基本原则：</p><blockquote><p>不要通过共享内存来通信，而应该通过通信来共享内存</p></blockquote><p>传递共享的变量有两个主要的缺点：</p><ul><li>缺点 #1：分割一致的修饰</li></ul><p>因为结构中包含一些切片可以被同时修改（同时被两个或者更多的协程）我们得处理互斥的问题。</p><p>例如，<code>Message</code>消息结构包含一个<code>Estdata []estdata</code>，通过加上另一个<code>estdata</code>修改这部分必须像下面这样处理：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutexEstdata.Lock()</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> value &#123;</span><br><span class="line">    fl := extractFlightLevel(v[subtokenFl])</span><br><span class="line">    msg.Estdata = <span class="built_in">append</span>(msg.Estdata, estdata&#123;v[subtokenPtid], v[subtokenEto], fl&#125;)</span><br><span class="line">&#125;</span><br><span class="line">mutexEstdata.Unlock()</span><br></pre></td></tr></table></figure><p>事实上，排除特定用法，在协程中使用<code>mutex</code>(互斥锁)并不是一个好的选择。</p><ul><li>缺点 #2：伪共享</li></ul><p>通过线程或者协程分享内存并不是一个好的方式因为可能存在伪共享（一个在<code>CPU</code>缓存中的进程可以被另一个<code>CPU</code>缓存)。这意味着我们需要尽可能地避免通过线程和协程来共享那些需要修改的变量。</p><p>在这个例子中，虽然，我不认为伪共享在输入的文件教少的情况下有一个很大的影响（在<code>Message</code>消息结构体中增加文件的性能测试结果或多或少是一样的），但在我看来这也是一个很重要的需要牢记的点。<br><br>现在让我们来看下好的并发处理：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> in &#123;</span><br><span class="line">    <span class="keyword">go</span> mapLine(line, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>mapLine()</code>只接受两个参数：</p><ul><li><p>当前行</p></li><li><p><code>channel</code>通道，当前行处理完后，这里的通道不再简单地用来发生消息，也用来传送实际的结果。这意味着不应该使用协程去修改最后的消息结构。</p></li></ul><p>结果在父级的协程中整合。（产生的<code>mapLine()</code>方法在各自的协程中被调用）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">msg := Message&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> in &#123;</span><br><span class="line">    data := &lt;-ch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="comment">// Modify msg variable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码更加一致，在我看来，根据<code>Go</code>的原则：通过通信来共享内存。通过单一的协程来修改消息变量防止了可能由于并发导致的修改和伪共享问题。</p><p>这部分代码潜在的问题是造成了每一行一个协程，这种实现将能够运行，因为<code>ADEXP</code>信息行数将不会太大，在这个简单实现中，一个请求将产生一个协程，在生成能力上将无法考量。一个更好的选择是创建一个协程池来复用协程。</p><h2 id="行处理通知"><a href="#行处理通知" class="headerlink" title="行处理通知"></a>行处理通知</h2><p>在上面不好的代码中，一旦<code>mapLine()</code>处理完一行，我们需要在父级的协程中进行标识。这部分将通过使用<code>chan string</code>通道和方法的调用：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="string">"ok"</span></span><br></pre></td></tr></table></figure><p>因为父级协程并不会检查通道传过来的结果，较好的处理是通过<code>chan struct{}</code>使用<code>ch &lt;- struct{}{}</code>，或者更好的选择(<code>GC</code>会更差)是通过<code>chan interface{}</code>使用<code>ch &lt;- nil</code>处理。</p><p>另一个类似的方法（在我看来甚至会更简洁）是使用<code>sync.WaitGroup</code>，因为当每一个<code>mapLine()</code>执行完了，父级的协程还需继续运行。</p><h2 id="If条件判断"><a href="#If条件判断" class="headerlink" title="If条件判断"></a>If条件判断</h2><p>在<code>Go</code>的条件判断语句中，允许在条件前进行赋值。</p><p>一个改进版的代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, contains := factory[<span class="keyword">string</span>(token)]</span><br><span class="line"><span class="keyword">if</span> contains &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f, contains := factory[sToken]; contains &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码的可读性更高。</p><h2 id="Switch选择"><a href="#Switch选择" class="headerlink" title="Switch选择"></a>Switch选择</h2><p>代码中犯得另一个错误是没有设置<code>switch</code>中的<code>default</code>选项：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> simpleToken.token &#123;</span><br><span class="line"><span class="keyword">case</span> tokenTitle:</span><br><span class="line">    msg.Title = value</span><br><span class="line"><span class="keyword">case</span> tokenAdep:</span><br><span class="line">    msg.Adep = value</span><br><span class="line"><span class="keyword">case</span> tokenAltnz:</span><br><span class="line">    msg.Alternate = value </span><br><span class="line"><span class="comment">// Other cases</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>如果开发者能够考虑到所有的情况，<code>switch</code>的<code>default</code>项是可选的，但是像下面这样捕获特殊的情况肯定会更好。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> simpleToken.token &#123;</span><br><span class="line"><span class="keyword">case</span> tokenTitle:</span><br><span class="line">    msg.Title = value</span><br><span class="line"><span class="keyword">case</span> tokenAdep:</span><br><span class="line">    msg.Adep = value</span><br><span class="line"><span class="keyword">case</span> tokenAltnz:</span><br><span class="line">    msg.Alternate = value</span><br><span class="line"><span class="comment">// Other cases    </span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    log.Errorf(<span class="string">"unexpected token type %v"</span>, simpleToken.token)</span><br><span class="line">    <span class="keyword">return</span> Message&#123;&#125;, fmt.Errorf(<span class="string">"unexpected token type %v"</span>, simpleToken.token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<code>default</code>选项会帮助开发者捕获开发过程中可能造成的<code>bugs</code>。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><code>parseComplexLines()</code>是一个解析复杂<code>token</code>的方法，在不好的代码中是使用递归来处理：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseComplexLines</span><span class="params">(in <span class="keyword">string</span>, currentMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">out []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> []<span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    match := regexpSubfield.Find([]<span class="keyword">byte</span>(in))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> match == <span class="literal">nil</span> &#123;</span><br><span class="line">        out = <span class="built_in">append</span>(out, currentMap)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sub := <span class="keyword">string</span>(match)</span><br><span class="line"></span><br><span class="line">    h, l := parseLine(sub)</span><br><span class="line"></span><br><span class="line">    _, contains := currentMap[<span class="keyword">string</span>(h)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> contains &#123;</span><br><span class="line">        out = <span class="built_in">append</span>(out, currentMap)</span><br><span class="line">        currentMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentMap[<span class="keyword">string</span>(h)] = <span class="keyword">string</span>(strings.Trim(l, stringEmpty))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parseComplexLines(in[<span class="built_in">len</span>(sub):], currentMap, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>Go</code>不支持尾调用优化递归，好的代码使用迭代算法能得到同样的结果：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseComplexToken</span><span class="params">(token <span class="keyword">string</span>, value []<span class="keyword">byte</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warnf(<span class="string">"Empty value"</span>)</span><br><span class="line">        <span class="keyword">return</span> complexToken&#123;token, <span class="literal">nil</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> v []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">    currentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    matches := regexpSubfield.FindAll(value, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, sub := <span class="keyword">range</span> matches &#123;</span><br><span class="line">        h, l := parseLine(sub)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _, contains := currentMap[<span class="keyword">string</span>(h)]; contains &#123;</span><br><span class="line">            v = <span class="built_in">append</span>(v, currentMap)</span><br><span class="line">            currentMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentMap[<span class="keyword">string</span>(h)] = <span class="keyword">string</span>(bytes.Trim(l, stringEmpty))</span><br><span class="line">    &#125;</span><br><span class="line">    v = <span class="built_in">append</span>(v, currentMap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> complexToken&#123;token, v&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种写法在性能上会优于第一种。</p><h2 id="常量管理"><a href="#常量管理" class="headerlink" title="常量管理"></a>常量管理</h2><p>我们需要管理一个常量来区分<code>ADEXP</code>和<code>ICAO</code>类型的消息。不好的写法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AdexpType = <span class="number">0</span> <span class="comment">// TODO constant</span></span><br><span class="line">    IcaoType  = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">反之，利用`</span>Go<span class="string">`的`</span><span class="literal">iota</span><span class="string">`（常量计数器）能写出更优雅的代码：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>Go</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AdexpType = <span class="literal">iota</span></span><br><span class="line">    IcaoType </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>输出的结果是一致的，但是规避了可能存在的错误。</p><h2 id="接收方法"><a href="#接收方法" class="headerlink" title="接收方法"></a>接收方法</h2><p>每个转换提供一个函数来判断每个<code>Message</code>是非涉及到上一个级别（至少在350级以上的路线点）</p><p>不好的代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUpperLevel</span><span class="params">(m Message)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> m.RoutePoints &#123;</span><br><span class="line">        <span class="keyword">if</span> r.FlightLevel &gt; upperLevel &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意味着我们必须把<code>Message</code>当函数的参数。反之，好的代码是提供一个简单的函数作为<code>Message</code>的接收者。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Message)</span> <span class="title">IsUpperLevel</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> m.RoutePoints &#123;</span><br><span class="line">        <span class="keyword">if</span> r.FlightLevel &gt; upperLevel &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是更可取的，我们简单地让消息实现了一个特定的行为。这也是使用<code>Go</code>实现接口的第一步，如果某天我们需要创建另一个同一行为(<code>IsUpperLevel()</code>)的结构，这部分代码不需要被重构（因为<code>Message</code>已经继承该行为）。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释这部分的问题很明显，但是不好的注释很少被提及。</p><p>另一方面，在真实项目中我尝试着去做很好的注释，尽管我并不是那种每行都会注释的人，我依然相信至少在每个函数和在一个复杂的函数的核心部分写上注释是非常重要的事情。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Split each line in a goroutine</span></span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> in &#123;</span><br><span class="line">    <span class="keyword">go</span> mapLine(line, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := Message&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gather the goroutine results</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> in &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释中提供一个另外的例子也会提供很大的帮助：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parse a line by returning the header (token name) and the value. </span></span><br><span class="line"><span class="comment">// Example: -COMMENT TEST must returns COMMENT and TEST (in byte slices)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseLine</span><span class="params">(in []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的一个额外的例子对另一个开发者更好地了解当前这个项目很有帮助。</p><p>最后同样重要的，根据<code>Go</code>的最佳实践，包本身也需要注释。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Package good is a library for parsing the ADEXP messages.</span></span><br><span class="line"><span class="comment">An intermediate format Message is built by the parser.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> good</span><br></pre></td></tr></table></figure><h2 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h2><p>另一个很明显的问题是在缺少日志处理。因为我并不喜欢<code>Go</code>提供的标准日志<code>package</code>包，我在这个项目中使用一个叫<code>logrus</code>第三方的日志包。</p><h2 id="go的fmt包"><a href="#go的fmt包" class="headerlink" title="go的fmt包"></a>go的fmt包</h2><p><code>Go</code>提供一个强力的工具集<code>go fmt</code>。遗憾的是我们忘记去利用它。</p><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p><code>DDD</code>带来了通用语言的概念，以强调所有项目之间共享语言的重要性(<code>business experts</code>, <code>dev</code>, <code>testers</code> 等)。</p><p>这点在这个项目上可能无法衡量，但是从整个项目的可维护性上来考虑，保持一个简单的兼容上下文结构的<code>Message</code>也是重要的一点。</p><p>#性能结果</p><p>在<code>i7-7700 4x 3.60Ghz</code>的硬件环境下，我通过基准测试来对比两种代码：</p><ul><li><p>好的代码： 60430 ns/op</p></li><li><p>不好的代码： 45996 ns/op</p></li></ul><p>不好的代码比好的代码慢了超过30%。</p><p>#结论</p><p>在我看来，要对好的代码和不好的代码给出一个普遍的定义非常难。在一个环境中，一段代码可以被认为是好的代码，但在另一个环境中可能被认为是不好的代码。</p><p>一个很明显的特征就是好的代码在给定的环境中能很好地解决问题，如果代码高效，但是不满足需求，那也是徒劳。</p><p>同时，考虑代码的简洁、可维护性、高效对开发者来说非常重要。</p><blockquote><p>性能的提升伴随着代码复杂性的增加。</p></blockquote><p>一个好的开发者能够在给定的环境中在上面这些特征里找到一个平衡。就像在<code>DDD</code>里,<code>context</code>就是解决方案🙂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习&lt;code&gt;Go&lt;/code&gt;，也顺便在&lt;a href=&quot;https://studygolang.com/gctt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GCTT&lt;/a&gt;社区帮忙翻译了一些文章。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于React的几道面试题</title>
    <link href="https://wuxinhua.com/2018/03/17/The-questions-about-react-and-redux-in-interview/"/>
    <id>https://wuxinhua.com/2018/03/17/The-questions-about-react-and-redux-in-interview/</id>
    <published>2018-03-16T16:02:20.000Z</published>
    <updated>2020-12-31T12:01:49.412Z</updated>
    
    <content type="html"><![CDATA[<p>面试的过程也是一个学习的过程，能够及时定位到自己的知识盲点或者掌握得不够好的地方，这篇内容是对一些React面试题的思考总结。<br>一个合格的开发者，不应该满足于写出机器可运行的代码，而应该试着去理解代码背后的一些原理和思想，我用React开发移动端应用也是一边摸索学习一边实践的过程，期间我犯了很多错误，也学习到了很多东西，我以为我应该能hold住React的这些问题，但在面试过程中，我的回答并不总是让面试官满意，甚至有些偏差，所以我总结了一下近期几次面试中问到的React相关的问题，我希望在学习React的过程中能帮到你，避免犯同样的错误，也许问下面这些问题并不是最好的方法来证明一个开发者是否精通React，但这些题可以从一定程度上了解到候选人对React的掌握情况。  </p><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ol><li><a href="#关于setState？">关于setState</a></li><li><a href="#props和state的区别？">props和state的区别</a></li><li><a href="#无状态组件和状态组件？">无状态组件和状态组件？</a></li><li><a href="#Virtual Dom的对比过程？">Virtual Dom的对比过程</a></li><li><a href="#关于React组件的生命周期？">关于React组件的生命周期</a></li><li><a href="#生命周期的哪个阶段异步请求数据？">生命周期的哪个阶段异步请求数据</a></li><li><a href="#什么是高阶组件(HOC">什么是高阶组件(HOC)</a>？)</li><li><a href="#React如果处理事件绑定？">React如果处理事件绑定</a>  </li><li><a href="#key如何选择？">key如何选择</a></li></ol><h5 id="关于setState？"><a href="#关于setState？" class="headerlink" title="关于setState？"></a>关于setState？</h5><p><strong>1.调用setState后发生了什么?</strong>  </p><p>调用setState后，视图层会进行一次刷新，这背后到底发生了哪些事情？<br>当对象作为参数执行setState时，React内部会以一种对象合并的方式来批量更新组件的状态，类似于Object.assign()，把需要更新的state合并后放入状态队列，利用这个队列可以更加高效的批量更新state；当参数为函数时，React会将所有更新组成队列，并且按顺序来执行，这样避免了将state合并成一个对象的问题，之后会启动一个<code>reconciliation</code>调和过程，即创建一个新的 React Element tree（UI层面的对象表示）并且和之前的tree作比较，基于你传递给setState的对象找出发生的变化，最后更新DOM中需改动的部分。</p><p><strong>2.setState为什么是异步的？</strong><br>从一个例子来看setState的异步：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  add(value)&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      counter: <span class="keyword">this</span>.state.counter + value</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.counter);</span><br><span class="line">    <span class="comment">// 第一次点击console输出0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p onClick=&#123;() =&gt; <span class="keyword">this</span>.add(<span class="number">1</span>)&#125;&gt;</span><br><span class="line">          Click to change the value.</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如在上面的代码中，点击打印出来的counter值是0，setState之后并没有立即更新counter的值，那么如果确保拿到的counter是更新过的呢？有两种解决方法：<br>1.利用setState的第二个参数设置回调函数，setState调用后会触发执行这个callback函数； </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(value)&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter+value</span><br><span class="line">  &#125;, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.state.counter);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.利用setTimeout  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.state.counter)&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>官方的解释说可以把setState看作是一个请求，而不是更新的命令，为了获得更好的性能，React会延迟更新操作，达到一次更新几个组件的目的；React的setState是异步的，有人提出质疑，这是历史原因导致的？还是说当初有意设计成异步的？<a href="https://github.com/gaearon" target="_blank" rel="noopener">@gaearon</a>对这个问题做了回应<a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710" target="_blank" rel="noopener">issue#11527</a>，总结一下是出于以下几个目的：</p><ol><li>保持内部的一致性，跟props一样；</li><li>在许多情况下，setState的同步渲染效率不高，异步可以将几个更新合并，提高效率；</li><li>并不仅仅是出于优化方面的考虑，可以利用异步特征去做其他的事，例如你的navigator路由足够快，你跳转到别的页面了，还是能继续执行异步操作；</li></ol><p><strong>3.setState的两种使用方式？</strong><br>除了上面这种传入新的对象外，还可以使用方法作为参数来更新state，<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">@DanAbramov</a>之前在twitter上的<a href="https://twitter.com/dan_abramov/status/824309659775467527" target="_blank" rel="noopener">status</a>也解释了这一个方法；<br><img src="https://assets.wuxinhua.com/setState.jpg" alt><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">  add(value)&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;<span class="attr">counter</span>: prevState.counter+value&#125;))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.counter);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>setState() 接受一個function(state, props)作為参数传入，两个参数对应的是之前的state和props，之所以还要加入这一种方式，最主要的原因是setState的异步更新，当我们以传入对象的方式，并且多次调用setState方法的时候，实际上React做的是批量处理，React会合并这些Object，但是Object.assign在合并对象的时候，如果遇到keys相同，后面的value值会覆盖掉前面的，例如下面的示例代码，这是我理解的为什么调用三次setState目标值却只更新了一次的原因。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">counter</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  b = &#123;<span class="attr">counter</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  c = &#123; <span class="attr">counter</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b, c);</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// &#123;counter: 3&#125;</span></span><br></pre></td></tr></table></figure><p>二者主要的区别在于：</p><ol><li>如果是通过传入Object来计算next state，并不是安全的，this.props和this.state不是同步地被更新；</li><li>如果在一个方法内多次调用setState()，并不会执行多次的setState，但是如果是传入的function,这些function会被React塞到队列中，并且按顺序依次执行，具体可以查看下面的代码例子；  </li><li>在function方式下，我们的更新操作就不一定需要写在当前Class里，并且如果我们需要额外的参数来计算或者操作下一步的state的时候，还可以使用闭包：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyAdd</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"> preState, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: preState.counter + value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe height="466" scrolling="no" title="setState with Function" src="//codepen.io/amnEs1a/embed/LdyPdZ/?height=466&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/amnEs1a/pen/LdyPdZ/" target="_blank" rel="noopener">setState with Function</a> by kevin (<a href="https://codepen.io/amnEs1a" target="_blank" rel="noopener">@amnEs1a</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h5 id="props和state的区别？"><a href="#props和state的区别？" class="headerlink" title="props和state的区别？"></a>props和state的区别？</h5><p>在React中，数据总是单向地自上往下流动，组件中的一些状态或者数据的管理有时让人很头疼，尤其是在设计一些组件的时候，props是properties的缩写，可以认为是组件的属性，他们从上级获取，并且是不能改变的，如果想要改变props值，只能在父级组件中修改，然后传递给子组件。</p><table><thead><tr><th>场景</th><th>props</th><th>state</th></tr></thead><tbody><tr><td>是否可以从父组件中获取初始值</td><td>可以</td><td>可以</td></tr><tr><td>是否能被父组件改变</td><td>可以</td><td>不可以</td></tr><tr><td>是否能设置默认值</td><td>可以</td><td>不可以</td></tr><tr><td>是否在组件里改变值</td><td>不可以</td><td>可以</td></tr><tr><td>能否给子组件设置初始值</td><td>可以</td><td>可以</td></tr><tr><td>能否在子组件里被改变值</td><td>可以</td><td>可以</td></tr></tbody></table><p><strong>总结一下</strong>：  </p><ol><li>props用于定义外部接口，使用state来存储控制当前页面逻辑的数据；  </li><li>props的赋值是在父级组件，state赋值在当前组件内部；  </li><li>props是不可变的，而state是可变的；  </li><li>使用props比state会有更好的性能；    </li></ol><h5 id="无状态组件和状态组件？"><a href="#无状态组件和状态组件？" class="headerlink" title="无状态组件和状态组件？"></a>无状态组件和状态组件？</h5><p><strong>有状态和无状态两种形式的组件：</strong>  </p><ol><li>Stateless Component（无状态组件）  </li></ol><p>只有Props,没有state，当你不需要使用组件的生命周期的时候可以考虑使用这种方式，组件的数据流向更加简洁，组件也更方便测试。</p><ol><li>Stateful Component（有状态组件）  </li></ol><p>Props和state都有使用，当你的需要再客户端保持一些数据的时候，二者会被用到；   </p><h6 id="Class-Components-vs-Functional-Components"><a href="#Class-Components-vs-Functional-Components" class="headerlink" title="Class Components vs Functional Components"></a>Class Components vs Functional Components</h6><p>Class Components写法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Hello &#123;props&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>Functional Components的写法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Hello = <span class="function">(<span class="params"> props </span>) =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello&#123;props&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure></p><h5 id="Virtual-Dom-的对比过程？"><a href="#Virtual-Dom-的对比过程？" class="headerlink" title="Virtual Dom 的对比过程？"></a>Virtual Dom 的对比过程？</h5><p>这个问题主要考察的是对React的Diff算法的了解，Diff算法究竟是如何工作的？<br>在React中最神奇的部分莫过于Virtual Dom以及diff算法，React利用这两个东西高效地解决了页面渲染的问题。<br>（暂略~）</p><h5 id="关于React组件的生命周期？"><a href="#关于React组件的生命周期？" class="headerlink" title="关于React组件的生命周期？"></a>关于React组件的生命周期？</h5><p>手绘组件生命周期及钩子函数执行流程(忽略我潦草的英文单词)：<br><img src="https://assets.wuxinhua.com/react-lifecycle.jpeg" alt><br>React组件生命周期大致分为三个阶段：装载-&gt;更新-&gt;卸载，并且在每个阶段都提供了方法(也叫“hooks”钩子)，便于我们在这些函数中更新我们的UI和应用的状态。</p><h6 id="constuctor"><a href="#constuctor" class="headerlink" title="constuctor"></a>constuctor</h6><p>当对象被创建的时候，construnctor会被调用，所以这里是最佳的地方用来初始化state,也是在组件里唯一的地方我们能够直接使用this.state来定义一个状态。</p><h6 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h6><p>当props和state都设置好，React真正进入组件生命周期阶段，第一个函数是componentWillMount,这个方法和constructor一样都是只会被调用一次，会在第一次的render调用前执行，由于还没有执行render，所以我们无法获得dom，也无法使用refs。如果需要操作dom,这并不是一个合适的地方，我之前犯得的错误是在这个位置去做ajax请求，这一点会在下面这个问题中详细讲到。这个函数能起到什么作用？貌似并不大，props和state都定义好了，如果你需要根据props来设置state，或者在更新前修改state值，可以在这里来做。</p><h6 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h6><p>componentDidMount与componentWillMount不同的地方在于componentWillMount浏览器和服务器端均可运行，而componentDidMount在服务器端无法运行，既然“装载”是一个创建组件并且放到DOM树上的过程，那么真正的“装载”是不可能在服务器来完成。这个解释是我在上在<a href="https://www.zhihu.com/people/morgancheng/activities" target="_blank" rel="noopener">@程墨</a>的<a href="http://item.jd.com/12073933.html" target="_blank" rel="noopener">《深入浅出React和Redux》</a>书中看到的。</p><p>当组件更新在DOM上之后，componentDidMount会被执行，所以在这个函数适合做以下几个事情：</p><ol><li>API接口数据的异步请求；</li><li>例如一些需要使用到DOM的库(如D3.js)，可以在这里进行初始化;</li></ol><h6 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h6><p>根据props和nextProps比较props是否发生变化，再调用setState这点都没问题，容易让人误解的地方在于它什么时候触发，它并不是props改变了会触发，即使props没有变，它仍然会执行(为什么？因为React也不知道你的props有没有发生变化，它需要在这个地方进行对比)，除非你的组件并没有传递下来的props，这个方法将不会触发，如果我们需要在props发送变化时更新我们的state，那么这里是个合适的地方。</p><h6 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h6><p>shouldComponentUpdate是生命周期函数中比较重要的函数，在使用shouldComponentUpdate(nextProps,nextState)时值得注意的几点：</p><ol><li>在初始阶段和使用forceUpdate()时都不会执行；</li><li>不用的时候默认返回true，一旦使用就必须给返回Boolean类型的值；</li><li>当子组件的state发生变化时，即使父组件返回false，也不能阻止子组件rerender；</li><li>出于性能的考虑，不建议在这个函数中使用JSON.stringify()来比较值是否改变；</li></ol><h6 id="componentWillUpdate-和-componentDidUpdate"><a href="#componentWillUpdate-和-componentDidUpdate" class="headerlink" title="componentWillUpdate 和 componentDidUpdate"></a>componentWillUpdate 和 componentDidUpdate</h6><p>在使用React的过程中，我基本没有使用到这两个函数；如果shouldComponentUpdate的返回值是true，将会执行这两个函数，</p><h6 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h6><p>在这个阶段，组件已经不再使用，需要从Dom中移除，在移除前会被执行，这个函数中可以用来做以下事情：  </p><ol><li>例如登出时，清除跟用户相关的数据、auth token等</li><li>清除setTimeout或者setInterval循环；</li></ol><h5 id="生命周期的哪个阶段异步请求数据？"><a href="#生命周期的哪个阶段异步请求数据？" class="headerlink" title="生命周期的哪个阶段异步请求数据？"></a>生命周期的哪个阶段异步请求数据？</h5><p><strong>为什么选择在componentDidMount函数中来执行ajax异步请求？</strong></p><p>根据文档的描述，在componentWillMount改变state将不会引起rerenering，cunstructor也能起到同样的作用，由于这个这个函数有点让人摸不着头脑，所以React core组的成员在讨论是否可以在将来的版本移除掉这个函数<a href="https://github.com/facebook/react/issues/7671" target="_blank" rel="noopener">issues#7671</a>，但还是有一些区别，例如在constructor中你不能使用setState方法；但是如果你使用flux框架(例如redux)来更新数据，你在这个地方请求数据，将不会出现问题。</p><p>如果你在这个函数绑定了事件处理，在componentWillUnMount里移除这些事件,在客户端这一切能很好地运行，componentWillMount也会在服务端运行，但如果是服务端渲染，componentWillUnMount将不会在服务端里执行，所以这些事件不会被移除掉。 </p><p>最主要的原因是：</p><ol><li>在componentWillUnMount中无法确保在执行render前已经获得了异步请求的数据，componentDidMount不存在这个问题；  </li><li>为了性能的需要，Fiber有了调度render执行顺序的能力，所以componentWillMount方法的执行变得不确定了；  </li><li>无法保证ajax请求在组件的更新阶段里成功返回数据，有可能当我们进行setState处理的时候，组件已经被销毁了；</li></ol><h5 id="什么是高阶组件-HOC-？"><a href="#什么是高阶组件-HOC-？" class="headerlink" title="什么是高阶组件(HOC)？"></a>什么是高阶组件(HOC)？</h5><p> React的高阶组件HOC是<code>Higher order components</code>的缩写，在React中可以简单理解为是组件包裹另一个React组件。HOC最好的学习例子是React-Redux源码中对connect的实现，Connect高阶组件，它是真正连接Redux和组件的东西，Provider在最顶层提供store，Connect通过context来接收store,并且把store中的state映射到射到组件props。简要地描述一下我理解的React-redux中connect的实现过程，源码较长，截取了其中的一部分： 大致的调用过程是：createConnect =&gt; connectAdvanced =&gt; wrapWithConnect =&gt; Connect组件，connect是一个高阶函数，也是一个柯里化函数，需要传入mapStateToProps、mapStateToProps等参数及组件，返回一个产生Component的函数（wrapWithConnect），wrapWithConnect生产出经过处理的Connect组件。<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connectAdvanced</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  selectorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    getDisplayName = name =&gt; <span class="string">`ConnectAdvanced(<span class="subst">$&#123;name&#125;</span>)`</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    ....略</span></span></span><br><span class="line"><span class="function"><span class="params">    renderCountProp = undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">    ...connectOptions</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> subscriptionKey = storeKey + <span class="string">'Subscription'</span></span><br><span class="line">  <span class="keyword">const</span> version = hotReloadingVersion++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> contextTypes = &#123;</span><br><span class="line">    [storeKey]: storeShape,</span><br><span class="line">    [subscriptionKey]: subscriptionShape,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> childContextTypes = &#123;</span><br><span class="line">    [subscriptionKey]: subscriptionShape,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> wrappedComponentName = WrappedComponent.displayName</span><br><span class="line">      || WrappedComponent.name</span><br><span class="line">      || <span class="string">'Component'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> displayName = getDisplayName(wrappedComponentName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> selectorFactoryOptions = &#123;</span><br><span class="line">      ...connectOptions,</span><br><span class="line">      getDisplayName,</span><br><span class="line">      methodName,</span><br><span class="line">      WrappedComponent</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br><span class="line">    <span class="comment">// 创建Connect组件</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">          <span class="keyword">super</span>(props, context)</span><br><span class="line">          <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">          <span class="keyword">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">          <span class="keyword">this</span>.store = props[storeKey] || context[storeKey]</span><br><span class="line">          <span class="keyword">this</span>.setWrappedInstance = <span class="keyword">this</span>.setWrappedInstance.bind(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">this</span>.initSelector()</span><br><span class="line">          <span class="keyword">this</span>.initSubscription()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getChildContext() &#123;</span><br><span class="line">          <span class="keyword">const</span> subscription = <span class="keyword">this</span>.propsMode ? <span class="literal">null</span> : <span class="keyword">this</span>.subscription</span><br><span class="line">          <span class="keyword">return</span> &#123; [subscriptionKey]: subscription || <span class="keyword">this</span>.context[subscriptionKey] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回拓展过props的Connect</span></span><br><span class="line">    <span class="keyword">return</span> hoistStatics(Connect, WrappedComponent)</span><br></pre></td></tr></table></figure></p><p>HOC提供了一些额外的能力来操作组件：例如操作Props，通过refs访问到组件实例，提取 state等，以下是高阶组件的一些使用场景：  </p><ol><li>重用代码，当我们发现需要做很多重复的事情，写重复代码的时候，可以把公用的逻辑抽离到高阶组件中来；</li><li>增加现有组件的行为，不想修改现有组件内部的逻辑，通过产生新的组件，并且实现自己需要的功能，对原组件也没有侵害；</li></ol><h5 id="React如果处理事件绑定？"><a href="#React如果处理事件绑定？" class="headerlink" title="React如果处理事件绑定？"></a>React如果处理事件绑定？</h5><p>在React中处理事件与Dom中的处理很相似，但也有一些区别：<br>在HTML中：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p><p>在JSX中：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p><p>不同在于：</p><ol><li>在React中添加事件需要使用<strong>camelCase</strong>格式；</li><li>无法使用return false的方式来阻止事件的一些默认行为，必须得使用preventDefault。</li><li>在JSX中我们传递方法作为事件的参数，而不是一个字符串；</li></ol><p>我们知道e.preventDefault是w3c定义的方法，在IE中得使用e.returnValue = false来阻止默认行为，那React是如何做到兼容的呢？<br>React使用了一个叫SyntheticEventd的对象，所有的事件继承至SyntheticEvent，并且它是跨浏览器的，它和浏览器的原生事件接口一样，包括提供stopPropagation() 和 preventDefault()方法来阻止冒泡和阻止默认行为。<br>SyntheticEvent的特点：  </p><ol><li>跨浏览器</li><li>为了性能问题，SyntheticEvent是重复利用的，无法再异步的情况下调用事件</li></ol><p><a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="noopener">Handling Events 文档</a> 以及<a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent 接口</a>  </p><h5 id="Key值如何选择？"><a href="#Key值如何选择？" class="headerlink" title="Key值如何选择？"></a>Key值如何选择？</h5><p>在我面试的时候被问了两个关于key值的问题：</p><ol><li>key值的作用？</li><li>你会怎样设置key值？</li></ol><p>刚刚接触写React代码的时候，如果没有设置key值或key值重复的情况，都会出现关于key值的warning警告，那key值起到什么作用？先来看看官方文档是怎么说的：</p><blockquote><p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</p></blockquote><p>翻译过来就是便于React用key值来标识哪些元素是改变的，新增的，或者移除的。通常我的用法是使用每项的ID来作为key值，我的写法类似下面这种：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span></span><br><span class="line">  &lt;Todo</span><br><span class="line">    &#123;...todo&#125;</span><br><span class="line">    key=&#123;item.id || index&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></p><p><br>但有时并不是所有数据项都具备ID这个字段，所以我一般还会加上下标，官方提示说不建议使用index下标来做作为key值，它可能会对性能和组件的状态造成影响。所以总结下来是：</p><ol><li>使用数据项中的ID；</li><li>生成唯一标识字符串，例如使用<a href="https://www.npmjs.com/package/shortid" target="_blank" rel="noopener">shortid</a>；  </li><li>使用index数组下标； </li></ol><p>以上。</p><h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><ol><li><a href="https://medium.freecodecamp.org/functional-setstate-is-the-future-of-react-374f30401b6b" target="_blank" rel="noopener">Functional setState is the future of React</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/25954470" target="_blank" rel="noopener">setState：这个API设计到底怎么样</a>  </li><li><a href="https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82" target="_blank" rel="noopener">setState() Gate</a>  </li><li><a href="https://stackoverflow.com/questions/23481061/reactjs-state-vs-prop" target="_blank" rel="noopener">ReactJS state vs prop</a> </li><li><a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710" target="_blank" rel="noopener">why is setState asynchronous?</a>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试的过程也是一个学习的过程，能够及时定位到自己的知识盲点或者掌握得不够好的地方，这篇内容是对一些React面试题的思考总结。&lt;br&gt;一个合格的开发者，不应该满足于写出机器可运行的代码，而应该试着去理解代码背后的一些原理和思想，我用React开发移动端应用也是一边摸索学习一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SVG动画实践</title>
    <link href="https://wuxinhua.com/2018/01/20/The-svg-animation-in-action/"/>
    <id>https://wuxinhua.com/2018/01/20/The-svg-animation-in-action/</id>
    <published>2018-01-20T03:13:03.000Z</published>
    <updated>2020-12-31T12:01:49.412Z</updated>
    
    <content type="html"><![CDATA[<p>SVG算不上是一种新技术，早在2001年的时候，已经出台了相应的规范，它是一种使用XML描述2D图形的语言，利用SVG可以做非常多炫酷的动画，结合HTML5、CSS3，SVG就变得更加强大;本篇是SVG实践总结，主要包含以下方面的内容：  </p><ol><li>关于SVG</li><li>SVG的视窗和坐标体系</li><li>SVG 实践</li><li>SVG 动画</li><li>附录  </li></ol><h4 id="关于SVG"><a href="#关于SVG" class="headerlink" title="关于SVG"></a>关于SVG</h4><p>SVG是”Scalable Vector Graphics”的简称，中文翻译成“可缩放矢量图形”，从字面意义上有两层意思：可缩放+矢量图，SVG是一种新的描述图像的方式，在这之前，我们用的较多的是以<em>.jpg、</em>.gif、*.png等后缀的图像，这类图像统称为位图，使用一个个像素点来描述图像，所以也叫点阵图；位图的缩放会出现失真的情况，当放大到一定程度会呈现出类似于马赛克的状态，而矢量图是使用点和线来描绘图形，缩放对矢量图的清晰度没有影响；类似于 HTML，SVG 也是使用元素、属性、和样式来构建文档，也存在兼容的问题，浏览器支持情况如下图所示，SVG提供了很全的元素来供我们使用，例如<code>&lt;circle&gt;</code>、 <code>&lt;ellipse&gt;</code>、<code>&lt;polyline&gt;</code>、<code>&lt;path&gt;</code>….依次代表创建圆、椭圆、曲线、路径等，其中<code>path</code>是最强大的一个标签，没有之一，文章的后面会再次提到。<br><img src="https://assets.wuxinhua.com/caniusesvg.png" alt="SVG"><br>SVG 的优势：</p><ol><li>SVG是可伸缩的，并且不依赖分辨率；</li><li>与JPEG和GIF图像比起来，体积更小；</li><li>纯粹的XML；</li><li>多种方式嵌入到网页中；</li><li>用于查看和打印高保真文档；</li></ol><h4 id="SVG的坐标体系"><a href="#SVG的坐标体系" class="headerlink" title="SVG的坐标体系"></a>SVG的坐标体系</h4><p>在进行SVG开发之前，由于不熟悉SVG的viewport、viewBox、坐标系等概念，饶了一些弯路，先熟悉一下viewBox视窗、坐标这几个概念：  </p><h5 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h5><p>浏览器也有一个viewport，SVG的viewport与之类似，不同的是SVG这个窗口是可以修改的，“视窗”定义了我们以多大的区域来绘制SVG，这个概念类似于Canvas的画布，可以通过width和height来定义viewport,例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- the viewport 大小为 500px 500px --&gt;</span><br><span class="line">&lt;svg width=&quot;500&quot; height=&quot;500&quot;&gt;</span><br><span class="line">    &lt;!-- SVG content --&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></p><p>视窗可以指定具体的单位，如果没有给定，默认使用“px”单位，支持以下单位：px, %, pc, pt, mm, cm, in, ex, em, 不支持rem、vh、vw等单位。</p><h6 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h6><p>SVG的坐标系和标准的笛卡尔直角坐标系还有点区别，svg坐标系的原点(0,0)位于左上角XY轴交叉点，X轴向右为正方向，向下为Y轴的正方向。</p><h5 id="viewBox"><a href="#viewBox" class="headerlink" title="viewBox"></a>viewBox</h5><p>viewBox顾名思意“视区盒子”，viewBox和viewport有点让人傻傻分不清楚，其实viewBox是在viewport外存在的另一个坐标体系，用来辅助定义SVG的可视范围，我的理解是类似于使用截屏软件时，viewBox即截图框区域大小，我们可以移动这个框来选择截取位置，既能截全屏，也可以截取特定区域；当没有定义viewBox时，viewBox默认为viewport的大小，viewBox定义四个坐标，分别是：x  y  width  height，x:左上角横坐标，y:左上角纵坐标，width:宽度，height:高度，通过下面的代码来查看viewBox起的作用：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- the viewport 大小为 300px 300px --&gt;</span><br><span class="line">&lt;svg class=&quot;circle-chart&quot; width=&quot;300&quot; height=&quot;300&quot;  xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">      &lt;circle class=&quot;pie&quot; stroke=&quot;#4285f4&quot; stroke-width=&quot;20&quot; stroke-dasharray=&quot;400,0&quot; stroke-linecap=&quot;round&quot; fill=&quot;none&quot; cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;63.66197723675813&quot; /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>viewport的宽高均为300，定义一个圆心坐标为（0.0），周长为400的圆，那么圆半径 r = 400 / 2 * Math.PI = 63.66197723675813，圆的边宽度为30，即图中蓝色部分，在没有设置viewBox值的情况下，SVG的视区大小默认为viewport大小，由于坐标原点在左上角，所以我们只看到了圆环的右下1 / 4部分(图中#1所示)，如果想看到整个圆环，那么需要将viewBox视角往左上角方向移动，移动的距离为： r + stroke-width / 2 = 73.66197723675813的距离，如代码例子#2所示：</p><blockquote><p>viewBox=”-73.66197723675813 -73.66197723675813 300 300”</p></blockquote><p>但这并不是我想要的，我需要将圆环放置在视图的中心位置，那么viewBox的x、y坐标均为-150即可(如代码例子#3所示)  </p><blockquote><p>viewBox=”-150 -150 300 300”  </p></blockquote><h4 id="PreserveAspectRatio属性"><a href="#PreserveAspectRatio属性" class="headerlink" title="PreserveAspectRatio属性"></a>PreserveAspectRatio属性</h4><p>如果viewport和viewBox的宽高比不相同，你需要自己来指定如何在SVG阅读器（如浏览器）中显示SVG图像，你可以在SVG中使用preserveAspectRatio属性来指定，preserveAspetRation属性指出了如何缩放及如果对齐viewBox到viewport上,defer参数是可选值，它仅仅在image元素上应用preserveAspectRatio属性时才使用。preserveAspectRatio的align参数是否强制进行均匀的缩放,如果align设置为none，图形会被缩放以适应viewport大小，而不会管它的宽高比。可以将它想象为CSS中的background-position属性,viewBox就好像是背景图像，使用不同的align值就好比在viewport中使用不同的background-position值来定位viewBox一样，</p><blockquote><p>preserveAspectRatio = defer? align meetOrSlice    </p></blockquote><p>align有以下9种取值：<br><strong>xMinYMin</strong>：viewBox的<min-x>对齐viewport的最小X值，min-y对齐viewport的最小Y值。<br><strong>xMinYMid</strong>：viewBox的<min-x>对齐viewport的最小X值，viewBox的Y轴中点对齐viewport的Y轴中点。<br><strong>xMinYMax</strong>：viewBox的<min-x>对齐viewport的最小X值，min-y+<height>对齐viewport的最大Y值。<br><strong>xMidYMin</strong>：viewBox的X轴中点对齐viewport的X轴中点，min-y对齐viewport的最小Y值。<br><strong>xMidYMid（默认值）</strong>：viewBox的X轴中点对齐viewport的X轴中点，viewBox的Y轴中点对齐viewport的Y轴中点。<br><strong>xMidYMax</strong>：viewBox的X轴中点对齐viewport的X轴中点，min-y+<height>对齐viewport的最大Y值。<br><strong>xMaxYMin</strong>：viewBox的<min-x>+<width>对齐viewportX轴的最大值，min-y对齐viewport的最小Y值。<br><strong>xMaxYMid</strong>：viewBox的<min-x>+<width>对齐viewportX轴的最大值，viewBox的Y轴中点对齐viewport的Y轴中点。<br><strong>xMaxYMax</strong>：viewBox的<min-x>+<width>对齐viewportX轴的最大值，min-y+<height>对齐viewport的最大Y值。  </height></width></min-x></width></min-x></width></min-x></height></height></min-x></min-x></min-x></p><h4 id="SVG实践"><a href="#SVG实践" class="headerlink" title="SVG实践"></a>SVG实践</h4><h5 id="利用SVG实现一个环形图表"><a href="#利用SVG实现一个环形图表" class="headerlink" title="利用SVG实现一个环形图表"></a>利用SVG实现一个环形图表</h5><p>给定数据，利用SVG实现一个类似甜甜圈🍩的按百分比划分的环形图，如下图所示:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">                &#123;<span class="attr">value</span>:<span class="number">335</span>, <span class="attr">name</span>:<span class="string">'直接访问'</span>&#125;, <span class="comment">// pie1</span></span><br><span class="line">                &#123;<span class="attr">value</span>:<span class="number">310</span>, <span class="attr">name</span>:<span class="string">'邮件营销'</span>&#125;, <span class="comment">// pie2</span></span><br><span class="line">                &#123;<span class="attr">value</span>:<span class="number">234</span>, <span class="attr">name</span>:<span class="string">'联盟广告'</span>&#125;, <span class="comment">// pie3</span></span><br><span class="line">                &#123;<span class="attr">value</span>:<span class="number">135</span>, <span class="attr">name</span>:<span class="string">'视频广告'</span>&#125;, <span class="comment">// pie4</span></span><br><span class="line">                &#123;<span class="attr">value</span>:<span class="number">1548</span>, <span class="attr">name</span>:<span class="string">'搜索引擎'</span>&#125; <span class="comment">// pie5</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p><img src="https://assets.wuxinhua.com/blog/assets/echart-donus.png" alt="donut"></p><p><strong>两种思路：</strong></p><ol><li>利用描边和偏移stroke-dashoffset来完成（下面#4中例子）;  </li><li>按比例确定扇区的起始位置，利用path绘制各饼图，中间部分用另一个圆形遮盖 ;  </li></ol><p>按第一种思路，利用SVG神奇的stroke属性来帮我们完成绘图,stroke包含以下几个属性：<br>  <strong>stroke-width</strong>: 定义一条线，文本或元素轮廓厚度<br>  <strong>stroke-linecap</strong>: 描边端点表现形式 butt、round、square<br>  <strong>stroke-dasharray</strong>: 用于创建虚线<br>  <strong>stroke-dashoffset</strong>: 偏移位置<br>利用dasharray画出第一个扇区，描边的长度等于它弧长，第二个扇区偏移至第一个扇区结束位置，理一下描边思路，伪代码如下： <br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">// 总数</span><br><span class="line">lat total = 335 + 310 + 234 + 135 + 1548 ; // 2562</span><br><span class="line">// 周长</span><br><span class="line">let circumference = 400;</span><br><span class="line">// pie1扇区的弧长</span><br><span class="line">dash1 = 335 / total * circumference;  // 52.30288836846214</span><br><span class="line">offset1 = 0;</span><br><span class="line">// pie2弧长算法同pie1,第二个扇区的偏移dashoffset</span><br><span class="line">offset2 = 周长 - 之前扇区的周长 + 第一个扇区的偏移量</span><br><span class="line">~ 以此类推求出每个扇区的dasharray值 和 dashoffset值</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 虚线值和偏移量值</span><br><span class="line"><span class="selector-class">.chart5</span> <span class="selector-tag">circle</span><span class="selector-class">.pie1</span> &#123;</span><br><span class="line">  <span class="attribute">stroke-dasharray</span>: <span class="number">52.30288836846214</span> <span class="number">347.69711163153784</span>;</span><br><span class="line">  <span class="attribute">stroke-dashoffset</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.chart5</span> <span class="selector-tag">circle</span><span class="selector-class">.pie2</span> &#123;</span><br><span class="line">  <span class="attribute">stroke-dasharray</span>: <span class="number">48.39968774395004</span> <span class="number">351.60031225604996</span>;</span><br><span class="line">  <span class="attribute">stroke-dashoffset</span>: <span class="number">347.69711163153784</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.chart5</span> <span class="selector-tag">circle</span><span class="selector-class">.pie3</span> &#123;</span><br><span class="line">  <span class="attribute">stroke-dasharray</span>: <span class="number">36.53395784543326</span> <span class="number">363.46604215456676</span>;</span><br><span class="line">  <span class="attribute">stroke-dashoffset</span>: <span class="number">299.2974238875878</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.chart5</span> <span class="selector-tag">circle</span><span class="selector-class">.pie4</span> &#123;</span><br><span class="line">  <span class="attribute">stroke-dasharray</span>: <span class="number">21.07728337236534</span> <span class="number">378.92271662763466</span>;</span><br><span class="line">  <span class="attribute">stroke-dashoffset</span>: <span class="number">262.76346604215456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.chart5</span> <span class="selector-tag">circle</span><span class="selector-class">.pie5</span> &#123;</span><br><span class="line">  <span class="attribute">stroke-dasharray</span>: <span class="number">241.68618266978922</span> <span class="number">158.31381733021078</span>;</span><br><span class="line">  <span class="attribute">stroke-dashoffset</span>: <span class="number">241.68618266978922</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环形图结果如下图#6所示：  </p><iframe height="375" scrolling="no" title="svg_pie_chart" src="//codepen.io/amnEs1a/embed/wpNWWq/?height=375&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/amnEs1a/pen/wpNWWq/" target="_blank" rel="noopener">svg_pie_chart</a> by kevin (<a href="https://codepen.io/amnEs1a" target="_blank" rel="noopener">@amnEs1a</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h4 id="SVG-动画"><a href="#SVG-动画" class="headerlink" title="SVG 动画"></a>SVG 动画</h4><p>上面#4的例子就是使用css3的Animation来实现的，因为SVG类似于 HTML，所以CSS3的三大利器(Transitions, Transforms和Animation)同样适用于SVG；SVG的动画还可以通过定义animation elements标签来实现（#5例子），这些标签最初是在<code>SMIL</code>动画规范中定义的，CSS能做的SMIL都能做，如果你偏向于使用JavaScript，可以试试<a href="http://snapsvg.io/" target="_blank" rel="noopener">snapsvg</a>；</p><blockquote><p>the Snap.svg JavaScript library makes working with your SVG assets as easy as jQuery makes working with the DOM.  </p></blockquote><p>snapsvg被定义为<code>SVG界的jQuery</code>，让我们更方便得定义SVG动画。JavaScript实现动画的缺点是当SVG嵌入到img标签或者作为背景图片放入background-image属性中时，动画不起作用，但是例如SVG的path标签，通过定义d属性值来定义path的形状，这部分又无法通过CSS来实现，所以SIML可以说是弥补以上两者的一些缺陷，这里介绍一下使用SVG的SMIL；<br>SMIL允许：  </p><ol><li>变动一个元素的数字属性（x、y……）  </li><li>变动变形属性（translation或rotation）  </li><li>将颜色属性作为动画  </li><li>按照运动轨迹移动  </li></ol><blockquote><p>As of Chrome 45.0, SMIL animations are deprecated in favor of CSS animations and Web animations .    </p></blockquote><p>来看下浏览器对SMIL的支持情况，值得注意的是自Chrome 45.0起，SMIL动画就被废弃了，并且会在console中给出警告提示，推荐使用CSS动画和Web动画。<br>前面三个CSS3基本都能实现，厉害的是第4个，来体验一下SVG实现动画的几种方式：  </p><h5 id="animate属性"><a href="#animate属性" class="headerlink" title="animate属性"></a>animate属性</h5><p>通过添加SVG动画元素，比如<animate>到SVG元素内部来实现动画，对<animate> 元素来说，重要的属性有：<br>attributeName：变动的属性的属性名。<br>attributeType：属性类型<br>from：变动的初始值。<br>to：变动的终值<br>dur：动画的持续时间<br>fill: 是否保留动画结果<br>repeatCount： 重复次数indefinite表示无限重复  </animate></animate></p><p>会发现类似于CSS3 animate的定义方式，如何把我们写的animate标签作用于SVG上呢？SMIL提供了两种方式：  </p><ol><li>将animate标签放包裹在SVG标签中：  </li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"chart5"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">animate</span> <span class="attr">...</span> /&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- animate动画标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>使用<code>xlink:href</code>属性，指定作用于对应id标签：  </li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"chart5"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">animate</span> <span class="attr">xlink:href</span>=<span class="string">"#chart5"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">circle</span> &gt;</span></span><br></pre></td></tr></table></figure><p>但省略xlink:href属性值后，动画默认作用于当前位置的父节点标签。  </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"chart5"</span> <span class="attr">class</span>=<span class="string">"pie"</span> <span class="attr">stroke-linecap</span>=<span class="string">"round"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">cx</span>=<span class="string">"0"</span> <span class="attr">cy</span>=<span class="string">"0"</span> <span class="attr">r</span>=<span class="string">"63.66197723675813"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animate</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">xlink:href</span>=<span class="string">"#chart5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">attributeName</span>=<span class="string">"stroke-dashoffset"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">from</span>=<span class="string">"400"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">to</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">dur</span>=<span class="string">"6s"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">fill</span>=<span class="string">"remove"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>例如上述代码定义了attributeName属性名为：<code>stroke-dashoffset</code>，在6s的时间内从400转换到0，<code>repeatCount</code>表示动画重复次数，<code>fill</code>类似于<code>animation-fill-mode</code>属性定义动画结束后是否回到最初的状态，有两个值：</p><ol><li>freeze 表示保留动画结束时的属性值；  </li><li>remove 动画属性将被移除，默认是remove；  </li></ol><h5 id="animateTransform"><a href="#animateTransform" class="headerlink" title="animateTransform"></a>animateTransform</h5><p><code>&lt;animateTransform&gt;</code>元素可以执行变换属性的动画。这里的transform与CSS3的transform类似，例如需要执行一个旋转的动画，可以像下面这样定义：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animateTransform</span> <span class="attr">attributeName</span>=<span class="string">"transform"</span> <span class="attr">begin</span>=<span class="string">"0s"</span> <span class="attr">dur</span>=<span class="string">"2s"</span>  <span class="attr">type</span>=<span class="string">"rotate"</span> <span class="attr">from</span>=<span class="string">"0deg"</span> <span class="attr">to</span>=<span class="string">"180deg"</span> <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="animateMotion"><a href="#animateMotion" class="headerlink" title="animateMotion"></a>animateMotion</h5><p>animateMotion元素可以让SVG各种图形沿着特定的path路径运动，例如：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animateMotion</span> <span class="attr">path</span>=<span class="string">"M10,80"</span> <span class="attr">begin</span>=<span class="string">"0s"</span> <span class="attr">dur</span>=<span class="string">"2s"</span> <span class="attr">repeatCount</span>=<span class="string">"indefinite"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="利用SVG动画实现一个跳动的心❤️"><a href="#利用SVG动画实现一个跳动的心❤️" class="headerlink" title="利用SVG动画实现一个跳动的心❤️"></a>利用SVG动画实现一个跳动的心❤️</h5><p>这里将使用到<code>path</code>标签，可以把path理解成画笔，你只需要给定画笔移动的位置，path将完成绘图工作，path元素的形状是通过属性d定义的，属性d的值是一个“命令+参数”的序列，因为属性d采用的是用户坐标系统，所以不需标明单位，所以使用path绘图的前提是获得图形的：坐标 + 命令 + 参数；<br>path的命令用字母表示，有对应的含义，大写字母表示绝对定位，小写字母表示相对定位，例如：</p><blockquote><p> M 代表“移动到”某个位置<br>  L 代表直线<br>  Z 代表结束闭合路径<br>  ···</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">"path_ract"</span> <span class="attr">d</span>=<span class="string">"M0,0 L0,150 150,150 150,0 z"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--从原点(0 , 0)的位置移动到(0 , 150)、（150,150）、（150,0 ） 再回到原点，并且画直线--&gt;</span></span><br></pre></td></tr></table></figure><p>圆的d值比较复杂，给出画圆的d值公式，圆心坐标(cx, cy) 半径为r：</p><pre><code class="html">&lt;path    d=&quot;      M cx cy      m -r, 0      a r,r 0 1,0 (r * 2),0      a r,r 0 1,0 -(r * 2),0    &quot;/&gt;</code></pre><pre><code class="Javascript"><span class="comment">// 圆心坐标(cx, cy) 半径r</span><span class="function"><span class="keyword">function</span> <span class="title">getcirclePath</span>(<span class="params">cx, cy, r</span>)</span>{    <span class="keyword">return</span> <span class="string">'M '</span>+cx+<span class="string">' '</span>+cy+<span class="string">' m -'</span>+r+<span class="string">', 0 a '</span>+r+<span class="string">','</span>+r+<span class="string">' 0 1,0 '</span>+(r*<span class="number">2</span>)+<span class="string">',0 a '</span>+r+<span class="string">','</span>+r+<span class="string">' 0 1,0 -'</span>+(r*<span class="number">2</span>)+<span class="string">',0'</span>;}</code></pre><p>思路如下图所示，先利用path画一个正方形和两个圆，将圆分别向上和向右移动半径的距离，效果如下图所示<a href="https://codepen.io/amnEs1a/pen/ZvZOKr" target="_blank" rel="noopener">#codepen地址</a>，整个动画过程是使用SVG SMIL实现，可点击codepen的“return”按钮查看整个画图过程。<br><img src="https://assets.wuxinhua.com/heart.png" alt> </p><iframe height="357" scrolling="no" title="svg_heart_animation" src="//codepen.io/amnEs1a/embed/ZvZOKr/?height=357&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/amnEs1a/pen/ZvZOKr/" target="_blank" rel="noopener">svg_heart_animation</a> by kevin (<a href="https://codepen.io/amnEs1a" target="_blank" rel="noopener">@amnEs1a</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>    <p>之前在网上看了很多很酷炫的HTML5/SVG动画，这次自己用代码算是简单体验了一下，SVG确实很强大，好好利用起来，可以创造出很多有意思的事情，希望以上对刚刚接触到SVG的童鞋能有所启发和帮助，这期间翻了很资料和博客内容，包括SVG动画、Canvas和SVG的对比、大漠、张鑫旭写的这方面的文章等等，具体我列在下面的附录列表上；</p><h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><p>1.理解SVG的坐标系和转换<br>  <a href="http://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">Part 1 — The viewport, viewBox, and preserveAspectRatio</a><br>  <a href="http://www.sarasoueidan.com/blog/svg-transformations/" target="_blank" rel="noopener">Part 2 - The transform Attribute</a><br>  <a href="http://sarasoueidan.com/blog/nesting-svgs" target="_blank" rel="noopener">Part 3 - Establishing New Viewports</a><br>2.<a href="http://tutorials.jenkov.com/svg/svg-viewport-view-box.html" target="_blank" rel="noopener">SVG - Scalable Vector Graphics教程</a><br>3.<a href="https://www.w3cplus.com/html5/svg-coordinates.html" target="_blank" rel="noopener">大漠老师的SVG系列教程</a><br>4.<a href="http://www.w3cplus.com/html5/svg-viewport-viewbox-preserveaspectratio.html" target="_blank" rel="noopener">理解SVG的viewport,viewBox,preserveAspectRatio</a><br>5.<a href="http://jonibologna.com/svg-viewbox-and-viewport/" target="_blank" rel="noopener">A Look At SVG viewBox and viewport</a><br>6.<a href="https://msdn.microsoft.com/library/gg193983.aspx" target="_blank" rel="noopener">SVG 与 Canvas：如何选择</a><br>7.<a href="http://www.zhangxinxu.com/wordpress/category/graphic/svg-graphic/" target="_blank" rel="noopener">SVG相关目录存档-张鑫旭</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SVG算不上是一种新技术，早在2001年的时候，已经出台了相应的规范，它是一种使用XML描述2D图形的语言，利用SVG可以做非常多炫酷的动画，结合HTML5、CSS3，SVG就变得更加强大;本篇是SVG实践总结，主要包含以下方面的内容：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关于S
      
    
    </summary>
    
    
      <category term="SVG" scheme="https://wuxinhua.com/tags/SVG/"/>
    
  </entry>
  
</feed>
